<?xml version="1.0" encoding="ascii"?>
<!-- File naming: DA1459x-00.xml -->
<!--
  Copyright (C) 2020-2023 Renesas Electronics Corporation and/or its affiliates.
  All rights reserved. Confidential Information.

  This software ("Software") is supplied by Renesas Electronics Corporation and/or its
  affiliates ("Renesas"). Renesas grants you a personal, non-exclusive, non-transferable,
  revocable, non-sub-licensable right and license to use the Software, solely if used in
  or together with Renesas products. You may make copies of this Software, provided this
  copyright notice and disclaimer ("Notice") is included in all such copies. Renesas
  reserves the right to change or discontinue the Software at any time without notice.

  THE SOFTWARE IS PROVIDED "AS IS". RENESAS DISCLAIMS ALL WARRANTIES OF ANY KIND,
  WHETHER EXPRESS, IMPLIED, OR STATUTORY, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
  OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. TO THE
  MAXIMUM EXTENT PERMITTED UNDER LAW, IN NO EVENT SHALL RENESAS BE LIABLE FOR ANY DIRECT,
  INDIRECT, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING FROM, OUT OF OR IN
  CONNECTION WITH THE SOFTWARE, EVEN IF RENESAS HAS BEEN ADVISED OF THE POSSIBILITY OF
  SUCH DAMAGES. USE OF THIS SOFTWARE MAY BE SUBJECT TO TERMS AND CONDITIONS CONTAINED IN
  AN ADDITIONAL AGREEMENT BETWEEN YOU AND RENESAS. IN CASE OF CONFLICT BETWEEN THE TERMS
  OF THIS NOTICE AND ANY SUCH ADDITIONAL LICENSE AGREEMENT, THE TERMS OF THE AGREEMENT
  SHALL TAKE PRECEDENCE. BY CONTINUING TO USE THIS SOFTWARE, YOU AGREE TO THE TERMS OF
  THIS NOTICE.IF YOU DO NOT AGREE TO THESE TERMS, YOU ARE NOT PERMITTED TO USE THIS
  SOFTWARE.

  Purpose: System Viewer Description (SVD) DA1459x (Schema Version 1.3)

  Generated by cmsis-svd (version 0.2), d.d. October 10, 2023 - 09:23:32
  Last Modified by Renesas Electronics Corporation and/or its affiliates on October 10, 2023 - 12:46:04
 -->
<device xmlns:xs="http://www.w3.org/2001/XMLSchema-instance" schemaVersion="1.3" xs:noNamespaceSchemaLocation="CMSIS-SVD.xsd">
  <vendor>Renesas Electronics Corporation</vendor>                   				    <!-- device vendor name -->
  <vendorID>RENESAS</vendorID>                                        <!-- device vendor short name -->
  <name>DA1459x</name>                                          <!-- name of part-->
  <series>DA1459x</series>                                         <!-- device series the device belongs to -->
  <version>1.2</version>                                          <!-- version of this description, adding CMSIS-SVD 1.1 tags -->
  <description>DA1459x - Multi-core BLE 5.2 SoC family with embedded FLASH</description>
  <licenseText><!-- this license text will appear in header file. \n forces line breaks -->
  Copyright (C) 2020-2023 Renesas Electronics Corporation and/or its affiliates.\n
  All rights reserved. Confidential Information.\n

  This software ("Software") is supplied by Renesas Electronics Corporation and/or its\n
  affiliates ("Renesas"). Renesas grants you a personal, non-exclusive, non-transferable,\n
  revocable, non-sub-licensable right and license to use the Software, solely if used in\n
  or together with Renesas products. You may make copies of this Software, provided this\n
  copyright notice and disclaimer ("Notice") is included in all such copies. Renesas\n
  reserves the right to change or discontinue the Software at any time without notice.\n

  THE SOFTWARE IS PROVIDED "AS IS". RENESAS DISCLAIMS ALL WARRANTIES OF ANY KIND,\n
  WHETHER EXPRESS, IMPLIED, OR STATUTORY, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\n
  OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. TO THE\n
  MAXIMUM EXTENT PERMITTED UNDER LAW, IN NO EVENT SHALL RENESAS BE LIABLE FOR ANY DIRECT,\n
  INDIRECT, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING FROM, OUT OF OR IN\n
  CONNECTION WITH THE SOFTWARE, EVEN IF RENESAS HAS BEEN ADVISED OF THE POSSIBILITY OF\n
  SUCH DAMAGES. USE OF THIS SOFTWARE MAY BE SUBJECT TO TERMS AND CONDITIONS CONTAINED IN\n
  AN ADDITIONAL AGREEMENT BETWEEN YOU AND RENESAS. IN CASE OF CONFLICT BETWEEN THE TERMS\n
  OF THIS NOTICE AND ANY SUCH ADDITIONAL LICENSE AGREEMENT, THE TERMS OF THE AGREEMENT\n
  SHALL TAKE PRECEDENCE. BY CONTINUING TO USE THIS SOFTWARE, YOU AGREE TO THE TERMS OF\n
  THIS NOTICE.IF YOU DO NOT AGREE TO THESE TERMS, YOU ARE NOT PERMITTED TO USE THIS\n
  SOFTWARE.
  </licenseText>
  <cpu><!-- details about the cpu embedded in the device (SVD version 1.2,  see https://www.keil.com/pack/doc/CMSIS/SVD/html/group__cpu_section__gr.html) -->
    <name>CM33</name>
    <revision>r0p2</revision>
    <endian>little</endian>
    <mpuPresent>true</mpuPresent>
    <fpuPresent>true</fpuPresent>
    <nvicPrioBits>4</nvicPrioBits>
    <vendorSystickConfig>false</vendorSystickConfig>
		<vtorPresent>true</vtorPresent><sauNumRegions>0</sauNumRegions><dspPresent>true</dspPresent>
  </cpu>
  <addressUnitBits>8</addressUnitBits>                            <!-- byte addressable memory -->
  <width>32</width>                                               <!-- bus width is 32 bits -->
  <!-- default settings implicitly inherited by subsequent sections -->
  <size>32</size>                                                 <!-- this is the default size (number of bits) of all peripherals
																																									 and register that do not define "size" themselves -->
  <access>read-write</access>                                     <!-- default access permission for all subsequent registers -->
  <resetValue>0x00000000</resetValue>                             <!-- by default all bits of the registers are initialized to 0 on reset -->
  <resetMask>0xFFFFFFFF</resetMask>                               <!-- by default all 32Bits of the registers are used -->

  <peripherals>
	<peripheral>
	<name>AES_HASH</name>
	<version>1.0</version>
	<description>AES_HASH registers</description>
	<groupName>Peripheral_Registers</groupName>
	<baseAddress>0x30040000</baseAddress>
	<size>0</size>
	<addressBlock>
	<offset>0</offset>
	<size>260</size>
	<usage>registers</usage>
</addressBlock>
	<interrupt>
	<name>RESERVED0</name>
	<description>Reserved interrupt request.</description>
	<value>0</value>
</interrupt><interrupt>
	<name>DMA</name>
	<description>General Purpose DMA interrupt request.</description>
	<value>1</value>
</interrupt><interrupt>
	<name>CMAC2SYS</name>
	<description>CMAC and mailbox interrupt request.</description>
	<value>2</value>
</interrupt><interrupt>
	<name>UART</name>
	<description>UART interrupt request.</description>
	<value>3</value>
</interrupt><interrupt>
	<name>UART2</name>
	<description>UART2 interrupt request.</description>
	<value>4</value>
</interrupt><interrupt>
	<name>I2C</name>
	<description>I2C interrupt request.</description>
	<value>5</value>
</interrupt><interrupt>
	<name>SPI</name>
	<description>SPI interrupt request.</description>
	<value>6</value>
</interrupt><interrupt>
	<name>FCU</name>
	<description>FCU/eFlash interrupt request.</description>
	<value>7</value>
</interrupt><interrupt>
	<name>PCM</name>
	<description>PCM interrupt request.</description>
	<value>8</value>
</interrupt><interrupt>
	<name>SRC_IN</name>
	<description>SRC input interrupt request.</description>
	<value>9</value>
</interrupt><interrupt>
	<name>SRC_OUT</name>
	<description>SRC output interrupt request.</description>
	<value>10</value>
</interrupt><interrupt>
	<name>SRC2_IN</name>
	<description>SRC2 input interrupt request.</description>
	<value>11</value>
</interrupt><interrupt>
	<name>SRC2_OUT</name>
	<description>SRC2 output interrupt request.</description>
	<value>12</value>
</interrupt><interrupt>
	<name>MDCT</name>
	<description>Modified Discrete Cosine Transform interrupt request.</description>
	<value>13</value>
</interrupt><interrupt>
	<name>TIMER</name>
	<description>TIMER interrupt request.</description>
	<value>14</value>
</interrupt><interrupt>
	<name>TIMER2</name>
	<description>TIMER2 interrupt request.</description>
	<value>15</value>
</interrupt><interrupt>
	<name>RTC</name>
	<description>RTC interrupt request.</description>
	<value>16</value>
</interrupt><interrupt>
	<name>KEY_WKUP_GPIO</name>
	<description>Debounced button press interrupt request.</description>
	<value>17</value>
</interrupt><interrupt>
	<name>PDC_M33</name>
	<description>Wakeup from PDC to CM33 interrupt request.</description>
	<value>18</value>
</interrupt><interrupt>
	<name>MRM</name>
	<description>Cache Miss Rate Monitor interrupt request.</description>
	<value>19</value>
</interrupt><interrupt>
	<name>RESERVED20</name>
	<description>Reserved (software) interrupt request.</description>
	<value>20</value>
</interrupt><interrupt>
	<name>QUADDEC</name>
	<description>Quadrature Decoder interrupt request.</description>
	<value>21</value>
</interrupt><interrupt>
	<name>RESERVED22</name>
	<description>Reserved (software) interrupt request.</description>
	<value>22</value>
</interrupt><interrupt>
	<name>XTAL32M_RDY</name>
	<description>XTAL32M trimmed and ready interrupt request.</description>
	<value>23</value>
</interrupt><interrupt>
	<name>CLK_CALIBRATION</name>
	<description>Clock calibration successfully interrupt request.</description>
	<value>24</value>
</interrupt><interrupt>
	<name>GPADC</name>
	<description>General Purpose / SAR  Analog-Digital Converter interrupt request.</description>
	<value>25</value>
</interrupt><interrupt>
	<name>SDADC</name>
	<description>Sigma Delta Analog-Digital Converter interrupt request.</description>
	<value>26</value>
</interrupt><interrupt>
	<name>CRYPTO</name>
	<description>Crypto interrupt request. Sources: AES or HASH function interrupt.</description>
	<value>27</value>
</interrupt><interrupt>
	<name>CAPTIMER</name>
	<description>GPIO triggered Capture Timer interrupt request.</description>
	<value>28</value>
</interrupt><interrupt>
	<name>RFDIAG</name>
	<description>Baseband or Radio Diagnostics interrupt request.</description>
	<value>29</value>
</interrupt><interrupt>
	<name>TIMER3</name>
	<description>TIMER3 interrupt request.</description>
	<value>30</value>
</interrupt><interrupt>
	<name>TIMER4</name>
	<description>TIMER4 interrupt request.</description>
	<value>31</value>
</interrupt><interrupt>
	<name>RTC_EVENT</name>
	<description>RTC event interrupt request.</description>
	<value>32</value>
</interrupt><interrupt>
	<name>GPIO_P0</name>
	<description>GPIO port 0 toggle interrupt request.</description>
	<value>33</value>
</interrupt><interrupt>
	<name>GPIO_P1</name>
	<description>GPIO port 1 toggle interrupt request. </description>
	<value>34</value>
</interrupt>
	<registers>
	<register>
	<name>CRYPTO_CLRIRQ_REG</name>
	<description>Crypto Clear interrupt request</description>
	<addressOffset>0x00000018</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00000001</resetMask>
	<fields><field>
	<name>CRYPTO_CLRIRQ</name>
	<description>Write 1 to clear a pending interrupt request.</description>
	<bitRange>[0:0]</bitRange>
	<access>write-only</access>
	</field></fields>
</register><register>
	<name>CRYPTO_CTRL_REG</name>
	<description>Crypto Control register</description>
	<addressOffset>0x00000000</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0001ffff</resetMask>
	<fields><field>
	<name>CRYPTO_AES_KEXP</name>
	<description>It forces (active high) the execution of the key expansion process with the starting of the AES encryption/decryption process. The bit will be cleared automatically by the hardware, after the completion of the AES key expansion process.</description>
	<bitRange>[16:16]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>CRYPTO_MORE_IN</name>
	<description>0: Define that this is the last input block. When the current input is consumed by the crypto engine and the output data is written to the memory, the calculation ends (CRYPTO_INACTIVE goes to one).
1: The current input data block is not the last. More input data will follow. When the current input is consumed, the engine stops and waits for more data (CRYPTO_WAIT_FOR_IN goes to one).</description>
	<bitRange>[15:15]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>CRYPTO_HASH_OUT_LEN</name>
	<description>The number of bytes minus one of the hash result which will be saved at the memory by the DMA. In relation with the selected hash algorithm the accepted values are:
SHA-256: 0..31 -&gt; 1 - 32 bytes
SHA-256/224: 0..27 -&gt; 1- 28 bytes</description>
	<bitRange>[14:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>CRYPTO_HASH_SEL</name>
	<description>Selects the type of the algorithm
0: The encryption algorithm (AES)
1: A hash algorithm.
The exact algorithm is defined by the CRYPTO_ALG and CRYPTO_ALG_MD fields.</description>
	<bitRange>[9:9]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>CRYPTO_IRQ_EN</name>
	<description>Interrupt Request Enable
0: The interrupt generation ability is disabled.
1: The interrupt generation ability is enabled. Generates an interrupt request at the end of operation.</description>
	<bitRange>[8:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>CRYPTO_ENCDEC</name>
	<description>Encryption/Decryption
0: Decryption
1: Encryption</description>
	<bitRange>[7:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>CRYPTO_AES_KEY_SZ</name>
	<description>The size of AES Key
0x0: 128 bits AES Key
0x1: 192 bits AES Key
0x2: 256 bits AES Key
0x3: 256 bits AES Key</description>
	<bitRange>[6:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>CRYPTO_OUT_MD</name>
	<description>Output Mode. This field makes sense only when the AES algorithm is selected (CRYPTO_HASH_SEL = 0)
0: Write back to memory all the resulting data
1: Write back to memory only the final block of the resulting data</description>
	<bitRange>[4:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>CRYPTO_ALG_MD</name>
	<description>It defines the mode of operation of the AES algorithm when the controller is configured for an encryption/decryption processing (CRYPTO_HASH_SEL = 0).
0x0: ECB
0x1: ECB
0x2: CTR
0x3: CBC</description>
	<bitRange>[3:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>CRYPTO_ALG</name>
	<description>Algorithm selection.
When CRYPTO_HASH_SEL = 0, the only available choice is the AES algorithm.
0x0: AES
0x1: Reserved
0x2: Reserved
0x3: Reserved
When CRYPTO_HASH_SEL = 1, this field selects the desired hash algorithm.
0x0 or 0x2: SHA-256/224
0x1 or 0x3: SHA-256</description>
	<bitRange>[1:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>CRYPTO_DEST_ADDR_REG</name>
	<description>Crypto DMA destination memory</description>
	<addressOffset>0x00000010</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0xffffffff</resetMask>
	<fields><field>
	<name>CRYPTO_DEST_ADDR</name>
	<description>Destination address at where the result of the processing is stored. The value of this register is updated as the calculation proceeds and the output data are written to the memory.</description>
	<bitRange>[31:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>CRYPTO_FETCH_ADDR_REG</name>
	<description>Crypto DMA fetch register</description>
	<addressOffset>0x00000008</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0xffffffff</resetMask>
	<fields><field>
	<name>CRYPTO_FETCH_ADDR</name>
	<description>The memory address from where will be retrieved the data that will be processed. The value of this register is updated as the calculation proceeds and the output data are written to the memory.</description>
	<bitRange>[31:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>CRYPTO_KEYS_START</name>
	<description>Crypto First position of the AES keys storage memory</description>
	<addressOffset>0x00000100</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0xffffffff</resetMask>
	<fields><field>
	<name>CRYPTO_KEY_X</name>
	<description>CRYPTO_KEY_(0-63)
This is the AES keys storage memory. This memory is accessible via AHB slave interface, only when the CRYPTO is inactive (CRYPTO_INACTIVE = 1).</description>
	<bitRange>[31:0]</bitRange>
	<access>write-only</access>
	</field></fields>
</register><register>
	<name>CRYPTO_LEN_REG</name>
	<description>Crypto Length of the input block in bytes</description>
	<addressOffset>0x0000000c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00ffffff</resetMask>
	<fields><field>
	<name>CRYPTO_LEN</name>
	<description>It contains the number of bytes of input data. If this number is not a multiple of a block size, the data is automatically extended with zeros. The value of this register is updated as the calculation proceeds and the output data are written to the memory.</description>
	<bitRange>[23:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>CRYPTO_MREG0_REG</name>
	<description>Crypto Mode depended register 0</description>
	<addressOffset>0x0000001c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0xffffffff</resetMask>
	<fields><field>
	<name>CRYPTO_MREG0</name>
	<description>It contains information that are depended by the mode of operation, when is used the AES algorithm:
CBC - IV[31:0]
CTR - CTRBLK[31:0]. It is the initial value of the 32 bits counter.
At any other mode, the contents of this register has no meaning.</description>
	<bitRange>[31:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>CRYPTO_MREG1_REG</name>
	<description>Crypto Mode depended register 1</description>
	<addressOffset>0x00000020</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0xffffffff</resetMask>
	<fields><field>
	<name>CRYPTO_MREG1</name>
	<description>It contains information that are depended by the mode of operation, when is used the AES algorithm:
CBC - IV[63:32]
CTR - CTRBLK[63:32]
At any other mode, the contents of this register has no meaning.</description>
	<bitRange>[31:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>CRYPTO_MREG2_REG</name>
	<description>Crypto Mode depended register 2</description>
	<addressOffset>0x00000024</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0xffffffff</resetMask>
	<fields><field>
	<name>CRYPTO_MREG2</name>
	<description>It contains information that are depended by the mode of operation, when is used the AES algorithm:
CBC - IV[95:64]
CTR - CTRBLK[95:64]
At any other mode, the contents of this register has no meaning.</description>
	<bitRange>[31:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>CRYPTO_MREG3_REG</name>
	<description>Crypto Mode depended register 3</description>
	<addressOffset>0x00000028</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0xffffffff</resetMask>
	<fields><field>
	<name>CRYPTO_MREG3</name>
	<description>It contains information that are depended by the mode of operation, when is used the AES algorithm:
CBC - IV[127:96]
CTR - CTRBLK[127:96]
At any other mode, the contents of this register has no meaning.</description>
	<bitRange>[31:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>CRYPTO_START_REG</name>
	<description>Crypto Start calculation</description>
	<addressOffset>0x00000004</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00000001</resetMask>
	<fields><field>
	<name>CRYPTO_START</name>
	<description>Write 1 to initiate the processing of the input data. This register is auto-cleared.</description>
	<bitRange>[0:0]</bitRange>
	<access>write-only</access>
	</field></fields>
</register><register>
	<name>CRYPTO_STATUS_REG</name>
	<description>Crypto Status register</description>
	<addressOffset>0x00000014</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000001</resetValue>
	<resetMask>0x00000007</resetMask>
	<fields><field>
	<name>CRYPTO_IRQ_ST</name>
	<description>The status of the interrupt request line of the CRYPTO block.
0: There is no active interrupt request.
1: An interrupt request is pending.</description>
	<bitRange>[2:2]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>CRYPTO_WAIT_FOR_IN</name>
	<description>Indicates the situation where the engine waits for more input data. This is applicable when the CRYPTO_MORE_IN = 1, so the input data are fragmented in the memory.
0: The crypto is not waiting for more input data.
1: The crypto waits for more input data.
The CRYPTO_INACTIVE flag remains zero to indicate that the calculation is not finished. The supervisor of the CRYPTO must program to CRYPTO_FETCH_ADDR and CRYPTO_LEN a new input data fragment. The calculation is continued as soon as the CRYPTO_START register is written with 1. This action clears the CRYPTO_WAIT_FOR_IN flag.</description>
	<bitRange>[1:1]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>CRYPTO_INACTIVE</name>
	<description>0: The CRYPTO is active. The processing is in progress.
1: The CRYPTO is inactive. The processing has finished.</description>
	<bitRange>[0:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register></registers>
</peripheral><peripheral>
	<name>ANAMISC_BIF</name>
	<version>1.0</version>
	<description>ANAMISC_BIF registers</description>
	<groupName>Peripheral_Registers</groupName>
	<baseAddress>0x50040b00</baseAddress>
	<size>0</size>
	<addressBlock>
	<offset>0</offset>
	<size>32</size>
	<usage>registers</usage>
</addressBlock>

	<registers>
	<register>
	<name>CLK_CAL_IRQ_REG</name>
	<description>Select clock for oscillator calibration</description>
	<addressOffset>0x0000001c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000000f</resetMask>
	<fields><field>
	<name>CLK_CAL_IRQ_CLR</name>
	<description>Clear the IRQ.
1: Clear the IRQ
0: No effect.
Read out 0 always.</description>
	<bitRange>[2:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>CLK_CAL_IRQ_STATUS</name>
	<description>Shows the IRQ bit status.</description>
	<bitRange>[1:1]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>CLK_CAL_IRQ_EN</name>
	<description>Enable clk calibration IRQ.
0: Disabled.
1*: Enabled.
*Note: If IRQ feature is enabled, every calibration should be started by setting CLK_REF_SEL_REG[REF_CAL_START] to 1.</description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>CLK_REF_CNT_REG</name>
	<description>Count value for oscillator calibration</description>
	<addressOffset>0x00000014</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>REF_CNT_VAL</name>
	<description>Indicates the calibration time, with a decrement counter to 1. </description>
	<bitRange>[15:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>CLK_REF_SEL_REG</name>
	<description>Select clock for oscillator calibration</description>
	<addressOffset>0x00000010</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x000000ff</resetMask>
	<fields><field>
	<name>CAL_CLK_SEL</name>
	<description>Select calibration clock input to be used in calibration:
0x0: DIVN clock
0x1: RCLP
0x2: RC32M
0x3: XTAL32K
0x4: XTAL32M_VARICAP_TEST
0x5, 0x6 and 0x7: Reserved</description>
	<bitRange>[7:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>EXT_CNT_EN_SEL</name>
	<description>0: Enable XTAL_CNT counter by the REF_CLK selected by REF_CLK_SEL.
1: Enable XTAL_CNT counter from an external input.</description>
	<bitRange>[4:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>REF_CAL_START</name>
	<description>Writing 1 starts a calibration. This bit is cleared when calibration is finished, and CLK_REF_VAL is ready. </description>
	<bitRange>[3:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>REF_CLK_SEL</name>
	<description>Select reference clock input for calibration:
0x0: RCLP
0x1: RC32M
0x2: XTAL32K
0x3: RCX
0x4: XTAL32M_VARICAP_TEST
0x5: DIVN clock</description>
	<bitRange>[2:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>CLK_REF_VAL_REG</name>
	<description>DIVN reference cycles, lower 16 bits</description>
	<addressOffset>0x00000018</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0xffffffff</resetMask>
	<fields><field>
	<name>XTAL_CNT_VAL</name>
	<description>Returns the number of DIVN clock cycles counted during the calibration time, defined with REF_CNT_VAL </description>
	<bitRange>[31:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register></registers>
</peripheral><peripheral>
	<name>CACHE</name>
	<version>1.0</version>
	<description>CACHE registers</description>
	<groupName>Peripheral_Registers</groupName>
	<baseAddress>0x1a0c0000</baseAddress>
	<size>0</size>
	<addressBlock>
	<offset>0</offset>
	<size>84</size>
	<usage>registers</usage>
</addressBlock>

	<registers>
	<register>
	<name>CACHE_CTRL2_REG</name>
	<description>Cache control register 2 (only Word (32-bits) access supported).</description>
	<addressOffset>0x00000020</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0xffffffff</resetMask>
	<fields><field>
	<name>CACHE_READY</name>
	<description>Cache Controller RO status bit.
0: Default.
1: Set to 1 when CACHE_CTRL is enabled, initialized and immediately ready for a cacheable access to service.</description>
	<bitRange>[28:28]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>CACHE_RAM_INIT</name>
	<description>Cache Controller RO status bit.
0: Default.
1: Set to 1 when SRAM is being initialized (being flushed).
Note: The flushing of the cache memory takes 256 HCLK cycles.</description>
	<bitRange>[27:27]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>CACHE_EF_LEN</name>
	<description>Length of eFLASH cacheable memory.
N*64 kB. N = 0 to 512 (max. of 32 MB).
Setting CACHE_EF_LEN = 0 disables the caching.
Note 1: The max. relevant CACHE_EF_LEN setting depends on the chosen Flash region (program) size.
Note 2: The first block (CACHE_EF_LEN = 1) includes the memory space specified by CACHE_EFLASH_REG[EFLASH_REGION_OFFSET].</description>
	<bitRange>[25:17]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>CACHE_FLUSH_DISABLE</name>
	<description>0: Default.
1: Flushing of the Cache memory is disabled when SYS_CTRL_REG[CACHERAM_MUX] is switched from 1 to 0.
Note: Setting this bit to 1 is only allowed for debugging purposes.</description>
	<bitRange>[16:16]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>CACHE_USE_FULL_DB_RANGE</name>
	<description>00: CACHERAM (mirrored) read/write and NO use of the full 184 bits databus (for executing program code or extension of the SysRAM with the Cache RAM).
In this mode 8 bits, 16 bits and 32 bits write access is supported.
01: CACHERAM (mirrored) read and use of the full 184 bits databus of &quot;SRAM_1_0&quot; (for testing and debugging purposes).
In this mode only 32 bits write access is supported.
10: CACHERAM (mirrored) read and use of the full 184 bits databus of &quot;SRAM_3_2&quot; (for testing and debugging purposes).
In this mode only 32 bits write access is supported.
11: Reserved.
Note 1: SYS_CTRL_REG[CACHERAM_MUX] must be set to 0 before accessing the memory mapped (mirrored) Cache Data and TAG memory.
Note 2: For all three settings, max. 8 kB is available from the memory map.</description>
	<bitRange>[15:14]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>CACHE_MHCLKEN_DISABLE</name>
	<description>0: Default.
1: The &quot;m_HCLK_EN&quot; input is ignored and the controller avoids inserting m_HTRANS = BUSY because of wait states.
Note:
This bit is only relevant for executing from QSPI Flash (when set to 1, it will improve performance). This bit should be kept 0 for executing from eFlash.</description>
	<bitRange>[13:13]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>CACHE_CWF_DISABLE</name>
	<description>0: Default.
1: The cache line refill is performed with INCR type burst and &quot;Critical Word First&quot; is disabled.
Note:
This bit is only relevant for executing from QSPI Flash (when set to 1, it will improve performance).This bit should be kept 0 for executing from eFlash.</description>
	<bitRange>[12:12]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>CACHE_CGEN</name>
	<description>0: Cache controller clock gating is not enabled.
1: Cache controller clock gating is enabled (enabling power saving).</description>
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>CACHE_WEN</name>
	<description>0: Cache Data and TAG memory read only.
1: Cache Data and TAG memory read/write.
The Data and TAG memory are only updated by the cache controller.
There is no HW protection to prevent unauthorized access by the ARM.
Note 1: When accessing the memory mapped Cache Data and TAG memory (which is only allowed for debugging purposes) only 32 bits access is supported.
Note 2: SYS_CTRL_REG[CACHERAM_MUX] must be set to 0 before accessing the memory mapped Cache Data and TAG memory.
See also the CACHE_CTRL2_REG[CACHE_USE_FULL_DB_RANGE] description.</description>
	<bitRange>[9:9]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>CACHE_LEN</name>
	<description>Length of QSPI FLASH cacheable memory.
N*64 kB. N = 0 to 512 (max. of 32 MB).
Setting CACHE_LEN = 0 disables the caching.
Note 1: The max. relevant CACHE_LEN setting depends on the chosen Flash region (program) size.
Note 2: The first block (CACHE_LEN = 1) includes the memory space specified by CACHE_FLASH_REG[FLASH_REGION_OFFSET]</description>
	<bitRange>[8:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>CACHE_EFLASH_REG</name>
	<description>Cache eFlash program size and base address register (only Word (32-bits) access supported). This register is NA for the CMAC Cache (no remapping done in the CMAC Cache).</description>
	<addressOffset>0x00000044</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00a00006</resetValue>
	<resetMask>0xffffffff</resetMask>
	<fields><field>
	<name>EFLASH_REGION_BASE</name>
	<description>These bits corresponds with the eFlash region base address bits [31:16].
Default value is 0x00A0.
The eFlash region base address bits [31:24] are fixed to 0x00.
These register bits are retained.
Note 1: The updated value takes effect only after a software reset.
Note 2 The eFlash region base address setting depends on the chosen eFlash region size.</description>
	<bitRange>[31:16]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>EFLASH_REGION_OFFSET</name>
	<description>The eFlash region offset address (in words).
This value is added to the eFlash (CPU) address bits [13:2].
These register bits are retained.
Note 1: The updated value takes effect only after a software reset.</description>
	<bitRange>[15:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>EFLASH_REGION_SIZE</name>
	<description>The eFlash region size.
Default value is 6 (128 kB).
0 = 512 kB (reserved for bigger eFlash)
1 = 512 kB (reserved for bigger eFlash)
2 = 512 kB (reserved for bigger eFlash)
3 = 512 kB (reserved for bigger eFlash)
4 = 512 kB
5 = 256 kB
6 = 128 kB
7 = 64 kB
These register bits are retained.
Note 1: The updated value takes effect only after a software reset.
Note 2: See for the max. region (program) size the memory map.</description>
	<bitRange>[2:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>CACHE_FLASH_REG</name>
	<description>Cache QSPI Flash program size and base address register (only Word (32-bits) access supported). This register is NA for the CMAC Cache (no remapping done in the CMAC Cache).</description>
	<addressOffset>0x00000040</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x16000006</resetValue>
	<resetMask>0xffffffff</resetMask>
	<fields><field>
	<name>FLASH_REGION_BASE</name>
	<description>These bits corresponds with the Flash region base address bits [31:16].
Default value is 0x1600.
The Flash region base address bits [31:25] are fixed to 0x16 and bits [17:16] are fixed to 0x0.
These register bits are retained.
Note 1: The updated value takes effect only after a software reset.
Note 2 The Flash region base address setting depends on the chosen Flash region size.</description>
	<bitRange>[31:16]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>FLASH_REGION_OFFSET</name>
	<description>Flash region offset address (in words).
This value is added to the Flash (CPU) address bits [13:2].
These register bits are retained.
Note 1: The updated value takes effect only after a software reset.</description>
	<bitRange>[15:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>FLASH_REGION_SIZE</name>
	<description>Flash region size.
Default value is 6 (0.5 MB).
0 = 32 MB
1 = 16 MB
2 = 8 MB
3 = 4 MB
4 = 2 MB
5 = 1 MB
6 = 0.5 MB
7 = 0.25 MB
These register bits are retained.
Note 1: The updated value takes effect only after a software reset.
Note 2: See for the max. region (program) size the memory map.</description>
	<bitRange>[2:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>CACHE_MRM_CTRL_REG</name>
	<description>Cache MRM (Miss Rate Monitor) CONTROL register (only Word (32-bits) access supported).</description>
	<addressOffset>0x00000030</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0xffffffff</resetMask>
	<fields><field>
	<name>MRM_IRQ_HITS_THRES_STATUS</name>
	<description>0: No interrupt is generated.
1: Interrupt (pulse-sensitive) is generated because the number of cache hits reached the programmed threshold (threshold != 0).</description>
	<bitRange>[4:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>MRM_IRQ_MISSES_THRES_STATUS</name>
	<description>0: No interrupt is generated.
1: Interrupt (pulse-sensitive) is generated because the number of cache misses reached the programmed threshold (threshold != 0).</description>
	<bitRange>[3:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>MRM_IRQ_TINT_STATUS</name>
	<description>0: No interrupt is generated.
1: Interrupt (pulse-sensitive) is generated because the time interval counter reached the end (time interval != 0).</description>
	<bitRange>[2:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>MRM_IRQ_MASK</name>
	<description>0: Disables interrupt generation.
1: Enables interrupt generation.
Note: The Cache MRM generates a pulse-sensitive interrupt towards the ARM processor.</description>
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>MRM_START</name>
	<description>0: Freeze the &quot;misses/hits&quot; counters and reset the time interval counter to the programmed value in CACHE_MRM_TINT_REG.
1: Enables the counters.
Note: In case CACHE_MRM_CTRL_REG[MRM_START] is set to 1 and CACHE_MRM_TINT_REG (!=0) is used for the MRM interrupt generation, the time interval counter counts down (on a fixed reference clock of 32 MHz) until it is 0. At that time CACHE_MRM_CTRL_REG[MRM_START] will be reset automatically to 0 by the MRM hardware and the MRM interrupt will be generated.</description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>CACHE_MRM_HITS1WS_REG</name>
	<description>Cache MRM (Miss Rate Monitor) HITS with 1 Wait State register (only Word (32-bits) access supported).</description>
	<addressOffset>0x00000048</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0xffffffff</resetMask>
	<fields><field>
	<name>MRM_HITS1WS</name>
	<description>Contains the amount of cache hits.</description>
	<bitRange>[31:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>CACHE_MRM_HITS_REG</name>
	<description>Cache MRM (Miss Rate Monitor) HITS register (only Word (32-bits) access supported).</description>
	<addressOffset>0x00000028</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0xffffffff</resetMask>
	<fields><field>
	<name>MRM_HITS</name>
	<description>Contains the amount of cache hits.</description>
	<bitRange>[31:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>CACHE_MRM_HITS_THRES_REG</name>
	<description>Cache MRM (Miss Rate Monitor) HITS THRESHOLD register (only Word (32-bits) access supported).</description>
	<addressOffset>0x0000003c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0xffffffff</resetMask>
	<fields><field>
	<name>MRM_HITS_THRES</name>
	<description>Defines the hits threshold to trigger the interrupt generation. See also the description of CACHE_MRM_CTRL_REG[MRM_IRQ_HITS_THRES_STATUS].
Note: When MRM_HITS_THRES = 0 (unrealistic value), no interrupt will be generated.</description>
	<bitRange>[31:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>CACHE_MRM_MISSES_REG</name>
	<description>Cache MRM (Miss Rate Monitor) MISSES register (only Word (32-bits) access supported).</description>
	<addressOffset>0x0000002c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0xffffffff</resetMask>
	<fields><field>
	<name>MRM_MISSES</name>
	<description>Contains the amount of cache misses.</description>
	<bitRange>[31:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>CACHE_MRM_MISSES_THRES_REG</name>
	<description>Cache MRM (Miss Rate Monitor) THRESHOLD register (only Word (32-bits) access supported).</description>
	<addressOffset>0x00000038</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0xffffffff</resetMask>
	<fields><field>
	<name>MRM_MISSES_THRES</name>
	<description>Defines the misses threshold to trigger the interrupt generation. See also the description of CACHE_MRM_CTRL_REG[MRM_IRQ_MISSES_THRES_STATUS].
Note: When MRM_MISSES_THRES = 0 (unrealistic value), no interrupt will be generated.</description>
	<bitRange>[31:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>CACHE_MRM_TINT_REG</name>
	<description>Cache MRM (Miss Rate Monitor) TIME INTERVAL register (only Word (32-bits) access supported).</description>
	<addressOffset>0x00000034</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0xffffffff</resetMask>
	<fields><field>
	<name>MRM_TINT</name>
	<description>Defines the time interval for the monitoring in 32 MHz clock cycles. See also the description of CACHE_MRM_CTRL_REG[MRM_IRQ_TINT_STATUS].
Note: When MRM_TINT = 0 (unrealistic value), no interrupt will be generated.</description>
	<bitRange>[18:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>SWD_RESET_REG</name>
	<description>SWD HW reset control register (only Word (32-bits) access supported).</description>
	<addressOffset>0x00000050</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0xffffffff</resetMask>
	<fields><field>
	<name>SWD_HW_RESET_REQ</name>
	<description>0: default.
1: hardware reset request (from the debugger tool). The register is automatically reset with a HW_RESET.
This bit can only be accessed by the debugger software and not by the application.</description>
	<bitRange>[0:0]</bitRange>
	<access>write-only</access>
	</field></fields>
</register></registers>
</peripheral><peripheral>
	<name>CHIP_VERSION</name>
	<version>1.0</version>
	<description>CHIP_VERSION registers</description>
	<groupName>Peripheral_Registers</groupName>
	<baseAddress>0x50050200</baseAddress>
	<size>0</size>
	<addressBlock>
	<offset>0</offset>
	<size>256</size>
	<usage>registers</usage>
</addressBlock>

	<registers>
	<register>
	<name>CHIP_ID1_REG</name>
	<description>Chip identification register 1.</description>
	<addressOffset>0x00000000</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000032</resetValue>
	<resetMask>0x000000ff</resetMask>
	<fields><field>
	<name>CHIP_ID1</name>
	<description>First character of device type in ASCII. </description>
	<bitRange>[7:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>CHIP_ID2_REG</name>
	<description>Chip identification register 2.</description>
	<addressOffset>0x00000004</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000036</resetValue>
	<resetMask>0x000000ff</resetMask>
	<fields><field>
	<name>CHIP_ID2</name>
	<description>Second character of device type in ASCII. </description>
	<bitRange>[7:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>CHIP_ID3_REG</name>
	<description>Chip identification register 3.</description>
	<addressOffset>0x00000008</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000033</resetValue>
	<resetMask>0x000000ff</resetMask>
	<fields><field>
	<name>CHIP_ID3</name>
	<description>Third character of device type in ASCII. </description>
	<bitRange>[7:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>CHIP_ID4_REG</name>
	<description>Chip identification register 4.</description>
	<addressOffset>0x0000000c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000034</resetValue>
	<resetMask>0x000000ff</resetMask>
	<fields><field>
	<name>CHIP_ID4</name>
	<description>Fourth character of device type in ASCII.</description>
	<bitRange>[7:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>CHIP_REVISION_REG</name>
	<description>Chip revision register.</description>
	<addressOffset>0x00000014</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000041</resetValue>
	<resetMask>0x000000ff</resetMask>
	<fields><field>
	<name>CHIP_REVISION</name>
	<description>Chip version, corresponds with type number in ASCII.
0x41 = A, 0x42 = B </description>
	<bitRange>[7:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>CHIP_SWC_REG</name>
	<description>Software compatibility register.</description>
	<addressOffset>0x00000010</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000002</resetValue>
	<resetMask>0x0000000f</resetMask>
	<fields><field>
	<name>CHIP_SWC</name>
	<description>SoftWare Compatibility (SWC) code.
Integer (default = 0) which is incremented if a silicon change has impact on the CPU Firmware.
Can be used by software developers to write silicon revision dependent code. </description>
	<bitRange>[3:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>CHIP_TEST1_REG</name>
	<description>Chip test register 1.</description>
	<addressOffset>0x000000f8</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000045</resetValue>
	<resetMask>0x000000ff</resetMask>
	<fields><field>
	<name>CHIP_LAYOUT_REVISION</name>
	<description>Chip layout revision, corresponds with type number in ASCII.
0x41 = A, 0x42 = B </description>
	<bitRange>[7:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>CHIP_TEST2_REG</name>
	<description>Chip test register 2.</description>
	<addressOffset>0x000000fc</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000000f</resetMask>
	<fields><field>
	<name>CHIP_METAL_OPTION</name>
	<description>Chip metal option value.</description>
	<bitRange>[3:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register></registers>
</peripheral><peripheral>
	<name>CMAC_CACHE</name>
	<version>1.0</version>
	<description>CMAC_CACHE registers</description>
	<groupName>Peripheral_Registers</groupName>
	<baseAddress>0x1a1c0000</baseAddress>
	<size>0</size>
	<addressBlock>
	<offset>0</offset>
	<size>84</size>
	<usage>registers</usage>
</addressBlock>

	<registers>
	<register>
	<name>CM_CACHE_CTRL2_REG</name>
	<description>Cache control register 2 (only Word (32-bits) access supported).</description>
	<addressOffset>0x00000020</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0xffffffff</resetMask>
	<fields><field>
	<name>CACHE_READY</name>
	<description>Cache Controller RO status bit.
0: Default.
1: Set to 1 when CACHE_CTRL is enabled, initialized and immediately ready for a cacheable access to service.</description>
	<bitRange>[28:28]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>CACHE_RAM_INIT</name>
	<description>Cache Controller RO status bit.
0: Default.
1: Set to 1 when SRAM is being initialized (being flushed).
Note: The flushing of the cache memory takes 256 HCLK cycles.</description>
	<bitRange>[27:27]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>CACHE_EF_LEN</name>
	<description>Length of eFLASH cacheable memory.
N*64 kB. N = 0 to 512 (max. of 32 MB).
Setting CACHE_EF_LEN = 0 disables the caching.
Note 1: The max. relevant CACHE_EF_LEN setting depends on the chosen Flash region (program) size.
Note 2: The first block (CACHE_EF_LEN = 1) includes the memory space specified by CACHE_EFLASH_REG[EFLASH_REGION_OFFSET].</description>
	<bitRange>[25:17]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>CACHE_FLUSH_DISABLE</name>
	<description>0: Default.
1: Flushing of the Cache memory is disabled when SYS_CTRL_REG[CACHERAM_MUX] is switched from 1 to 0.
Note: Setting this bit to 1 is only allowed for debugging purposes.</description>
	<bitRange>[16:16]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>CACHE_USE_FULL_DB_RANGE</name>
	<description>00: CACHERAM (mirrored) read/write and NO use of the full 184 bits databus (for executing program code or extension of the SysRAM with the Cache RAM).
In this mode 8 bits, 16 bits and 32 bits write access is supported.
01: CACHERAM (mirrored) read and use of the full 184 bits databus of &quot;SRAM_1_0&quot; (for testing and debugging purposes).
In this mode only 32 bits write access is supported.
10: CACHERAM (mirrored) read and use of the full 184 bits databus of &quot;SRAM_3_2&quot; (for testing and debugging purposes).
In this mode only 32 bits write access is supported.
11: Reserved.
Note 1: SYS_CTRL_REG[CACHERAM_MUX] must be set to 0 before accessing the memory mapped (mirrored) Cache Data and TAG memory.
Note 2: For all three settings, max. 8 kB is available from the memory map.</description>
	<bitRange>[15:14]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>CACHE_MHCLKEN_DISABLE</name>
	<description>0: Default.
1: The &quot;m_HCLK_EN&quot; input is ignored and the controller avoids inserting m_HTRANS = BUSY because of wait states.
Note:
This bit is only relevant for executing from QSPI Flash (when set to 1, it will improve performance). This bit should be kept 0 for executing from eFlash.</description>
	<bitRange>[13:13]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>CACHE_CWF_DISABLE</name>
	<description>0: Default.
1: The cache line refill is performed with INCR type burst and &quot;Critical Word First&quot; is disabled.
Note:
This bit is only relevant for executing from QSPI Flash (when set to 1, it will improve performance).This bit should be kept 0 for executing from eFlash.</description>
	<bitRange>[12:12]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>CACHE_CGEN</name>
	<description>0: Cache controller clock gating is not enabled.
1: Cache controller clock gating is enabled (enabling power saving).</description>
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>CACHE_WEN</name>
	<description>0: Cache Data and TAG memory read only.
1: Cache Data and TAG memory read/write.
The Data and TAG memory are only updated by the cache controller.
There is no HW protection to prevent unauthorized access by the ARM.
Note 1: When accessing the memory mapped Cache Data and TAG memory (which is only allowed for debugging purposes) only 32 bits access is supported.
Note 2: SYS_CTRL_REG[CACHERAM_MUX] must be set to 0 before accessing the memory mapped Cache Data and TAG memory.
See also the CACHE_CTRL2_REG[CACHE_USE_FULL_DB_RANGE] description.</description>
	<bitRange>[9:9]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>CACHE_LEN</name>
	<description>Length of QSPI FLASH cacheable memory.
N*64 kB. N = 0 to 512 (max. of 32 MB).
Setting CACHE_LEN = 0 disables the caching.
Note 1: The max. relevant CACHE_LEN setting depends on the chosen Flash region (program) size.
Note 2: The first block (CACHE_LEN = 1) includes the memory space specified by CACHE_FLASH_REG[FLASH_REGION_OFFSET]</description>
	<bitRange>[8:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>CM_CACHE_EFLASH_REG</name>
	<description>Cache eFlash program size and base address register (only Word (32-bits) access supported). This register is NA for the CMAC Cache (no remapping done in the CMAC Cache).</description>
	<addressOffset>0x00000044</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00a00006</resetValue>
	<resetMask>0xffffffff</resetMask>
	<fields><field>
	<name>EFLASH_REGION_BASE</name>
	<description>These bits corresponds with the eFlash region base address bits [31:16].
Default value is 0x00A0.
The eFlash region base address bits [31:24] are fixed to 0x00.
These register bits are retained.
Note 1: The updated value takes effect only after a software reset.
Note 2 The eFlash region base address setting depends on the chosen eFlash region size.</description>
	<bitRange>[31:16]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>EFLASH_REGION_OFFSET</name>
	<description>The eFlash region offset address (in words).
This value is added to the eFlash (CPU) address bits [13:2].
These register bits are retained.
Note 1: The updated value takes effect only after a software reset.</description>
	<bitRange>[15:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>EFLASH_REGION_SIZE</name>
	<description>The eFlash region size.
Default value is 6 (128 kB).
0 = 512 kB (reserved for bigger eFlash)
1 = 512 kB (reserved for bigger eFlash)
2 = 512 kB (reserved for bigger eFlash)
3 = 512 kB (reserved for bigger eFlash)
4 = 512 kB
5 = 256 kB
6 = 128 kB
7 = 64 kB
These register bits are retained.
Note 1: The updated value takes effect only after a software reset.
Note 2: See for the max. region (program) size the memory map.</description>
	<bitRange>[2:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>CM_CACHE_FLASH_REG</name>
	<description>Cache QSPI Flash program size and base address register (only Word (32-bits) access supported). This register is NA for the CMAC Cache (no remapping done in the CMAC Cache).</description>
	<addressOffset>0x00000040</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x16000006</resetValue>
	<resetMask>0xffffffff</resetMask>
	<fields><field>
	<name>FLASH_REGION_BASE</name>
	<description>These bits corresponds with the Flash region base address bits [31:16].
Default value is 0x1600.
The Flash region base address bits [31:25] are fixed to 0x16 and bits [17:16] are fixed to 0x0.
These register bits are retained.
Note 1: The updated value takes effect only after a software reset.
Note 2 The Flash region base address setting depends on the chosen Flash region size.</description>
	<bitRange>[31:16]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>FLASH_REGION_OFFSET</name>
	<description>Flash region offset address (in words).
This value is added to the Flash (CPU) address bits [13:2].
These register bits are retained.
Note 1: The updated value takes effect only after a software reset.</description>
	<bitRange>[15:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>FLASH_REGION_SIZE</name>
	<description>Flash region size.
Default value is 6 (0.5 MB).
0 = 32 MB
1 = 16 MB
2 = 8 MB
3 = 4 MB
4 = 2 MB
5 = 1 MB
6 = 0.5 MB
7 = 0.25 MB
These register bits are retained.
Note 1: The updated value takes effect only after a software reset.
Note 2: See for the max. region (program) size the memory map.</description>
	<bitRange>[2:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>CM_CACHE_MRM_CTRL_REG</name>
	<description>Cache MRM (Miss Rate Monitor) CONTROL register (only Word (32-bits) access supported).</description>
	<addressOffset>0x00000030</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0xffffffff</resetMask>
	<fields><field>
	<name>MRM_IRQ_HITS_THRES_STATUS</name>
	<description>0: No interrupt is generated.
1: Interrupt (pulse-sensitive) is generated because the number of cache hits reached the programmed threshold (threshold != 0).</description>
	<bitRange>[4:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>MRM_IRQ_MISSES_THRES_STATUS</name>
	<description>0: No interrupt is generated.
1: Interrupt (pulse-sensitive) is generated because the number of cache misses reached the programmed threshold (threshold != 0).</description>
	<bitRange>[3:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>MRM_IRQ_TINT_STATUS</name>
	<description>0: No interrupt is generated.
1: Interrupt (pulse-sensitive) is generated because the time interval counter reached the end (time interval != 0).</description>
	<bitRange>[2:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>MRM_IRQ_MASK</name>
	<description>0: Disables interrupt generation.
1: Enables interrupt generation.
Note: The Cache MRM generates a pulse-sensitive interrupt towards the ARM processor.</description>
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>MRM_START</name>
	<description>0: Freeze the &quot;misses/hits&quot; counters and reset the time interval counter to the programmed value in CACHE_MRM_TINT_REG.
1: Enables the counters.
Note: In case CACHE_MRM_CTRL_REG[MRM_START] is set to 1 and CACHE_MRM_TINT_REG (!=0) is used for the MRM interrupt generation, the time interval counter counts down (on a fixed reference clock of 32 MHz) until it is 0. At that time CACHE_MRM_CTRL_REG[MRM_START] will be reset automatically to 0 by the MRM hardware and the MRM interrupt will be generated.</description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>CM_CACHE_MRM_HITS1WS_REG</name>
	<description>Cache MRM (Miss Rate Monitor) HITS with 1 Wait State register (only Word (32-bits) access supported).</description>
	<addressOffset>0x00000048</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0xffffffff</resetMask>
	<fields><field>
	<name>MRM_HITS1WS</name>
	<description>Contains the amount of cache hits.</description>
	<bitRange>[31:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>CM_CACHE_MRM_HITS_REG</name>
	<description>Cache MRM (Miss Rate Monitor) HITS register (only Word (32-bits) access supported).</description>
	<addressOffset>0x00000028</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0xffffffff</resetMask>
	<fields><field>
	<name>MRM_HITS</name>
	<description>Contains the amount of cache hits.</description>
	<bitRange>[31:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>CM_CACHE_MRM_HITS_THRES_REG</name>
	<description>Cache MRM (Miss Rate Monitor) HITS THRESHOLD register (only Word (32-bits) access supported).</description>
	<addressOffset>0x0000003c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0xffffffff</resetMask>
	<fields><field>
	<name>MRM_HITS_THRES</name>
	<description>Defines the hits threshold to trigger the interrupt generation. See also the description of CACHE_MRM_CTRL_REG[MRM_IRQ_HITS_THRES_STATUS].
Note: When MRM_HITS_THRES = 0 (unrealistic value), no interrupt will be generated.</description>
	<bitRange>[31:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>CM_CACHE_MRM_MISSES_REG</name>
	<description>Cache MRM (Miss Rate Monitor) MISSES register (only Word (32-bits) access supported).</description>
	<addressOffset>0x0000002c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0xffffffff</resetMask>
	<fields><field>
	<name>MRM_MISSES</name>
	<description>Contains the amount of cache misses.</description>
	<bitRange>[31:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>CM_CACHE_MRM_MISSES_THRES_REG</name>
	<description>Cache MRM (Miss Rate Monitor) THRESHOLD register (only Word (32-bits) access supported).</description>
	<addressOffset>0x00000038</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0xffffffff</resetMask>
	<fields><field>
	<name>MRM_MISSES_THRES</name>
	<description>Defines the misses threshold to trigger the interrupt generation. See also the description of CACHE_MRM_CTRL_REG[MRM_IRQ_MISSES_THRES_STATUS].
Note: When MRM_MISSES_THRES = 0 (unrealistic value), no interrupt will be generated.</description>
	<bitRange>[31:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>CM_CACHE_MRM_TINT_REG</name>
	<description>Cache MRM (Miss Rate Monitor) TIME INTERVAL register (only Word (32-bits) access supported).</description>
	<addressOffset>0x00000034</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0xffffffff</resetMask>
	<fields><field>
	<name>MRM_TINT</name>
	<description>Defines the time interval for the monitoring in 32 MHz clock cycles. See also the description of CACHE_MRM_CTRL_REG[MRM_IRQ_TINT_STATUS].
Note: When MRM_TINT = 0 (unrealistic value), no interrupt will be generated.</description>
	<bitRange>[18:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>CM_CACHE_RESET_REG</name>
	<description>SWD HW reset control register (only Word (32-bits) access supported).</description>
	<addressOffset>0x00000050</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0xffffffff</resetMask>
	<fields><field>
	<name>SWD_HW_RESET_REQ</name>
	<description>0: default.
1: hardware reset request (from the debugger tool). The register is automatically reset with a HW_RESET.
This bit can only be accessed by the debugger software and not by the application.</description>
	<bitRange>[0:0]</bitRange>
	<access>write-only</access>
	</field></fields>
</register></registers>
</peripheral><peripheral>
	<name>CRG_AUD</name>
	<version>1.0</version>
	<description>CRG_AUD registers</description>
	<groupName>Peripheral_Registers</groupName>
	<baseAddress>0x50030000</baseAddress>
	<size>0</size>
	<addressBlock>
	<offset>0</offset>
	<size>80</size>
	<usage>registers</usage>
</addressBlock>

	<registers>
	<register>
	<name>PCM_DIV_REG</name>
	<description>PCM divider and enables</description>
	<addressOffset>0x00000040</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00003fff</resetMask>
	<fields><field>
	<name>PCM_SRC_SEL</name>
	<description>Selects the clock source
1 = DIV1 clock
0 = DIVN clock</description>
	<bitRange>[13:13]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>CLK_PCM_EN</name>
	<description>Enable for the internally generated PCM clock
The PCM_DIV must be set before or together with CLK_PCM_EN.</description>
	<bitRange>[12:12]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PCM_DIV</name>
	<description>PCM clock divider. Minimum value is 0x2.</description>
	<bitRange>[11:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>PCM_FDIV_REG</name>
	<description>PCM fractional division register</description>
	<addressOffset>0x00000044</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>PCM_FDIV</name>
	<description>These bits define the fractional division part of the PCM clock. The left most 1 defines the denominator, the number of 1 bits define the numerator. For example,
0x0110 means 2/9, with a distribution of 1.0001.0000
0xfeee means 13/16, with a distribution of 1111.1110.1110.1110</description>
	<bitRange>[15:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>PDM_DIV_REG</name>
	<description>PDM divider and enables</description>
	<addressOffset>0x00000048</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x000003ff</resetMask>
	<fields><field>
	<name>PDM_MASTER_MODE</name>
	<description>Master mode selection
0: slave mode
1: master mode</description>
	<bitRange>[9:9]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>CLK_PDM_EN</name>
	<description>Enable for the internally generated PDM clock
The PDM_DIV must be set before or together with CLK_PDM_EN.</description>
	<bitRange>[8:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PDM_DIV</name>
	<description>PDM clock divider</description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>SRC_DIV_REG</name>
	<description>SRC divider and enables</description>
	<addressOffset>0x0000004c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0003ffff</resetMask>
	<fields><field>
	<name>CLK_SRC2_EN</name>
	<description>Enable for the internally generated SRC2 clock
The SRC2_DIV must be set before or together with CLK_SRC2_EN.</description>
	<bitRange>[17:17]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>CLK_SRC_EN</name>
	<description>Enable for the internally generated SRC clock
The SRC_DIV must be set before or together with CLK_SRC_EN.</description>
	<bitRange>[16:16]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SRC2_DIV</name>
	<description>SRC2 clock divider</description>
	<bitRange>[15:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SRC_DIV</name>
	<description>SRC clock divider</description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register></registers>
</peripheral><peripheral>
	<name>CRG_COM</name>
	<version>1.0</version>
	<description>CRG_COM registers</description>
	<groupName>Peripheral_Registers</groupName>
	<baseAddress>0x50020500</baseAddress>
	<size>0</size>
	<addressBlock>
	<offset>0</offset>
	<size>16</size>
	<usage>registers</usage>
</addressBlock>

	<registers>
	<register>
	<name>CLK_COM_REG</name>
	<description>Peripheral divider register</description>
	<addressOffset>0x00000004</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x000003ff</resetMask>
	<fields><field>
	<name>I2C_CLK_SEL</name>
	<description>Selects the clock source
1 = DIV1 clock
0 = DIVN clock</description>
	<bitRange>[7:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>I2C_ENABLE</name>
	<description>Enables the clock</description>
	<bitRange>[6:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SPI_CLK_SEL</name>
	<description>Selects the clock source
1 = DIV1 clock
0 = DIVN clock</description>
	<bitRange>[5:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SPI_ENABLE</name>
	<description>Enables the clock</description>
	<bitRange>[4:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>UART2_CLK_SEL</name>
	<description>Selects the clock source
1 = DIV1 clock
0 = DIVN clock</description>
	<bitRange>[3:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>UART2_ENABLE</name>
	<description>Enables the clock</description>
	<bitRange>[2:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>UART_CLK_SEL</name>
	<description>Selects the clock source
1 = DIV1 clock
0 = DIVN clock</description>
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>UART_ENABLE</name>
	<description>Enables the clock</description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>RESET_CLK_COM_REG</name>
	<description>Peripheral divider register RESET register. Reads back 0x0000</description>
	<addressOffset>0x0000000c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x000003ff</resetMask>
	<fields><field>
	<name>I2C_CLK_SEL</name>
	<description>Selects the clock source
1 = DIV1 clock
0 = DIVN clock</description>
	<bitRange>[7:7]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>I2C_ENABLE</name>
	<description>Disables the clock</description>
	<bitRange>[6:6]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>SPI_CLK_SEL</name>
	<description>Selects the clock source
1 = DIV1 clock
0 = DIVN clock</description>
	<bitRange>[5:5]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>SPI_ENABLE</name>
	<description>Disables the clock</description>
	<bitRange>[4:4]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>UART2_CLK_SEL</name>
	<description>Selects the clock source
1 = DIV1 clock
0 = DIVN clock</description>
	<bitRange>[3:3]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>UART2_ENABLE</name>
	<description>Disables the clock</description>
	<bitRange>[2:2]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>UART_CLK_SEL</name>
	<description>Selects the clock source
1 = DIV1 clock
0 = DIVN clock</description>
	<bitRange>[1:1]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>UART_ENABLE</name>
	<description>Disables the clock</description>
	<bitRange>[0:0]</bitRange>
	<access>write-only</access>
	</field></fields>
</register><register>
	<name>SET_CLK_COM_REG</name>
	<description>Peripheral divider register SET register. Reads back 0x0000</description>
	<addressOffset>0x00000008</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x000003ff</resetMask>
	<fields><field>
	<name>I2C_CLK_SEL</name>
	<description>Selects the clock source
1 = DIV1 clock
0 = DIVN clock</description>
	<bitRange>[7:7]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>I2C_ENABLE</name>
	<description>Enables the clock</description>
	<bitRange>[6:6]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>SPI_CLK_SEL</name>
	<description>Selects the clock source
1 = DIV1 clock
0 = DIVN clock</description>
	<bitRange>[5:5]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>SPI_ENABLE</name>
	<description>Enables the clock</description>
	<bitRange>[4:4]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>UART2_CLK_SEL</name>
	<description>Selects the clock source
1 = DIV1 clock
0 = DIVN clock</description>
	<bitRange>[3:3]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>UART2_ENABLE</name>
	<description>Enables the clock</description>
	<bitRange>[2:2]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>UART_CLK_SEL</name>
	<description>Selects the clock source
1 = DIV1 clock
0 = DIVN clock</description>
	<bitRange>[1:1]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>UART_ENABLE</name>
	<description>Enables the clock</description>
	<bitRange>[0:0]</bitRange>
	<access>write-only</access>
	</field></fields>
</register></registers>
</peripheral><peripheral>
	<name>CRG_PER</name>
	<version>1.0</version>
	<description>CRG_PER registers</description>
	<groupName>Peripheral_Registers</groupName>
	<baseAddress>0x50040c00</baseAddress>
	<size>0</size>
	<addressBlock>
	<offset>0</offset>
	<size>16</size>
	<usage>registers</usage>
</addressBlock>

	<registers>
	<register>
	<name>CLK_PER_REG</name>
	<description>Peripheral divider register</description>
	<addressOffset>0x00000004</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00000001</resetMask>
	<fields><field>
	<name>GPADC_CLK_SEL</name>
	<description>Selects the clock source
1 = DIV1 clock
0 = DIVN clock/2</description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>RESET_CLK_PER_REG</name>
	<description>Peripheral divider register RESET register, reads 0x0000</description>
	<addressOffset>0x0000000c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00000001</resetMask>
	<fields><field>
	<name>GPADC_CLK_SEL</name>
	<description>Selects the clock source
1 = DIV1 clock
0 = DIVN clock/2</description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>SET_CLK_PER_REG</name>
	<description>Peripheral divider register SET register, reads 0x0000</description>
	<addressOffset>0x00000008</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00000001</resetMask>
	<fields><field>
	<name>GPADC_CLK_SEL</name>
	<description>Selects the clock source
1 = DIV1 clock
0 = DIVN clock/2</description>
	<bitRange>[0:0]</bitRange>
	<access>read-writeOnce</access>
	</field></fields>
</register></registers>
</peripheral><peripheral>
	<name>CRG_SYS</name>
	<version>1.0</version>
	<description>CRG_SYS registers</description>
	<groupName>Peripheral_Registers</groupName>
	<baseAddress>0x50050500</baseAddress>
	<size>0</size>
	<addressBlock>
	<offset>0</offset>
	<size>4</size>
	<usage>registers</usage>
</addressBlock>

	<registers>
	<register>
	<name>CLK_SYS_REG</name>
	<description>Peripheral divider register</description>
	<addressOffset>0x00000000</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00000003</resetMask>

</register></registers>
</peripheral><peripheral>
	<name>CRG_TOP</name>
	<version>1.0</version>
	<description>CRG_TOP registers</description>
	<groupName>Peripheral_Registers</groupName>
	<baseAddress>0x50000000</baseAddress>
	<size>0</size>
	<addressBlock>
	<offset>0</offset>
	<size>256</size>
	<usage>registers</usage>
</addressBlock>

	<registers>
	<register>
	<name>ANA_STATUS_REG</name>
	<description>Analog Signals Status Register</description>
	<addressOffset>0x000000dc</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x000001ff</resetMask>
	<fields><field>
	<name>LDO_GPADC_OK</name>
	<description>When high LDO_GPADC is active</description>
	<bitRange>[8:8]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>BOD_COMP_VEFLASH_OK</name>
	<description>COMP_VEFLASH_OK = 1 -&gt; VDD &gt; 1.08 V
No filtering applied, software should read multiple times to filter glitches.</description>
	<bitRange>[7:7]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>BOD_COMP_VDCDC_OK</name>
	<description>COMP_VDCDC_ = 1 -&gt; VDCDC &gt; 0.95 V</description>
	<bitRange>[6:6]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>BOD_COMP_VDDIO_OK</name>
	<description>COMP_VDDIO = 1 -&gt; VDDIO &gt; 1.667 V</description>
	<bitRange>[5:5]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>BOD_COMP_VDD_OK</name>
	<description>COMP_VDD_OK = 1 -&gt; VDD &gt; 1.125 V</description>
	<bitRange>[4:4]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>LDO_IO_OK</name>
	<description>When high LDO_IO is active</description>
	<bitRange>[3:3]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>LDO_LOW_OK</name>
	<description>When high LDO_LOW is active</description>
	<bitRange>[2:2]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>LDO_CORE_OK</name>
	<description>When high LDO_CORE is active</description>
	<bitRange>[1:1]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>BANDGAP_OK</name>
	<description>When high bandgap is active</description>
	<bitRange>[0:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>BANDGAP_REG</name>
	<description>bandgap trimming</description>
	<addressOffset>0x00000050</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x000007ff</resetMask>
	<fields><field>
	<name>BGR_ITRIM</name>
	<description>Current trimming for bias </description>
	<bitRange>[10:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>BGR_TRIM</name>
	<description>Trim register for bandgap </description>
	<bitRange>[4:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>BIAS_VREF_SEL_REG</name>

	<addressOffset>0x000000a4</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x0000003a</resetValue>
	<resetMask>0x000000ff</resetMask>
	<fields><field>
	<name>BIAS_VREF_RF2_SEL</name>
	<description>HP: 0xA
LP: 0x3
same coding as BIAS_VREF_RF1_SEL.</description>
	<bitRange>[7:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>BIAS_VREF_RF1_SEL</name>
	<description>Vref_code | Vref_Voltage (mV)
0:900
1:930
2:960
3:990
4:1020
5:1050
6:1080
7:1110
8:1140
9:1170
10:1200
11:1230
12:1260
13:1290
14:1320
15:1350</description>
	<bitRange>[3:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>BOD_CTRL_REG</name>
	<description>BOD control register</description>
	<addressOffset>0x000000d0</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000180</resetValue>
	<resetMask>0x000001ff</resetMask>
	<fields><field>
	<name>BOD_VDDIO_MASK</name>
	<description>Mask the output of the VDDIO comparator.
0x0 - POR trigger due to BOD comparator enabled
0x1 - POR trigger due to BOD comparator blocked</description>
	<bitRange>[8:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>BOD_VDCDC_MASK</name>
	<description>Mask the output of the VDCDC comparator
0x0 - POR trigger due to BOD comparator enabled
0x1 - POR trigger due to BOD comparator blocked</description>
	<bitRange>[7:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>BOD_VDD_MASK</name>
	<description>Mask the output of the VDD comparator
0x0 - POR trigger due to BOD comparator enabled
0x1 - POR trigger due to BOD comparator blocked</description>
	<bitRange>[6:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>BOD_DIS_VDDIO_COMP</name>
	<description>Disable the BOD for the VDDIO comparator. Preferred way is to use BOD_VDDIO_MASK = 0x1 instead</description>
	<bitRange>[4:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>BOD_DIS_VDCDC_COMP</name>
	<description>Disable the BOD for the VDCDC comparator. Preferred way is to use BOD_VDCDC_MASK = 0x1 instead</description>
	<bitRange>[3:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>BOD_DIS_VDD_COMP</name>
	<description>Disable the BOD for the VDD comparator. Preferred way is to use BOD_VDD_MASK = 0x1 instead</description>
	<bitRange>[2:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>BOD_SEL_VDD_LVL</name>
	<description>Set the level for the Vdd BOD comparator.
0x0 - 0.78 V (Used for Vdd = 0.9 V)
0x1 - 1.05 V (Used for Vdd = 1.2 V)
0x2 - Undefined, do not use
0x3 - 0.70 V (Sleep mode)
Note that the level is overruled by the hardware state machine when the chip is in sleep mode and set to 0x3. During wake-up, the level is set back to 0x0. </description>
	<bitRange>[1:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>CLK_AMBA_REG</name>
	<description>HCLK, PCLK, divider and clock gates</description>
	<addressOffset>0x00000000</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000022</resetValue>
	<resetMask>0x00001fff</resetMask>
	<fields><field>
	<name>QSPI_ENABLE</name>
	<description>Clock enable for QSPI controller </description>
	<bitRange>[12:12]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>QSPI_DIV</name>
	<description>QSPI divider
00 = divide by 1
01 = divide by 2
10 = divide by 4
11 = divide by 8</description>
	<bitRange>[11:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>QDEC_CLK_ENABLE</name>
	<description>Clock enable for QDEC block</description>
	<bitRange>[7:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>AES_CLK_ENABLE</name>
	<description>Clock enable for AES crypto block </description>
	<bitRange>[6:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PCLK_DIV</name>
	<description>APB interface clock, Cascaded with HCLK:
00 = divide hclk by 1
01 = divide hclk by 2
10 = divide hclk by 4
11 = divide hclk by 8 </description>
	<bitRange>[5:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>HCLK_DIV</name>
	<description>AHB interface and microprocessor clock. Source clock divided by:
000 = divide hclk by 1
001 = divide hclk by 2
010 = divide hclk by 4
011 = divide hclk by 8
1xx = divide hclk by 16</description>
	<bitRange>[2:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>CLK_CTRL_REG</name>
	<description>Clock control register</description>
	<addressOffset>0x00000014</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00002001</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>RUNNING_AT_DBLR64M</name>
	<description>Indicates that the DBLR64MHz clock is used as clock, and may not be switched off</description>
	<bitRange>[15:15]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>RUNNING_AT_XTAL32M</name>
	<description>Indicates that the XTAL32M clock is used as clock, and may not be switched off </description>
	<bitRange>[14:14]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>RUNNING_AT_RC32M</name>
	<description>Indicates that the RC32M clock is used as clock </description>
	<bitRange>[13:13]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>RUNNING_AT_LP_CLK</name>
	<description>Indicates that either the LP_CLK is being used as clock </description>
	<bitRange>[12:12]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>XTAL32M_DISABLE</name>
	<description>Setting this bit instantaneously disables the 32-MHz crystal oscillator. Also, after sleep/wake-up cycle, the oscillator will not be enabled. This bit may not be set to 1 when RUNNING_AT_XTAL32M is 1 to prevent deadlock. After resetting this bit, wait for XTAL32M_SETTLED or XTAL32M_TRIM_READY to become 1 before switching to XTAL32M clock source.</description>
	<bitRange>[5:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>LP_CLK_SEL</name>
	<description>Sets the clock source of the LowerPower clock
0x0: RCLP
0x1: RCX
0x2: XTAL32K through the oscillator with an external Crystal.
0x3: XTAL32K through an external square wave generator (set PID of GPIO to FUNC_GPIO)</description>
	<bitRange>[3:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SYS_CLK_SEL</name>
	<description>Selects the clock source.
0x0 : XTAL32M
0x1 : RC32M
0x2 : RCLP
0x3 : DBLR64M</description>
	<bitRange>[1:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>CLK_RADIO_REG</name>
	<description>Radio PLL control register</description>
	<addressOffset>0x00000010</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000004</resetValue>
	<resetMask>0x0000000f</resetMask>
	<fields><field>
	<name>RFCU_ENABLE</name>
	<description>Enable the RF Control Unit clock</description>
	<bitRange>[3:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>CMAC_SYNCH_RESET</name>
	<description>Force synchronous reset to CMAC core and Sleep Timer. Its effective only when both Radio and Timer Power Domains are powered and the clocks are enabled.
CMAC CPU and CMAC registers, including the retained ones, will be reset.
It should be kept in reset for enough time to make sure that it will be captured by CMAC, Low Power and APB clocks.</description>
	<bitRange>[2:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>CMAC_CLK_SEL</name>
	<description>Selects the clock source
1 = DIV1 clock
0 = DIVN clock</description>
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>CMAC_CLK_ENABLE</name>
	<description>Enables the CMAC clock.</description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>CLK_RC32M_REG</name>
	<description>Fast RC control register</description>
	<addressOffset>0x00000044</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x0000078e</resetValue>
	<resetMask>0x00000fff</resetMask>
	<fields><field>
	<name>RC32M_COSC</name>
	<description>C-adjust of RC-oscillator
A higher value of COSC results in a lower frequency</description>
	<bitRange>[10:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RC32M_RANGE</name>
	<description>Coarse adjust
A higher value of RANGE results in a higher frequency, values 2 and 3 are equal</description>
	<bitRange>[6:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RC32M_BIAS</name>
	<description>Bias adjustment</description>
	<bitRange>[4:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RC32M_ENABLE</name>
	<description>Enables the 32-MHz RC oscillator </description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>CLK_RCLP_REG</name>
	<description>32/512 kHz RC oscillator register</description>
	<addressOffset>0x0000003c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000038</resetValue>
	<resetMask>0x0000007f</resetMask>
	<fields><field>
	<name>RCLP_TRIM</name>
	<description>0000 = lowest frequency
0111 = default
1111 = highest frequency </description>
	<bitRange>[6:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RCLP_LOW_SPEED_FORCE</name>
	<description>Puts the RCLP in 32-kHz mode. </description>
	<bitRange>[2:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RCLP_HIGH_SPEED_FORCE</name>
	<description>Puts the RCLP in 512-kHz mode
1: Frequency is 512 kHz</description>
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RCLP_DISABLE</name>
	<description>Disables the RCLP oscillator</description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>CLK_RCX_REG</name>
	<description>RCX-oscillator control register</description>
	<addressOffset>0x00000048</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x0000057e</resetValue>
	<resetMask>0x000007ff</resetMask>
	<fields><field>
	<name>RCX_BIAS</name>
	<description>LDO bias current.
0x0: minimum
0xF: maximum</description>
	<bitRange>[10:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RCX_C0</name>
	<description>Add unit capacitance to RC-time delay.</description>
	<bitRange>[6:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RCX_CADJUST</name>
	<description>Adjust capacitance part of RC-time delay.
0x00: minimum capacitance
0x1F: maximum capacitance</description>
	<bitRange>[5:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RCX_ENABLE</name>
	<description>0: Disable the RCX oscillator (watchdog runs at RCLP)
1: Enable the RCX oscillator (watchdog runs at RCX)</description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>CLK_RTCDIV_REG</name>
	<description>Divisor for RTC 100 Hz clock</description>
	<addressOffset>0x0000004c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00051ea8</resetValue>
	<resetMask>0x003fffff</resetMask>
	<fields><field>
	<name>RTC_RESET_REQ</name>
	<description>Reset request for the RTC module</description>
	<bitRange>[21:21]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RTC_DIV_ENABLE</name>
	<description>Enable for the 100 Hz generation for the RTC block</description>
	<bitRange>[20:20]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RTC_DIV_DENOM</name>
	<description>Selects the denominator for the fractional division:
0b0: 1000
0b1: 1024</description>
	<bitRange>[19:19]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RTC_DIV_INT</name>
	<description>Integer divisor part for RTC 100Hz generation</description>
	<bitRange>[18:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RTC_DIV_FRAC</name>
	<description>Fractional divisor part for RTC 100-Hz generation.
If RTC_DIV_DENOM = 1, &lt;RTC_DIV_FRAC&gt; out of 1024 cycles will divide by &lt;RTC_DIV_INT+1&gt;, the rest is &lt;RTC_DIV_INT&gt;
If RTC_DIV_DENOM = 0, &lt;RTC_DIV_FRAC&gt; out of 1000 cycles will divide by &lt;RTC_DIV_INT+1&gt;, the rest is &lt;RTC_DIV_INT&gt;</description>
	<bitRange>[9:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>CLK_SWITCH2XTAL_REG</name>
	<description>Switches clock from RC32M to XTAL32M</description>
	<addressOffset>0x0000001c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00000001</resetMask>
	<fields><field>
	<name>SWITCH2XTAL</name>
	<description>When writing to this register, the clock switch will happen from RC32M to XTAL32M. If any other clock is selected than RC32M, the selection is discarded.</description>
	<bitRange>[0:0]</bitRange>
	<access>write-only</access>
	</field></fields>
</register><register>
	<name>CLK_TMR_REG</name>
	<description>Clock control for the timers</description>
	<addressOffset>0x00000018</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00000007</resetMask>
	<fields><field>
	<name>TMR2_PWM_AON_MODE</name>
	<description>Maps Timer2 PWM onto P0_10.
This state is preserved during deep sleep to allow PWM output on the pad during deep sleep.</description>
	<bitRange>[2:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>TMR_PWM_AON_MODE</name>
	<description>Maps Timer1 PWM onto P0_12.
This state is preserved during deep sleep to allow PWM output on the pad during deep sleep.</description>
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>WAKEUPCT_ENABLE</name>
	<description>Enables the clock</description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>CLK_XTAL32K_REG</name>
	<description>32 kHz XTAL oscillator register</description>
	<addressOffset>0x00000040</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x0000102e</resetValue>
	<resetMask>0x00001fff</resetMask>
	<fields><field>
	<name>XTAL32K_VDDX_TRIM</name>
	<description>Trim for the pre-regulator for the oscillator core, running on VDCDC.</description>
	<bitRange>[12:9]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>XTAL32K_DISABLE_AMPREG</name>
	<description>Setting this bit disables the amplitude regulation of the XTAL32kHz oscillator.
Set this bit to 1 for an external clock to XTAL32Kp
Keep this bit 0 with a crystal between XTAL32Kp and XTAL32Km</description>
	<bitRange>[7:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>XTAL32K_CUR</name>
	<description>Bias current for the 32-kHz XTAL oscillator.
0000 is minimum, 1111 is maximum, 0011 is default.
For each application there is an optimal setting for which the start-up behavior is optimal </description>
	<bitRange>[6:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>XTAL32K_RBIAS</name>
	<description>Setting for the bias resistor. 00 is maximum, 11 is minimum. Preferred setting will be provided by Renesas. </description>
	<bitRange>[2:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>XTAL32K_ENABLE</name>
	<description>Enables the 32kHz XTAL oscillator </description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>DISCHARGE_RAIL_REG</name>
	<description>Immediate rail resetting. There is no LDO/DCDC gating</description>
	<addressOffset>0x000000d4</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00000007</resetMask>
	<fields><field>
	<name>RESET_VDD</name>
	<description>1: Enables immediate discharging of the VDD rail. Note that the source is not disabled.
0: disable immediate discharging of the VDD rail.</description>
	<bitRange>[2:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RESET_VDCDC</name>

	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RESET_VIO</name>
	<description>1: Enables immediate discharging of the VDDIO rail. Note that the source is not disabled.
0: disable immediate discharging of the VDDIO rail.</description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>HIBERN_CTRL_REG</name>
	<description>Hibernation control register</description>
	<addressOffset>0x000000f0</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000003f</resetMask>
	<fields><field>
	<name>HIBERN_WKUP_MASK</name>
	<description>Selects which pin to wake-up from:
00: No wake-up pin enabled
x1: P0[14] enabled as wake-up pin
1x: P1[4] enabled as wake-up pin</description>
	<bitRange>[5:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>HIBERN_WKUP_POLARITY</name>
	<description>Selects the polarity of the wake-up source:
x0: P0[14] active high wake-up pin
x1: P0[14] active low wake-up pin
0x: P1[4] active high wake-up pin
1x: P1[4] active low wake-up pin</description>
	<bitRange>[3:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>HIBERNATION_ENABLE</name>
	<description>Enables the hibernation mode when sleeping
0: Deep sleep mode, PD_SLP remains on
1: Hibernation mode, PD_SLP goes off.</description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>P0_PAD_LATCH_REG</name>
	<description>Control the state retention of the GPIO ports</description>
	<addressOffset>0x00000070</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x0000ffff</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>P0_LATCH_EN</name>
	<description>Direct write to the individual pad latching signals.
Latches the control signals of the pads for state retention in powerdown mode.
0 = Control signals are retained
1 = Latch is transparent, pad can be recontrolled </description>
	<bitRange>[15:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>P0_RESET_PAD_LATCH_REG</name>
	<description>Control the state retention of the GPIO ports</description>
	<addressOffset>0x00000078</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>P0_RESET_LATCH_EN</name>
	<description>Direct Reset of the marked bits. Reading returns 0x0.</description>
	<bitRange>[15:0]</bitRange>
	<access>write-only</access>
	</field></fields>
</register><register>
	<name>P0_SET_PAD_LATCH_REG</name>
	<description>Control the state retention of the GPIO ports</description>
	<addressOffset>0x00000074</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>P0_SET_LATCH_EN</name>
	<description>Direct Set of the marked bits. Reading returns 0x0.</description>
	<bitRange>[15:0]</bitRange>
	<access>write-only</access>
	</field></fields>
</register><register>
	<name>P1_PAD_LATCH_REG</name>
	<description>Control the state retention of the GPIO ports</description>
	<addressOffset>0x0000007c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x0000ffff</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>P1_LATCH_EN</name>
	<description>Direct write to the individual pad latching signals.
Latches the control signals of the pads for state retention in powerdown mode.
0 = Control signals are retained
1 = Latch is transparent, pad can be recontrolled </description>
	<bitRange>[15:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>P1_RESET_PAD_LATCH_REG</name>
	<description>Control the state retention of the GPIO ports</description>
	<addressOffset>0x00000084</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>P1_RESET_LATCH_EN</name>
	<description>Direct Reset of the marked bits. Reading returns 0x0. </description>
	<bitRange>[15:0]</bitRange>
	<access>write-only</access>
	</field></fields>
</register><register>
	<name>P1_SET_PAD_LATCH_REG</name>
	<description>Control the state retention of the GPIO ports</description>
	<addressOffset>0x00000080</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>P1_SET_LATCH_EN</name>
	<description>Direct Set of the marked bits. Reading returns 0x0.</description>
	<bitRange>[15:0]</bitRange>
	<access>write-only</access>
	</field></fields>
</register><register>
	<name>PMU_CTRL_REG</name>
	<description>Power Management Unit control register</description>
	<addressOffset>0x00000020</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x0000040f</resetValue>
	<resetMask>0x00000fff</resetMask>
	<fields><field>
	<name>RETAIN_CMAC_CACHE</name>
	<description>Selects the retainability of the cmac cache block during deep sleep.
1 is retainable
0 is power gated</description>
	<bitRange>[11:11]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>AUD_SLEEP</name>
	<description>Put the AUDIO power domain (PD_AUD) in powerdown.</description>
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>LP_CLK_OUTPUT_EN</name>
	<description>LP_CLK output enable bit:
0: Disabled
1: Map LP_CLK on GPIO P0[12]</description>
	<bitRange>[9:9]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RETAIN_CACHE</name>
	<description>Selects the retainability of the system cache block during deep sleep.
1 is retainable
0 is power gated</description>
	<bitRange>[7:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SYS_SLEEP</name>
	<description>Put the System powerdomain (PD_SYS) in powerdown.
If this bit is 1, and there is no pending IRQ in the PDC for the M33, the PD_SYS will be switched off.
Wake-up should be handled by the PDC.</description>
	<bitRange>[6:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RESET_ON_WAKEUP</name>
	<description>Perform a hardware reset after waking up. Booter will be started. </description>
	<bitRange>[5:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>MAP_BANDGAP_EN</name>
	<description>Setting this bit will:

- map bandgap_enable to P0_11
- map (wokenup OR cmac_slp_timer_expire) to P1_02</description>
	<bitRange>[4:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>COM_SLEEP</name>
	<description>Put the Communications powerdomain (PD_COM) in powerdown </description>
	<bitRange>[3:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>TIM_SLEEP</name>
	<description>Put the Timers Powerdomain (PD_TIM) in powerdown.</description>
	<bitRange>[2:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RADIO_SLEEP</name>
	<description>Put the digital part of the radio, including CMAC (PD_RAD) in powerdown </description>
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PERIPH_SLEEP</name>
	<description>Put the peripherals power domain (PD_PER) in powerdown</description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>PMU_SLEEP_REG</name>
	<description>Configures the sleep/wake-up strategy</description>
	<addressOffset>0x000000f4</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00002080</resetValue>
	<resetMask>0x0001ffff</resetMask>
	<fields><field>
	<name>FAST_WAKEUP</name>
	<description>Speeds up the wake-up process by enabling all LDOs simultaneously instead of in staggered order. Only use if all voltages have been retained during sleep.</description>
	<bitRange>[16:16]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>LDO_OK_BYPASS</name>
	<description>Don't wait for LDO_OK signals in the wake-up process from sleep mode, but use a fixed timeout of 32 us.
The BOD comparator check will make sure the supplies are OK before going to active state. </description>
	<bitRange>[15:15]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>FAST_WAKEUP_SKIP_BGR_OK</name>
	<description>Go to running mode immediately, do not wait for the BGR_OK signal after a fast_wakeup trigger</description>
	<bitRange>[14:14]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>BOD_MASK_BGR_OK</name>
	<description>MASK BOD reset when BGR is NOK</description>
	<bitRange>[13:13]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>BG_ENABLE_SLEEP</name>
	<description>Keep the bandgap enabled during deep sleep operation</description>
	<bitRange>[12:12]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>BG_REFRESH_INTERVAL</name>
	<description>This is a value defining the interval every which the Bandgap will be activated for refresh. The value represents ticks of lp_clk/64, for example, 30,5 us * 64 = 1,9 ms.</description>
	<bitRange>[11:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>POR_PIN_REG</name>
	<description>Selects a GPIO pin for POR generation</description>
	<addressOffset>0x00000098</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x0000003f</resetValue>
	<resetMask>0x000000ff</resetMask>
	<fields><field>
	<name>POR_PIN_POLARITY</name>
	<description>0: Active Low
1: Active High
Note: This applies only for the GPIO pin. Reset pad is always active High</description>
	<bitRange>[7:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>POR_PIN_SELECT</name>
	<description>0x00: P0_00
...
0x0F: P0_15
0x10: P1_00
...
0x1F: P1_15
0x20 to 0x3E: reserved
0x3F: POR generation disabled</description>
	<bitRange>[5:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>POR_TIMER_REG</name>
	<description>Time for POR to happen</description>
	<addressOffset>0x0000009c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000018</resetValue>
	<resetMask>0x0000007f</resetMask>
	<fields><field>
	<name>POR_TIME</name>
	<description>Time for the POReset to happen.
Formula:
Time = POR_TIME x 4096 x RC32 clock period
Default value: ~3 seconds</description>
	<bitRange>[6:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>POWER_CTRL_REG</name>
	<description>Power control register</description>
	<addressOffset>0x000000e0</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00006517</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>LDO_CORE_RET_VREF_ENABLE</name>
	<description>Enable the LDO_CORE_RET VREF buffer in the bandgap. </description>
	<bitRange>[14:14]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>LDO_IO_RET_VREF_ENABLE</name>
	<description>Enable the LDO_IO_RET VREF buffer in the bandgap</description>
	<bitRange>[13:13]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>LDO_VREF_HOLD_FORCE</name>
	<description>Forces LDO references in hold mode</description>
	<bitRange>[12:12]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DCDC_ENABLE_SLEEP</name>
	<description>Enable the DCDC in sleep mode when DCDC_ENABLE is also set in DCDC_CTRL_REG</description>
	<bitRange>[11:11]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>LDO_CORE_RET_ENABLE_SLEEP</name>
	<description>Enables (1) or disables (0) LDO_CORE_RET in sleep mode</description>
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>LDO_CORE_RET_ENABLE_ACTIVE</name>
	<description>Enables (1) or disables (0) LDO_CORE_RET in active mode</description>
	<bitRange>[9:9]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>LDO_LOW_ENABLE_SLEEP</name>
	<description>Enable the LDO_LOW in sleep mode</description>
	<bitRange>[8:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>LDO_LOW_HIGH_CURRENT</name>
	<description>Force high current mode for LDO_LOW</description>
	<bitRange>[7:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>LDO_IO_BYPASS_SLEEP</name>
	<description>Enables the LDO_IO bypass in sleep mode. Note that, when this bit is asserted, it overrules the regulating operation of the LDO</description>
	<bitRange>[6:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>LDO_IO_BYPASS_ACTIVE</name>
	<description>Enables the LDO_IO bypass in active mode. Note that, when this bit is asserted, it overrules the regulating operation of the LDO</description>
	<bitRange>[5:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>LDO_IO_RET_ENABLE_SLEEP</name>
	<description>Enables (1) or Disables (0) LDO_IO_RET in sleep mode</description>
	<bitRange>[4:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>LDO_IO_RET_ENABLE_ACTIVE</name>
	<description>Enables (1) or Disables (0) LDO_IO_RET in active mode</description>
	<bitRange>[3:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>LDO_CORE_ENABLE</name>
	<description>Enables the LDO_CORE (0) Disable (1) Enable</description>
	<bitRange>[2:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>LDO_LOW_ENABLE_ACTIVE</name>
	<description>Enables the LDO_LOW (0) Disable (1) Enable</description>
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>LDO_IO_ENABLE</name>
	<description>Enables the LDO_IO... (0) Disable (1) Enable</description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>POWER_LEVEL_REG</name>
	<description>Power level settings</description>
	<addressOffset>0x000000e4</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00001800</resetValue>
	<resetMask>0x00003fff</resetMask>
	<fields><field>
	<name>XTAL32M_LDO_LEVEL</name>
	<description>Set the Level of the Xtal LDO.
0x0 = 882 mV
0x1 = 888 mV
0x2 = 894 mV
0x3 = 900 mV
0x4 = 906 mV
0x5 = 912 mV
0x6 = 918 mV
0x7 = 924 mV</description>
	<bitRange>[13:11]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>VDDIO_TRIM</name>
	<description>Set the VDDIO level (25 mV/LSB):
0x8: 1.6 V
0x9: 1.625 V
...
0xF: 1.775 V
0x0: 1.8 V
0x1: 1.825 V
...
0x7: 1.975 V</description>
	<bitRange>[10:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>VDCDC_LEVEL</name>
	<description>Set the VDCDC level, 0x0 = 1.1 V, 0x7 = 1.45 V, step = 50 mV</description>
	<bitRange>[6:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>VDD_LEVEL_SLEEP</name>
	<description>Set the VDD level in sleep mode. 0x0 = 0.75 V, 0x1 = 0.9 V</description>
	<bitRange>[3:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>VDD_LEVEL_ACTIVE</name>
	<description>Level setting for VDD rail
0x0: 0.9 V , 0x7 = 1.25 V
50 mV steps</description>
	<bitRange>[2:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>RAM_PWR_CTRL_REG</name>
	<description>Control power state of System RAMS</description>
	<addressOffset>0x000000c0</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000003f</resetMask>
	<fields><field>
	<name>RAM3_PWR_CTRL</name>
	<description>See description of RAM1_PWR_CTRL.</description>
	<bitRange>[5:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RAM2_PWR_CTRL</name>
	<description>See description of RAM1_PWR_CTRL.</description>
	<bitRange>[3:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RAM1_PWR_CTRL</name>
	<description>Power state control of the individual RAMs. May only change when the memory isn't accessed.
When PD_MEM_IS_UP:
0x0: Normal operation
0x1: Normal operation
0x2: Retained (no access possible)
0x3: Off (memory content corrupted)
When PD_MEM_IS_DOWN:
0x0: Retained
0x1: Off (memory content corrupted)
0x2: Retained
0x3: Off (memory content corrupted)</description>
	<bitRange>[1:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>RESET_STAT_REG</name>
	<description>Reset status register</description>
	<addressOffset>0x000000bc</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x0000003f</resetValue>
	<resetMask>0x0000003f</resetMask>
	<fields><field>
	<name>CMAC_WDOGRESET_STAT</name>
	<description>Indicates that a CMAC-Watchdog timeout has happened. Note that it is also set when a POReset has happened.</description>
	<bitRange>[5:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SWD_HWRESET_STAT</name>
	<description>Indicates that a write to SWD_RESET_REG has happened. Note that it is also set when a POReset has happened.</description>
	<bitRange>[4:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>WDOGRESET_STAT</name>
	<description>Indicates that a Watchdog timeout has happened. Note that it is also set when a POReset has happened.</description>
	<bitRange>[3:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SWRESET_STAT</name>
	<description>Indicates that a software reset has happened</description>
	<bitRange>[2:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>HWRESET_STAT</name>
	<description>Indicates that a hardware reset has happened</description>
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PORESET_STAT</name>
	<description>Indicates that a PowerOn Reset has happened.
All bitfields of RESET_STAT_REG should be read (to check the source of reset) and then cleared to 0, allowing thus the hardware to automatically set to 1 the proper bitfields during the next reset event.</description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>RST_CTRL_REG</name>
	<description>Reset control register</description>
	<addressOffset>0x0000000c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00000007</resetMask>
	<fields><field>
	<name>CMAC_CACHE_FLUSH_WITH_SW_RESET</name>
	<description>0: Flush the CMAC Cache memory only at hardware reset.
1: Flush the CMAC Cache memory also at software reset.</description>
	<bitRange>[2:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SYS_CACHE_FLUSH_WITH_SW_RESET</name>
	<description>0: Flush the System Cache memory only at hardware reset.
1: Flush the System Cache memory also at software reset.</description>
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>GATE_RST_WITH_FCU</name>
	<description>0: Reset is not gated with FCU write/erase
1: Reset delayed in case FCU write/erase is ongoing. Software reset is never gated so should not be set during FCU write/erase.</description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>SECURE_BOOT_REG</name>
	<description>Controls secure booting (only ROM software can write)</description>
	<addressOffset>0x000000cc</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x000001ff</resetMask>
	<fields><field>
	<name>PROT_INFO_PAGE</name>
	<description>Protection of eFlash info page
0: Write/erase of info page enabled
1: Write/erase of info page permanently disabled</description>
	<bitRange>[8:8]</bitRange>
	<access>read-writeOnce</access>
	</field><field>
	<name>SECURE_BOOT</name>
	<description>Follows the respective eFlash flag value
0: System is not supporting secure boot
1: System is a secure system supporting secure boot</description>
	<bitRange>[6:6]</bitRange>
	<access>read-writeOnce</access>
	</field><field>
	<name>FORCE_CMAC_DEBUGGER_OFF</name>
	<description>This bit will permanently disable the CMAC debugger</description>
	<bitRange>[5:5]</bitRange>
	<access>read-writeOnce</access>
	</field><field>
	<name>FORCE_M33_DEBUGGER_OFF</name>
	<description>This bit will permanently disable the M33 debugger</description>
	<bitRange>[4:4]</bitRange>
	<access>read-writeOnce</access>
	</field><field>
	<name>PROT_USER_APP_CODE</name>
	<description>This bit will permanently disable write/erase of user application code sector</description>
	<bitRange>[3:3]</bitRange>
	<access>read-writeOnce</access>
	</field><field>
	<name>PROT_VALID_KEY</name>
	<description>This bit will permanently disable read/erase of validation keys sector</description>
	<bitRange>[2:2]</bitRange>
	<access>read-writeOnce</access>
	</field><field>
	<name>PROT_APP_KEY</name>
	<description>This bit will permanently disable read/erase of application keys sector</description>
	<bitRange>[1:1]</bitRange>
	<access>read-writeOnce</access>
	</field><field>
	<name>PROT_CONFIG_SCRIPT</name>
	<description>This bit will permanently disable write/erase of configuration script sector</description>
	<bitRange>[0:0]</bitRange>
	<access>read-writeOnce</access>
	</field></fields>
</register><register>
	<name>STARTUP_STATUS_REG</name>
	<description>Startup Statemachine Status Register</description>
	<addressOffset>0x000000fc</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x000fffff</resetMask>
	<fields><field>
	<name>VEFLASH_LVL_RD</name>
	<description>Read back the Eflash level setting. </description>
	<bitRange>[9:9]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>BOD_VEFLASH_OK_SYNC</name>
	<description>Read back the synchronized signal from the veflash comparator.It will become 0x1 when the VDD &gt;1.08 V.This bit does not inform of a BOD event</description>
	<bitRange>[8:8]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>BOD_VDDIO_OK_SYNC_RD</name>
	<description>Read back the synchronized signal from the vdcdc bod comparator</description>
	<bitRange>[7:7]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>BOD_VDDD_OK_SYNC_RD</name>
	<description>Read back the synchronized signal from the vddd bod comparator</description>
	<bitRange>[6:6]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>BOD_VDCDC_OK_SYNC_RD</name>
	<description>Read back the synchronized signal from the vdcdc bod comparator</description>
	<bitRange>[5:5]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>BOD_VDDD_LVL_RD</name>
	<description>Read back bod_vddd_lvl setting. </description>
	<bitRange>[4:3]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>BOD_VDDIO_MASK_SYNC_RD</name>
	<description>Synchronized bod_vddio_mask bit.
Can be used to check if mask bit has been set</description>
	<bitRange>[2:2]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>BOD_VDDD_MASK_SYNC_RD</name>
	<description>Synchronized bod_vddd_mask bit.
Can be used to check if mask bit has been set</description>
	<bitRange>[1:1]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>BOD_VDCDC_MASK_SYNC_RD</name>
	<description>Synchronized bod_vdcdc_mask bit.
Can be used to check if mask bit has been set</description>
	<bitRange>[0:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>SYS_CTRL_REG</name>
	<description>System Control register</description>
	<addressOffset>0x00000024</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000020</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>SW_RESET</name>
	<description>Writing 1 to this bit will generate a SW_RESET.</description>
	<bitRange>[15:15]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>CACHERAM_MUX</name>
	<description>Controls accessibility of Cache RAM (incl. enabling/disabling of the Cache Controller):
0: The cache controller is disabled/bypassed, the cacheRAM is visible in the memory space,
1: The cache controller is enabled, the cacheRAM is not visible anymore in the memory space.
Note: When the cache controller is enabled after or at reset, the Cache is first initialized (cleared/flushed) by writing all 0s to each line, one line per clock cycle to all SRAM modules.
When the cache controller is disabled/bypassed the cache memory is cleared/flushed in the same way as during the first after reset initialization.</description>
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DEBUGGER_ENABLE</name>
	<description>Enable the debugger. This bit is set by the booter according to the OTP header. If not set, the SWDIO and SW_CLK can be used as gpio ports. </description>
	<bitRange>[7:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>REMAP_INTVECT</name>
	<description>0: Normal operation
1: If ARM is in address range 0 to 0x1FF then the address is remapped to SYS-RAM 0x0080.0000 to 0x0080.01FF. This allows to put the interrupt vector table to be placed in RAM while executing, for example, from QSPI.</description>
	<bitRange>[3:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>REMAP_ADR0</name>
	<description>Controls which memory is located at address 0x0000 for execution.
0x0: ROM
0x1: eFlash
Note 1: When REMAP_ADR0 = 0x1, address 0x0 is mapped to EFLASH_REGION_BASE + EFLASH_REGION_OFFSET&lt;&lt;2
Note 2: When REMAP_ADR0 = 0x1, the CPU can only access the eFlash region [EFLASH_REGION_BASE + EFLASH_REGION_OFFSET&lt;&lt;2, EFLASH_REGION_SIZE] from the 0x00A00000 address range. The complete eFlash can be accessed via the 0x31000000 address range but only uncached.0x2: QSPI FLASH cached (see also the CACHE_FLASH_REG.FLASH_REGION.* descriptions)
Note 1: When REMAP_ADR0=0x2, address 0x0 is mapped to FLASH_REGION_BASE + FLASH_REGION_OFFSET&lt;&lt;2.
Note 2: When REMAP_ADR0=0x2, the CPU can only access the Flash region [FLASH_REGION_BASE + FLASH_REGION_OFFSET&lt;&lt;2, FLASH_REGION_SIZE] from the 0x16000000 address range. The complete Flash can be accessed via the 0x32000000 address range but only uncached. 0x3: SYSRAMS un-cached
0x4: SYSRAM3 (for testing purposes only)
0x5: System Cache Data RAM un-cached (CACHERAM_MUX = 0)
Note 1: DWord (64 bits) access is not supported by the Cache Data RAM interface in mirrored mode (only 32, 16 and 8 bits).
Note 2: DMA access is not supported by the Cache Data RAM interface when REMAP_ADR0 = 0x5. 0x6: QSPI FLASH un-cached (for verification only)
0x7: No remapping (only relevant for the CMAC Cache)</description>
	<bitRange>[2:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>SYS_STAT_REG</name>
	<description>System status register</description>
	<addressOffset>0x00000028</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x000095a5</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>POWER_IS_UP</name>
	<description>Indicates that the Startup state machine is finished, and all power regulation are in order.
In Fast Wake-up mode, the software needs to wait for this signal before starting any heavy traffic.</description>
	<bitRange>[15:15]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>DBG_IS_ACTIVE</name>
	<description>Indicates that a debugger is attached.</description>
	<bitRange>[14:14]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>AUD_IS_UP</name>
	<description>Indicates that PD_AUD is functional </description>
	<bitRange>[13:13]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>AUD_IS_DOWN</name>
	<description>Indicates that PD_AUD is in power down </description>
	<bitRange>[12:12]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>COM_IS_UP</name>
	<description>Indicates that PD_COM is functional </description>
	<bitRange>[11:11]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>COM_IS_DOWN</name>
	<description>Indicates that PD_COM is in power down </description>
	<bitRange>[10:10]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>TIM_IS_UP</name>
	<description>Indicates that PD_TIM is functional </description>
	<bitRange>[9:9]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>TIM_IS_DOWN</name>
	<description>Indicates that PD_TIM is in power down </description>
	<bitRange>[8:8]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>MEM_IS_UP</name>
	<description>Indicates that PD_MEM is functional</description>
	<bitRange>[7:7]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>MEM_IS_DOWN</name>
	<description>Indicates that PD_MEM is in power down</description>
	<bitRange>[6:6]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>SYS_IS_UP</name>
	<description>Indicates that PD_SYS is functional </description>
	<bitRange>[5:5]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>SYS_IS_DOWN</name>
	<description>Indicates that PD_SYS is in power down </description>
	<bitRange>[4:4]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>PER_IS_UP</name>
	<description>Indicates that PD_PER is functional </description>
	<bitRange>[3:3]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>PER_IS_DOWN</name>
	<description>Indicates that PD_PER is in power down </description>
	<bitRange>[2:2]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>RAD_IS_UP</name>
	<description>Indicates that PD_RAD is functional </description>
	<bitRange>[1:1]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>RAD_IS_DOWN</name>
	<description>Indicates that PD_RAD is in power down </description>
	<bitRange>[0:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register></registers>
</peripheral><peripheral>
	<name>CRG_XTAL</name>
	<version>1.0</version>
	<description>CRG_XTAL registers</description>
	<groupName>Peripheral_Registers</groupName>
	<baseAddress>0x50010000</baseAddress>
	<size>0</size>
	<addressBlock>
	<offset>0</offset>
	<size>108</size>
	<usage>registers</usage>
</addressBlock>

	<registers>
	<register>
	<name>CLKDBLR_CTRL1_REG</name>
	<description>Clock Doubler Control Logic control register 1</description>
	<addressOffset>0x00000060</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000001</resetValue>
	<resetMask>0x007fffff</resetMask>
	<fields><field>
	<name>DELAY_TDC_OVR</name>
	<description>Overrule value for the delay_tdc output.</description>
	<bitRange>[22:17]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DELAY_64M_PRE_OVR</name>
	<description>Overrule value for the delay_64m_pre output.</description>
	<bitRange>[16:12]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DELAY_64M_OVR</name>
	<description>Overrule value for the delay_64m output.</description>
	<bitRange>[11:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DELAY_32M_OVR</name>
	<description>Overrule value for the delay_32m output.</description>
	<bitRange>[7:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>OVERRIDE</name>
	<description>Bypass the Clock Doubler Control Logic.
0: Normal operation
1: Bypass the Control Logic and force its outputs to CLKDBLR_CTRL1_REG[DELAY*OVR] and CLKDBLR_CTRL2_REG[*OVR] values.
Override mode enabling sequence:
1. Set CLKDBLR_CTRL*_REG[*OVR] bits except CLKDBLR_CTRL2_REG[OUTPUT_ENABLE_OVR] to desired values.
2. Release the reset via CLKDBLR_CTRL1_REG[RESET_N]
3. Set CLKDBLR_CTRL1_REG[OVERRIDE] to 1.
4. Set CLKDBLR_CTRL2_REG[OUTPUT_ENABLE_OVR] to 1.
5. Set CLKDBLR_CTRL1_REG[ENABLE] to 1.</description>
	<bitRange>[2:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>ENABLE</name>
	<description>Enable the Control Logic.
0: Disabled
1: Enabled</description>
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RESET_N</name>
	<description>Reset the Control Logic.
0: Reset state
1: Normal operation.</description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>CLKDBLR_CTRL2_REG</name>
	<description>Clock Doubler Control Logic control register 2</description>
	<addressOffset>0x00000064</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>DELAY_64M_PRE_OFFSET</name>
	<description>Offset to be added to the delay_64m_pre output.</description>
	<bitRange>[15:14]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PRELOAD</name>
	<description>Preload the internal registers with CLKDBLR_CTRL1_REG[DELAY*OVR] inputs to give a good starting point to the FSM.
0: Normal mode.
1: Preload mode.</description>
	<bitRange>[13:13]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>INV_CLK</name>
	<description>Invert the clock of the tdc_in register.</description>
	<bitRange>[12:12]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DUTY_CYCLE_CORR_COUNT</name>
	<description>Duty cycle correction interval.
0: Maintenance mode disabled.
1..15: Re-calculate delay outputs every 2N clock cycles.</description>
	<bitRange>[11:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>LOW_POWER_OVR</name>
	<description>Overrule value for the low_power output.</description>
	<bitRange>[7:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>EN_ADJ_32M_OVR</name>
	<description>Overrule value for the en_adj_32m.</description>
	<bitRange>[6:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>EN_ADJ_64M_OVR</name>
	<description>Overrule value for the en_adj_64m.</description>
	<bitRange>[5:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>EN_TDC_OVR</name>
	<description>Overrule value for the en_tdc.</description>
	<bitRange>[4:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PHASE_INV_32M_OVR</name>
	<description>Overrule value for the phase_inv_32m.</description>
	<bitRange>[3:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SEL_32M_64M_CLK_OVR</name>
	<description>Overrule value for the sel_32m_64m_clk</description>
	<bitRange>[2:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>TDC_CLK_INV_OVR</name>
	<description>Overrule value for the tdc_clk_inv.</description>
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>OUTPUT_ENABLE_OVR</name>
	<description>Overrule value for the output_enable.</description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>CLKDBLR_STATUS_REG</name>
	<description>Clock Doubler Control Logic status register</description>
	<addressOffset>0x00000068</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0xffffffff</resetMask>
	<fields><field>
	<name>PHASE_INV_32M</name>
	<description>Read-out of the phase_inv_32m output of the Clock Doubler Control Logic.</description>
	<bitRange>[31:31]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>CLKDBLR_STATE</name>
	<description>Read-out of the state of the Clock Doubler Control Logic FSM state.</description>
	<bitRange>[30:26]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>OUTPUT_READY</name>
	<description>Ready flag which indicates that 64 MHz clock is available
0: 64 MHz clock not available
1: 64 MHz clock available
Note: This is an output of the calibration FSM, indicating calibration is finished and 64 MHz clock should be available. It is not a signal which shows the actual status of the 64-MHz clock.</description>
	<bitRange>[25:25]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>TDC_BIN_OUT</name>
	<description>TDC binary output.</description>
	<bitRange>[24:20]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>DELAY_TDC_OUT</name>
	<description>Delay value for the TDC block.</description>
	<bitRange>[19:14]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>DELAY_64M_PRE_OUT</name>
	<description>Delay value for the 64 MHz DTC block.</description>
	<bitRange>[13:9]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>DELAY_64M_OUT</name>
	<description>Delay value for the 64 MHz DTC block.</description>
	<bitRange>[8:5]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>DELAY_32M_OUT</name>
	<description>Delay value for the 32 MHz DTC block.</description>
	<bitRange>[4:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>XTAL32M_CAP_MEAS_REG</name>
	<description>Capacitance measure circuit control</description>
	<addressOffset>0x0000000c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000098</resetValue>
	<resetMask>0x000001ff</resetMask>
	<fields><field>
	<name>XTAL32M_MEAS_TIME</name>
	<description>Select measurement time (in DIVN clock-cycles)
0: 32
1: 64

6: 2048
7: 4096</description>
	<bitRange>[8:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>XTAL32M_MEAS_START</name>
	<description>Starts capacitance measurement</description>
	<bitRange>[5:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>XTAL32M_MEAS_CUR</name>
	<description>Select measurement current (minimum required capacitance)
0: 100 nA (0.44 pF)
1: 500 nA (2.22 pF)
2: 1 uA (4.44 pF)
3: 5 uA (22.2 pF)</description>
	<bitRange>[4:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>XTAL32M_CAP_SELECT</name>
	<description>Select measured capacitance
0: disabled
1: hold capacitance
2: xtal_p
3: xtal_n
4: xtal_p + xtal_n
5: low reference on xtal_p
6: low reference on xtal_p</description>
	<bitRange>[2:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>XTAL32M_CTRL_REG</name>
	<description>Xtal32m control register</description>
	<addressOffset>0x00000014</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000015</resetValue>
	<resetMask>0x000001ff</resetMask>
	<fields><field>
	<name>XTAL32M_ENABLE</name>
	<description>Enables xtal32m (testing purposes)</description>
	<bitRange>[8:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>XTAL32M_BIASPROT</name>
	<description>Bias startup circuit
0: enable during startup
1: always enabled
2: always disabled</description>
	<bitRange>[7:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>XTAL32M_LDO_SAH</name>
	<description>Controls amplitude regulator sample-and-hold
2'b00: set to HOLD when IRQ fires
2'b01: always TRACK
2'b1x: always HOLD</description>
	<bitRange>[5:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>XTAL32M_AMPREG_SAH</name>
	<description>Controls amplitude regulator sample-and-hold
2'b00: set to HOLD when IRQ fires
2'b01: always TRACK
2'b1x: always HOLD</description>
	<bitRange>[3:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>XTAL32M_BIAS_SAH</name>
	<description>Controls bias sample-and-hold
2'b00: set to HOLD when IRQ fires
2'b01: always TRACK
2'b1x: always HOLD</description>
	<bitRange>[1:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>XTAL32M_FSM_REG</name>
	<description>Startup state machine configuration</description>
	<addressOffset>0x00000010</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000001f</resetMask>
	<fields><field>
	<name>XTAL32M_FSM_APPLY_CONFIG</name>
	<description>CUR_SET, AMPL_SET, CMP_LVL and TRIM from XTAL32M_TRIM_REG are
0: applied at next startup
1: immediately applied</description>
	<bitRange>[4:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>XTAL32M_FSM_FORCE_IDLE</name>
	<description>Forces FSM in IDLE state, allows for software control</description>
	<bitRange>[3:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>XTAL32M_CMP_MODE</name>
	<description>Use following comparator trim settings in SETTLE state:
0: XTAL32M_TRIM_REG.CMP_LVL
1: XTAL32M_SETTLE_REG.CMP_LVL</description>
	<bitRange>[2:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>XTAL32M_TRIM_MODE</name>
	<description>Use following trimsetting in the SETTLE state
0: XTAL32M_TRIM_REG.TRIM
1: XTAL32M_SETTLE_REG.TRIM</description>
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>XTAL32M_CUR_MODE</name>
	<description>Use the following current setting in the SETTLE state
0: XTAL32M_START_REG.CUR_SET
1: XTAL32M_SETTLE_REG.CUR_SET</description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>XTAL32M_IRQ_CTRL_REG</name>
	<description>Xtal32m Interrupt control register</description>
	<addressOffset>0x00000018</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x000009ff</resetValue>
	<resetMask>0x00000fff</resetMask>
	<fields><field>
	<name>XTAL32M_IRQ_CAP_CTRL</name>
	<description>The IRQ counter is captured in the XTAL32M_IRQ_STATUS_REG.IRQ_COUNT_CAP when leaving the following state
0: START
1: SETTLE
2: RUN</description>
	<bitRange>[11:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>XTAL32M_IRQ_ENABLE</name>
	<description>Enable xtal interrupt generation.</description>
	<bitRange>[9:9]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>XTAL32M_IRQ_CLK</name>
	<description>Clock divider for IRQ counter
0: 4 us
1: 32 us</description>
	<bitRange>[8:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>XTAL32M_IRQ_CNT</name>
	<description>IRQ counter start value.</description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>XTAL32M_IRQ_STAT_REG</name>
	<description>XTAL32M IRQ status register</description>
	<addressOffset>0x00000028</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>XTAL32M_IRQ_COUNT_CAP</name>
	<description>Captured IRQ counter</description>
	<bitRange>[15:8]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>XTAL32M_IRQ_COUNT_STAT</name>
	<description>Current IRQ counter value</description>
	<bitRange>[7:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>XTAL32M_SETTLE_REG</name>
	<description>Trim values for XTAL32M in SETTLE state of startup</description>
	<addressOffset>0x00000004</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x000685a0</resetValue>
	<resetMask>0x07ffffff</resetMask>
	<fields><field>
	<name>XTAL32M_TIMEOUT</name>
	<description>Timeout
0: disabled
1: 4 us
2: 8 us

63: 252 us
64: 268 us
...
127: 1260 us</description>
	<bitRange>[26:20]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>XTAL32M_CMP_BLANK</name>
	<description>Blanking time for comparator output
0: disabled
1: 4 us
2: 8 us
3: 16 us
4: 32 us
5: 64 us</description>
	<bitRange>[19:17]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>XTAL32M_CMP_LVL</name>
	<description>Comparator triplevel
0: 2 uA
1: 4 uA
2: 8 uA
3: 12 uA</description>
	<bitRange>[16:15]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>XTAL32M_AMPL_SET</name>
	<description>Amplitude Regulator input level setting (peak-peak) in SETTLE phase of startup
0: 300 mV
1: 350 mV
..
7: 900 mV</description>
	<bitRange>[14:12]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>XTAL32M_CUR_SET</name>
	<description>Current setting (uA) in SETTLE phase of startup
0: 32
1: 64
2: 128
3: 192
4: 256
5: 320
6: 384
7: 448
8: 512
9: 576
10: 640
11: 704
12: 768
13: 832
14: 960
15: 1088</description>
	<bitRange>[11:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>XTAL32M_TRIM</name>
	<description>Capacitance bank setting in SETLLE phase of startup
CL = 3.5 pF + 50 fF/LSB</description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>XTAL32M_START_REG</name>
	<description>Trim values for XTAL32M in START state of startup</description>
	<addressOffset>0x00000000</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00070550</resetValue>
	<resetMask>0x07ffffff</resetMask>
	<fields><field>
	<name>XTAL32M_TIMEOUT</name>
	<description>Timeout
0: disabled
1: 4 us
2: 8 us

63: 252 us
64: 268 us
...
127: 1260 us</description>
	<bitRange>[26:20]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>XTAL32M_CMP_BLANK</name>
	<description>Blanking time for comparator output
0: disabled
1: 4 us
2: 8 us
3: 16 us
4: 32 us
5: 64 us</description>
	<bitRange>[19:17]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>XTAL32M_CMP_LVL</name>
	<description>Comparator triplevel
0: 2 uA
1: 4 uA
2: 8 uA
3: 12 uA</description>
	<bitRange>[16:15]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>XTAL32M_AMPL_SET</name>
	<description>Amplitude Regulator input level setting (peak-peak) in START phase of startup
0: 300 mV
1: 350 mV
..
7: 900 mV</description>
	<bitRange>[14:12]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>XTAL32M_CUR_SET</name>
	<description>Current setting (uA) in START phase of startup
0: 32
1: 64
2: 128
3: 192
4: 256
5: 320
6: 384
7: 448
8: 512
9: 576
10: 640
11: 704
12: 768
13: 832
14: 960
15: 1088</description>
	<bitRange>[11:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>XTAL32M_TRIM</name>
	<description>Capacitance bank setting in START phase of startup
CL = 3.5 pF + 50 fF/LSB</description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>XTAL32M_STAT0_REG</name>
	<description>XTAL32M status register</description>
	<addressOffset>0x00000024</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00ffffff</resetMask>
	<fields><field>
	<name>XTAL32M_TRIM_VAL</name>
	<description>Current value for oscillator trimming</description>
	<bitRange>[18:11]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>XTAL32M_CUR_SET_STAT</name>
	<description>Current value for cur_set</description>
	<bitRange>[10:7]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>XTAL32M_LDO_OK</name>
	<description>Indicates LDO voltage level is ok</description>
	<bitRange>[6:6]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>XTAL32M_CMP_OUT</name>
	<description>Amplitude regulator comparator output state</description>
	<bitRange>[5:5]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>XTAL32M_STATE</name>
	<description>State of xtal startup FSM
0x0: IDLE
0x1: WAIT_LDO
0x2: WAIT_BIAS
0x3: START_BLANK
0x4: START
0x5: SETTLE_BLANK
0x6: SETTLE
0x7: RUN
0x8: CAP_TEST_IDLE
0x9: CAP_TEST_MEAS
0xA: CAP_TEST_END</description>
	<bitRange>[4:1]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>XTAL32M_READY</name>
	<description>Indicates xtal startup FSM has reached the RUNNING state and is ready for use (sysclk)</description>
	<bitRange>[0:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>XTAL32M_TRIM_REG</name>
	<description>Trim values for XTAL32M in RUNNING state</description>
	<addressOffset>0x00000008</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x000084a0</resetValue>
	<resetMask>0x0001ffff</resetMask>
	<fields><field>
	<name>XTAL32M_CMP_LVL</name>
	<description>Comparator triplevel
0: 2 uA
1: 4 uA
2: 8 uA
3: 12 uA</description>
	<bitRange>[16:15]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>XTAL32M_AMPL_SET</name>
	<description>Amplitude Regulator input level setting (peak-peak) in running phase
0: 300 mV
1: 350 mV
..
7: 900 mV</description>
	<bitRange>[14:12]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>XTAL32M_CUR_SET</name>
	<description>Current setting (uA) in running phase
0: 32
1: 64
2: 128
3: 192
4: 256
5: 320
6: 384
7: 448
8: 512
9: 576
10: 640
11: 704
12: 768
13: 832
14: 960
15: 1088</description>
	<bitRange>[11:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>XTAL32M_TRIM</name>
	<description>Capacitance bank setting in running phase, use to trim the xtal32m output frequency
CL = 3.5 pF + 50 fF/LSB</description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register></registers>
</peripheral><peripheral>
	<name>DCDC</name>
	<version>1.0</version>
	<description>DCDC registers</description>
	<groupName>Peripheral_Registers</groupName>
	<baseAddress>0x50000300</baseAddress>
	<size>0</size>
	<addressBlock>
	<offset>0</offset>
	<size>4</size>
	<usage>registers</usage>
</addressBlock>

	<registers>
	<register>
	<name>DCDC_CTRL_REG</name>

	<addressOffset>0x00000000</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x001ff4a2</resetValue>
	<resetMask>0x001fffff</resetMask>
	<fields><field>
	<name>DCDC_ILIM_SLP</name>
	<description>Sets the inductor current limit value in sleep mode.</description>
	<bitRange>[20:17]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DCDC_FIX_ILIM_SLP</name>
	<description>Sets a fixed inductor current limit in sleep to maximize amount of charge added per cycle and minimize duty cycle.
0x0: Automatic current limit setting remains active in sleep mode
0x1: Current limit fixed in sleep mode, value set with DCDC_ILIM_SLP field</description>
	<bitRange>[16:16]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DCDC_ILIM_MAX</name>
	<description>Maximum value for automatic inductor peak current limit control.
0x0: 6 mA
0x1: 12 mA
0x2: 18 mA
0x3: 24 mA
0x4: 30 mA
0x5: 36 mA
0x6: 42 mA
0x7: 48 mA
0x8: 54 mA
0x9: 60 mA
0xA: 66 mA
0xB: 72 mA
0xC: 78 mA
0xD: 84 mA
0xE: 90 mA
0xF: 96 mA (default)</description>
	<bitRange>[15:12]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DCDC_ILIM_MIN</name>
	<description>Minimum value for automatic inductor peak current limit control.
0x0: 6 mA
0x1: 12 mA
0x2: 18 mA
0x3: 24 mA
0x4: 30 mA (default)
0x5: 36 mA
0x6: 42 mA
0x7: 48 mA
0x8: 54 mA
0x9: 60 mA
0xA: 66 mA
0xB: 72 mA
0xC: 78 mA
0xD: 84 mA
0xE: 90 mA
0xF: 96 mA</description>
	<bitRange>[11:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DCDC_OK_CLR_CNT</name>
	<description>Number of subsequent V_NOK events needed to reset VDCD_OK.
0x0: 2
0x1: 4
0x2: 8 (default)
0x3: 15</description>
	<bitRange>[7:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DCDC_TIMEOUT</name>
	<description>Switch timeout, go to next state if either switch is active for longer than this setting.
0x0: Disabled
0x1: 0.25 us
0x2: 0.50 us
0x3: 0.75 us
0x4: 1.00 us (default)
0x5: 1.25 us
0x6: 1.50 us
0x7: 1.75 us</description>
	<bitRange>[5:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DCDC_CLK_DIV</name>
	<description>Idle clock divider, sets rate at which the output is monitored when the converter is idle.
0x0: Divide by 4
0x1: Divide by 8
0x2: Divide by 16
0x3: Divide by 32</description>
	<bitRange>[2:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DCDC_ENABLE</name>
	<description>Enables hardware control of the DCDC converter.
0x0: DCDC converter disabled
0x1: DCDC converter under hardware control</description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register></registers>
</peripheral><peripheral>
	<name>DMA</name>
	<version>1.0</version>
	<description>DMA registers</description>
	<groupName>Peripheral_Registers</groupName>
	<baseAddress>0x50060200</baseAddress>
	<size>0</size>
	<addressBlock>
	<offset>0</offset>
	<size>280</size>
	<usage>registers</usage>
</addressBlock>

	<registers>
	<register>
	<name>DMA0_A_START_REG</name>
	<description>Source address register of DMA channel 0</description>
	<addressOffset>0x00000000</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0xffffffff</resetMask>
	<fields><field>
	<name>DMA0_A_START</name>
	<description>Source start address of channel 0</description>
	<bitRange>[31:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>DMA0_B_START_REG</name>
	<description>Destination address register of DMA channel 0</description>
	<addressOffset>0x00000004</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0xffffffff</resetMask>
	<fields><field>
	<name>DMA0_B_START</name>
	<description>Destination start address of channel 0</description>
	<bitRange>[31:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>DMA0_CTRL_REG</name>
	<description>Control register of DMA channel 0</description>
	<addressOffset>0x00000010</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00018000</resetValue>
	<resetMask>0x0001ffff</resetMask>
	<fields><field>
	<name>DMA_EXCLUSIVE_ACCESS</name>
	<description>0: DMA channel deasserts the bus request upon completion of the write transfer (burst or single-shot)
1: DMA channel keeps on requesting the bus upon completion of the write. This is effective only in Memory-to-Memory transfers (DREQ_MODE = 0) and results into requesting the bus continuously during the whole transfer to speed up its completion (default).</description>
	<bitRange>[16:16]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>BUS_ERROR_DETECT</name>
	<description>0: Ignores bus error response from the AHB bus, so DMA continues normally.
1: Detects the bus response and tracks any bus error that may occur during the transfer. If a bus error is detected, the channel completes the current read-write DMA cycle (either in burst or single transfers mode) and then closes the transfer, de-asserting DMA_ON bit automatically.
It is noted that the respective bus error detection status bit of DMA_INT_STATUS_REG is automatically cleared as soon as the channel is switched on again to perform a new transfer.</description>
	<bitRange>[15:15]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>BURST_MODE</name>
	<description>Enables the DMA read/write bursts according to the following configuration:
00: Bursts are disabled
01: Bursts of 4 are enabled
10: Bursts of 8 are enabled
11: Reserved</description>
	<bitRange>[14:13]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>REQ_SENSE</name>
	<description>0: DMA operates with level-sensitive peripheral requests (default)
1: DMA operates with (positive) edge-sensitive peripheral requests</description>
	<bitRange>[12:12]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DMA_INIT</name>
	<description>0: DMA performs copy A1 to B1, A2 to B2, and so forth...
1: DMA performs copy of A1 to B1, B2, and so forth...
This feature is useful for memory initialization to any value. Thus, BINC must be set to 1, while AINC is don't care, as only one fetch from A is done. This process cannot be interrupted by other DMA channels. It is also noted that DMA_INIT should not be used when DREQ_MODE = 1.</description>
	<bitRange>[11:11]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DMA_IDLE</name>
	<description>0: Blocking mode, the DMA performs a fast back-to-back copy, disabling bus access for any bus master with lower priority.
1: Interrupting mode, the DMA inserts a wait cycle after each store allowing the CPU to steal cycles or cache to perform a burst read.
If DREQ_MODE = 1 or DMA_EXCLUSIVE_ACCESS = 1, DMA_IDLE is don't care.</description>
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DMA_PRIO</name>
	<description>The priority level determines which DMA channel will be granted access for transferring data, in case more than one channels are active and request the bus at the same time. The greater the value, the higher the priority. In specific:
000: Lowest priority
111: Highest priority
If different channels with equal priority level values request the bus at the same time, an inherent priority mechanism is applied. According to this mechanism, if, for example, both the DMA0 and DMA1 channels have the same priority level, then DMA0 will first be granted access to the bus.</description>
	<bitRange>[9:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>CIRCULAR</name>
	<description>0: Normal mode. The DMA channel stops after having completed the transfer of length determined by DMAx_LEN_REG. DMA_ON automatically deasserts when the transfer is completed.
1: Circular mode (applicable only if DREQ_MODE = 1). In this mode, DMA_ON never deasserts, as the DMA channel automatically resets DMAx_IDX_REG and starts a new transfer.</description>
	<bitRange>[6:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>AINC</name>
	<description>Enable increment of source address.
0: Do not increment (source address stays the same during the transfer)
1: Increment according to the value of BW bit-field (by 1, when BW = 00; by 2, when BW = 01; by 4, when BW = 10)</description>
	<bitRange>[5:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>BINC</name>
	<description>Enable increment of destination address.
0: Do not increment (destination address stays the same during the transfer)
1: Increment according to the value of BW bit-field (by 1, when BW = 00; by 2, when BW = 01; by 4, when BW = 10)</description>
	<bitRange>[4:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DREQ_MODE</name>
	<description>0: DMA channel starts immediately
1: DMA channel must be triggered by peripheral DMA request (see also the description of DMA_REQ_MUX_REG)</description>
	<bitRange>[3:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>BW</name>
	<description>Bus transfer width:
00: 1 Byte (suggested for peripherals like UART and 8-bit SPI)
01: 2 Bytes (suggested for peripherals like I2C and 16-bit SPI)
10: 4 Bytes (suggested for Memory-to-Memory transfers)
11: Reserved</description>
	<bitRange>[2:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DMA_ON</name>
	<description>0: DMA channel is off, clocks are disabled
1: DMA channel is enabled. This bit will be automatically cleared after the completion of a transfer, if Circular mode is not enabled. In Circular mode, this bit stays set.
Note: If DMA_ON is disabled by SW while the DMA channel is active, it cannot be enabled again until the channel has completed the last on-going read-write cycle and has stopped. Thus, the software has to check that the reading of DMA0_CTRL_REG.DMA_ON returns 0 before setting again the specific bit-field.</description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>DMA0_IDX_REG</name>
	<description>Index pointer register of DMA channel 0</description>
	<addressOffset>0x00000014</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>DMA0_IDX</name>
	<description>This (read-only) register determines the data items already transferred by the DMA channel. Hence, if its value is 1, then the DMA channel has already copied one data item and it is currently performing the next copy. If its value is 2, then two items have already been copied, and so on.
When the transfer is completed (so when DMA0_CTRL_REG[DMA_ON] has been cleared) and DMA0_CTRL_REG[CIRCULAR] is not set, the register keeps its (last) value (which should be equal to DMA0_LEN_REG) and it is automatically reset to 0 upon starting a new transfer. In Circular mode, the register is automatically initialized to 0 as soon as the DMA channel starts-over again.</description>
	<bitRange>[15:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>DMA0_INT_REG</name>
	<description>Interrupt length register of DMA channel 0</description>
	<addressOffset>0x00000008</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>DMA0_INT</name>
	<description>Number of transfers until an interrupt is generated. The interrupt is generated after a transfer, if and only if DMA0_INT_REG has reached DMA0_IDX_REG and before DMA0_IDX_REG is incremented. The interrupt enable bit of this channel must be already enabled to let the channel's controller generate the interrupt (see also DMA_INT_MASK_REG and the SET/RESET interrupt registers).</description>
	<bitRange>[15:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>DMA0_LEN_REG</name>
	<description>Transfer length register of DMA channel 0</description>
	<addressOffset>0x0000000c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>DMA0_LEN</name>
	<description>DMA channel's transfer length. DMA0_LEN of value 0, 1, 2, ... results into an actual transfer length of 1, 2, 3, ...</description>
	<bitRange>[15:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>DMA1_A_START_REG</name>
	<description>Source address register of DMA channel 1</description>
	<addressOffset>0x00000020</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0xffffffff</resetMask>
	<fields><field>
	<name>DMA1_A_START</name>
	<description>Source start address of channel 1</description>
	<bitRange>[31:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>DMA1_B_START_REG</name>
	<description>Destination address register of DMA channel 1</description>
	<addressOffset>0x00000024</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0xffffffff</resetMask>
	<fields><field>
	<name>DMA1_B_START</name>
	<description>Destination start address of channel 1</description>
	<bitRange>[31:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>DMA1_CTRL_REG</name>
	<description>Control register of DMA channel 1</description>
	<addressOffset>0x00000030</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00018000</resetValue>
	<resetMask>0x0001ffff</resetMask>
	<fields><field>
	<name>DMA_EXCLUSIVE_ACCESS</name>
	<description>0: DMA channel deasserts the bus request upon completion of the write transfer (burst or single-shot)
1: DMA channel keeps on requesting the bus upon completion of the write. This is effective only in Memory-to-Memory transfers (DREQ_MODE = 0) and results into requesting the bus continuously during the whole transfer to speed up its completion (default).</description>
	<bitRange>[16:16]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>BUS_ERROR_DETECT</name>
	<description>0: Ignores bus error response from the AHB bus, so DMA continues normally.
1: Detects the bus response and tracks any bus error that may occur during the transfer. If a bus error is detected, the channel completes the current read-write DMA cycle (either in burst or single transfers mode) and then closes the transfer, de-asserting DMA_ON bit automatically.
It is noted that the respective bus error detection status bit of DMA_INT_STATUS_REG is automatically cleared as soon as the channel is switched on again to perform a new transfer.</description>
	<bitRange>[15:15]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>BURST_MODE</name>
	<description>Enables the DMA read/write bursts according to the following configuration:
00: Bursts are disabled
01: Bursts of 4 are enabled
10: Bursts of 8 are enabled
11: Reserved</description>
	<bitRange>[14:13]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>REQ_SENSE</name>
	<description>0: DMA operates with level-sensitive peripheral requests (default)
1: DMA operates with (positive) edge-sensitive peripheral requests</description>
	<bitRange>[12:12]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DMA_INIT</name>
	<description>0: DMA performs copy A1 to B1, A2 to B2, and so forth...
1: DMA performs copy of A1 to B1, B2, and so forth...
This feature is useful for memory initialization to any value. Thus, BINC must be set to 1, while AINC is don't care, as only one fetch from A is done. This process cannot be interrupted by other DMA channels. It is also noted that DMA_INIT should not be used when DREQ_MODE = 1.</description>
	<bitRange>[11:11]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DMA_IDLE</name>
	<description>0: Blocking mode, the DMA performs a fast back-to-back copy, disabling bus access for any bus master with lower priority.
1: Interrupting mode, the DMA inserts a wait cycle after each store allowing the CPU to steal cycles or cache to perform a burst read.
If DREQ_MODE = 1 or DMA_EXCLUSIVE_ACCESS = 1, DMA_IDLE is don't care.</description>
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DMA_PRIO</name>
	<description>The priority level determines which DMA channel will be granted access for transferring data, in case more than one channels are active and request the bus at the same time. The greater the value, the higher the priority. In specific:
000: Lowest priority
111: Highest priority
If different channels with equal priority level values request the bus at the same time, an inherent priority mechanism is applied. According to this mechanism, if, for example, both the DMA0 and DMA1 channels have the same priority level, then DMA0 will first be granted access to the bus.</description>
	<bitRange>[9:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>CIRCULAR</name>
	<description>0: Normal mode. The DMA channel stops after having completed the transfer of length determined by DMAx_LEN_REG. DMA_ON automatically deasserts when the transfer is completed.
1: Circular mode (applicable only if DREQ_MODE = 1). In this mode, DMA_ON never deasserts, as the DMA channel automatically resets DMAx_IDX_REG and starts a new transfer.</description>
	<bitRange>[6:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>AINC</name>
	<description>Enable increment of source address.
0: Do not increment (source address stays the same during the transfer)
1: Increment according to the value of BW bit-field (by 1, when BW = 00; by 2, when BW = 01; by 4, when BW = 10)</description>
	<bitRange>[5:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>BINC</name>
	<description>Enable increment of destination address.
0: Do not increment (destination address stays the same during the transfer)
1: Increment according to the value of BW bit-field (by 1, when BW = 00; by 2, when BW = 01; by 4, when BW = 10)</description>
	<bitRange>[4:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DREQ_MODE</name>
	<description>0: DMA channel starts immediately
1: DMA channel must be triggered by peripheral DMA request (see also the description of DMA_REQ_MUX_REG)</description>
	<bitRange>[3:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>BW</name>
	<description>Bus transfer width:
00: 1 Byte (suggested for peripherals like UART and 8-bit SPI)
01: 2 Bytes (suggested for peripherals like I2C and 16-bit SPI)
10: 4 Bytes (suggested for Memory-to-Memory transfers)
11: Reserved</description>
	<bitRange>[2:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DMA_ON</name>
	<description>0: DMA channel is off, clocks are disabled
1: DMA channel is enabled. This bit will be automatically cleared after the completion of a transfer, if Circular mode is not enabled. In Circular mode, this bit stays set.
NOTE: If DMA_ON is disabled by software while the DMA channel is active, it cannot be enabled again until the channel has completed the last on-going read-write cycle and has stopped. Thus, the software has to check that the reading of DMA1_CTRL_REG.DMA_ON returns 0 before setting again the specific bit-field.</description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>DMA1_IDX_REG</name>
	<description>Index pointer register of DMA channel 1</description>
	<addressOffset>0x00000034</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>DMA1_IDX</name>
	<description>This (read-only) register determines the data items already transferred by the DMA channel. Hence, if its value is 1, then the DMA channel has already copied one data item and it is currently performing the next copy. If its value is 2, then two items have already been copied, and so on.
When the transfer is completed (so when DMA1_CTRL_REG[DMA_ON] has been cleared) and DMA1_CTRL_REG[CIRCULAR] is not set, the register keeps its (last) value (which should be equal to DMA1_LEN_REG) and it is automatically reset to 0 upon starting a new transfer. In Circular mode, the register is automatically initialized to 0 as soon as the DMA channel starts over again.</description>
	<bitRange>[15:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>DMA1_INT_REG</name>
	<description>Interrupt length register of DMA channel 1</description>
	<addressOffset>0x00000028</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>DMA1_INT</name>
	<description>Number of transfers until an interrupt is generated. The interrupt is generated after a transfer, if and only if DMA1_INT_REG has reached DMA1_IDX_REG and before DMA1_IDX_REG is incremented. The interrupt enable bit of this channel must be already enabled, to let the channel's controller generate the interrupt (see also DMA_INT_MASK_REG and the SET/RESET interrupt registers).</description>
	<bitRange>[15:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>DMA1_LEN_REG</name>
	<description>Transfer length register of DMA channel 1</description>
	<addressOffset>0x0000002c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>DMA1_LEN</name>
	<description>DMA channel's transfer length. DMA1_LEN of value 0, 1, 2, ... results into an actual transfer length of 1, 2, 3, ...</description>
	<bitRange>[15:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>DMA2_A_START_REG</name>
	<description>Source address register of DMA channel 2</description>
	<addressOffset>0x00000040</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0xffffffff</resetMask>
	<fields><field>
	<name>DMA2_A_START</name>
	<description>Source start address of channel 2</description>
	<bitRange>[31:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>DMA2_B_START_REG</name>
	<description>Destination address register of DMA channel 2</description>
	<addressOffset>0x00000044</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0xffffffff</resetMask>
	<fields><field>
	<name>DMA2_B_START</name>
	<description>Destination start address of channel 2</description>
	<bitRange>[31:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>DMA2_CTRL_REG</name>
	<description>Control register of DMA channel 2</description>
	<addressOffset>0x00000050</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00018000</resetValue>
	<resetMask>0x0001ffff</resetMask>
	<fields><field>
	<name>DMA_EXCLUSIVE_ACCESS</name>
	<description>0: DMA channel deasserts the bus request upon completion of the write transfer (burst or single-shot)
1: DMA channel keeps on requesting the bus upon completion of the write. This is effective only in Memory-to-Memory transfers (DREQ_MODE = 0) and results into requesting the bus continuously during the whole transfer to speed up its completion (default).</description>
	<bitRange>[16:16]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>BUS_ERROR_DETECT</name>
	<description>0: Ignores bus error response from the AHB bus, so DMA continues normally.
1: Detects the bus response and tracks any bus error that may occur during the transfer. If a bus error is detected, the channel completes the current read-write DMA cycle (either in burst or single transfers mode) and then closes the transfer, de-asserting DMA_ON bit automatically.
It is noted that the respective bus error detection status bit of DMA_INT_STATUS_REG is automatically cleared as soon as the channel is switched on again to perform a new transfer.</description>
	<bitRange>[15:15]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>BURST_MODE</name>
	<description>Enables the DMA read/write bursts according to the following configuration:
00: Bursts are disabled
01: Bursts of 4 are enabled
10: Bursts of 8 are enabled
11: Reserved</description>
	<bitRange>[14:13]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>REQ_SENSE</name>
	<description>0: DMA operates with level-sensitive peripheral requests (default)
1: DMA operates with (positive) edge-sensitive peripheral requests</description>
	<bitRange>[12:12]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DMA_INIT</name>
	<description>0: DMA performs copy A1 to B1, A2 to B2, and so forth...
1: DMA performs copy of A1 to B1, B2, and so forth...
This feature is useful for memory initialization to any value. Thus, BINC must be set to 1, while AINC is don't care, as only one fetch from A is done. This process cannot be interrupted by other DMA channels. It is also noted that DMA_INIT should not be used when DREQ_MODE = 1.</description>
	<bitRange>[11:11]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DMA_IDLE</name>
	<description>0: Blocking mode, the DMA performs a fast back-to-back copy, disabling bus access for any bus master with lower priority.
1: Interrupting mode, the DMA inserts a wait cycle after each store allowing the CPU to steal cycles or cache to perform a burst read.
If DREQ_MODE = 1 or DMA_EXCLUSIVE_ACCESS = 1, DMA_IDLE is don't care.</description>
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DMA_PRIO</name>
	<description>The priority level determines which DMA channel will be granted access for transferring data, in case more than one channels are active and request the bus at the same time. The greater the value, the higher the priority. In specific:
000: Lowest priority
111: Highest priority
If different channels with equal priority level values request the bus at the same time, an inherent priority mechanism is applied. According to this mechanism, if, for example, both the DMA0 and DMA1 channels have the same priority level, then DMA0 will first be granted access to the bus.</description>
	<bitRange>[9:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>CIRCULAR</name>
	<description>0: Normal mode. The DMA channel stops after having completed the transfer of length determined by DMAx_LEN_REG. DMA_ON automatically deasserts when the transfer is completed.
1: Circular mode (applicable only if DREQ_MODE = 1). In this mode, DMA_ON never deasserts, as the DMA channel automatically resets DMAx_IDX_REG and starts a new transfer.</description>
	<bitRange>[6:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>AINC</name>
	<description>Enable increment of destination address.
0: Do not increment (destination address stays the same during the transfer)
1: Increment according to the value of BW bit-field (by 1, when BW = 00; by 2, when BW = 01; by 4, when BW = 10)</description>
	<bitRange>[5:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>BINC</name>
	<description>Enable increment of destination address
0: Do not increment
1: Increment according value of BW</description>
	<bitRange>[4:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DREQ_MODE</name>
	<description>0: DMA channel starts immediately
1: DMA channel must be triggered by peripheral DMA request (see also the description of DMA_REQ_MUX_REG)</description>
	<bitRange>[3:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>BW</name>
	<description>Bus transfer width:
00: 1 Byte (suggested for peripherals like UART and 8-bit SPI)
01: 2 Bytes (suggested for peripherals like I2C and 16-bit SPI)
10: 4 Bytes (suggested for Memory-to-Memory transfers)
11: Reserved</description>
	<bitRange>[2:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DMA_ON</name>
	<description>0: DMA channel is off, clocks are disabled
1: DMA channel is enabled. This bit will be automatically cleared after the completion of a transfer, if Circular mode is not enabled. In Circular mode, this bit stays set.
Note: If DMA_ON is disabled by software while the DMA channel is active, it cannot be enabled again until the channel has completed the last on-going read-write cycle and has stopped. Thus, the software has to check that the reading of DMA2_CTRL_REG.DMA_ON returns 0 before setting again the specific bit-field.</description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>DMA2_IDX_REG</name>
	<description>Index pointer register of DMA channel 2</description>
	<addressOffset>0x00000054</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>DMA2_IDX</name>
	<description>This (read-only) register determines the data items already transferred by the DMA channel. Hence, if its value is 1, then the DMA channel has already copied one data item and it is currently performing the next copy. If its value is 2, then two items have already been copied, and so on.
When the transfer is completed (so when DMA2_CTRL_REG[DMA_ON] has been cleared) and DMA2_CTRL_REG[CIRCULAR] is not set, the register keeps its (last) value (which should be equal to DMA2_LEN_REG) and it is automatically reset to 0 upon starting a new transfer. In Circular mode, the register is automatically initialized to 0 as soon as the DMA channel starts over again.</description>
	<bitRange>[15:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>DMA2_INT_REG</name>
	<description>Interrupt length register of DMA channel 2</description>
	<addressOffset>0x00000048</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>DMA2_INT</name>
	<description>Number of transfers until an interrupt is generated. The interrupt is generated after a transfer, if and only if DMA2_INT_REG has reached DMA2_IDX_REG and before DMA2_IDX_REG is incremented. The interrupt enable bit of this channel must be already enabled to let the channel's controller generate the interrupt (see also DMA_INT_MASK_REG and the SET/RESET interrupt registers).</description>
	<bitRange>[15:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>DMA2_LEN_REG</name>
	<description>Transfer length register of DMA channel 2</description>
	<addressOffset>0x0000004c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>DMA2_LEN</name>
	<description>DMA channel's transfer length. DMA2_LEN of value 0, 1, 2, ... results into an actual transfer length of 1, 2, 3, ...</description>
	<bitRange>[15:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>DMA3_A_START_REG</name>
	<description>Source address register of DMA channel 3</description>
	<addressOffset>0x00000060</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0xffffffff</resetMask>
	<fields><field>
	<name>DMA3_A_START</name>
	<description>Source start address of channel 3</description>
	<bitRange>[31:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>DMA3_B_START_REG</name>
	<description>Destination address register of DMA channel 3</description>
	<addressOffset>0x00000064</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0xffffffff</resetMask>
	<fields><field>
	<name>DMA3_B_START</name>
	<description>Destination start address of channel 3</description>
	<bitRange>[31:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>DMA3_CTRL_REG</name>
	<description>Control register of DMA channel 3</description>
	<addressOffset>0x00000070</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00018000</resetValue>
	<resetMask>0x0001ffff</resetMask>
	<fields><field>
	<name>DMA_EXCLUSIVE_ACCESS</name>
	<description>0: DMA channel deasserts the bus request upon completion of the write transfer (burst or single-shot)
1: DMA channel keeps on requesting the bus upon completion of the write. This is effective only in Memory-to-Memory transfers (DREQ_MODE = 0) and results into requesting the bus continuously during the whole transfer to speed up its completion (default).</description>
	<bitRange>[16:16]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>BUS_ERROR_DETECT</name>
	<description>0: Ignores bus error response from the AHB bus, so DMA continues normally.
1: Detects the bus response and tracks any bus error may occur during the transfer. If a bus error is detected, the channel completes the current read-write DMA cycle (either in burst or single transfers mode) and then closes the transfer, de-asserting DMA_ON bit automatically.
It is noted that the respective bus error detection status bit of DMA_INT_STATUS_REG is automatically cleared as soon as the channel is switched on again to perform a new transfer.</description>
	<bitRange>[15:15]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>BURST_MODE</name>
	<description>Enables the DMA read/write bursts according to the following configuration:
00: Bursts are disabled
01: Bursts of 4 are enabled
10: Bursts of 8 are enabled
11: Reserved</description>
	<bitRange>[14:13]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>REQ_SENSE</name>
	<description>0: DMA operates with level-sensitive peripheral requests (default)
1: DMA operates with (positive) edge-sensitive peripheral requests</description>
	<bitRange>[12:12]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DMA_INIT</name>
	<description>0: DMA performs copy A1 to B1, A2 to B2, and so forth...
1: DMA performs copy of A1 to B1, B2, and so forth...
This feature is useful for memory initialization to any value. Thus, BINC must be set to 1, while AINC is don't care, as only one fetch from A is done. This process cannot be interrupted by other DMA channels. It is also noted that DMA_INIT should not be used when DREQ_MODE = 1.</description>
	<bitRange>[11:11]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DMA_IDLE</name>
	<description>0: Blocking mode, the DMA performs a fast back-to-back copy, disabling bus access for any bus master with lower priority.
1: Interrupting mode, the DMA inserts a wait cycle after each store allowing the CPU to steal cycles or cache to perform a burst read.
If DREQ_MODE = 1 or DMA_EXCLUSIVE_ACCESS = 1, DMA_IDLE is don't care.</description>
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DMA_PRIO</name>
	<description>The priority level determines which DMA channel will be granted access for transferring data, in case more than one channels are active and request the bus at the same time. The greater the value, the higher the priority. In specific:
000 = lowest priority
111 = highest priority
If different channels with equal priority level values request the bus at the same time, an inherent priority mechanism is applied. According to this mechanism, if, for example, both the DMA0 and DMA1 channels have the same priority level, then DMA0 will first be granted access to the bus.</description>
	<bitRange>[9:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>CIRCULAR</name>
	<description>0: Normal mode. The DMA channel stops after having completed the transfer of length determined by DMAx_LEN_REG. DMA_ON automatically deasserts when the transfer is completed.
1: Circular mode (applicable only if DREQ_MODE = 1). In this mode, DMA_ON never deasserts, as the DMA channel automatically resets DMAx_IDX_REG and starts a new transfer.</description>
	<bitRange>[6:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>AINC</name>
	<description>Enable increment of source address.
0: Do not increment (source address stays the same during the transfer)
1: Increment according to the value of BW bit-field (by 1, when BW = 00; by 2, when BW = 01; by 4, when BW = 10)</description>
	<bitRange>[5:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>BINC</name>
	<description>Enable increment of destination address.
0: Do not increment (destination address stays the same during the transfer)
1: Increment according to the value of BW bit-field (by 1, when BW = 00; by 2, when BW = 01; by 4, when BW = 10)</description>
	<bitRange>[4:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DREQ_MODE</name>
	<description>0: DMA channel starts immediately
1: DMA channel must be triggered by peripheral DMA request (see also the description of DMA_REQ_MUX_REG)</description>
	<bitRange>[3:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>BW</name>
	<description>Bus transfer width:
00: 1 Byte (suggested for peripherals like UART and 8-bit SPI)
01: 2 Bytes (suggested for peripherals like I2C and 16-bit SPI)
10: 4 Bytes (suggested for Memory-to-Memory transfers)
11: Reserved</description>
	<bitRange>[2:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DMA_ON</name>
	<description>0: DMA channel is off, clocks are disabled
1: DMA channel is enabled. This bit will be automatically cleared after the completion of a transfer, if Circular mode is not enabled. In Circular mode, this bit stays set.
Note: If DMA_ON is disabled by software while the DMA channel is active, it cannot be enabled again until the channel has completed the last on-going read-write cycle and has stopped. Thus, the software has to check that the reading of DMA3_CTRL_REG.DMA_ON returns 0 before setting again the specific bit-field.</description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>DMA3_IDX_REG</name>
	<description>Index pointer register of DMA channel 3</description>
	<addressOffset>0x00000074</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>DMA3_IDX</name>
	<description>This (read-only) register determines the data items already transferred by the DMA channel. Hence, if its value is 1, then the DMA channel has already copied one data item and it is currently performing the next copy. If its value is 2, then two items have already been copied, and so on.
When the transfer is completed (so when DMA3_CTRL_REG[DMA_ON] has been cleared) and DMA3_CTRL_REG[CIRCULAR] is not set, the register keeps its (last) value (which should be equal to DMA3_LEN_REG) and it is automatically reset to 0 upon starting a new transfer. In Circular mode, the register is automatically initialized to 0 as soon as the DMA channel starts over again.</description>
	<bitRange>[15:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>DMA3_INT_REG</name>
	<description>Interrupt length register of DMA channel 3</description>
	<addressOffset>0x00000068</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>DMA3_INT</name>
	<description>Number of transfers until an interrupt is generated. The interrupt is generated after a transfer, if and only if DMA3_INT_REG has reached DMA3_IDX_REG and before DMA3_IDX_REG is incremented. The interrupt enable bit of this channel must be already enabled, to let the channel's controller generate the interrupt (see also DMA_INT_MASK_REG and the SET/RESET interrupt registers).</description>
	<bitRange>[15:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>DMA3_LEN_REG</name>
	<description>Transfer length register of DMA channel 3</description>
	<addressOffset>0x0000006c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>DMA3_LEN</name>
	<description>DMA channel's transfer length. DMA3_LEN of value 0, 1, 2, ... results into an actual transfer length of 1, 2, 3, ...</description>
	<bitRange>[15:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>DMA4_A_START_REG</name>
	<description>Source address register of DMA channel 4</description>
	<addressOffset>0x00000080</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0xffffffff</resetMask>
	<fields><field>
	<name>DMA4_A_START</name>
	<description>Source start address of channel 4</description>
	<bitRange>[31:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>DMA4_B_START_REG</name>
	<description>Destination address register of DMA channel 4</description>
	<addressOffset>0x00000084</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0xffffffff</resetMask>
	<fields><field>
	<name>DMA4_B_START</name>
	<description>Destination start address of channel 4</description>
	<bitRange>[31:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>DMA4_CTRL_REG</name>
	<description>Control register of DMA channel 4</description>
	<addressOffset>0x00000090</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00018000</resetValue>
	<resetMask>0x0001ffff</resetMask>
	<fields><field>
	<name>DMA_EXCLUSIVE_ACCESS</name>
	<description>0: DMA channel deasserts the bus request upon completion of the write transfer (burst or single-shot)
1: DMA channel keeps on requesting the bus upon completion of the write. This is effective only in Memory-to-Memory transfers (DREQ_MODE = 0) and results into requesting the bus continuously during the whole transfer to speed up its completion (default).</description>
	<bitRange>[16:16]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>BUS_ERROR_DETECT</name>
	<description>0: Ignores bus error response from the AHB bus, so DMA continues normally.
1: Detects the bus response and tracks any bus error that may occur during the transfer. If a bus error is detected, the channel completes the current read-write DMA cycle (either in burst or single transfers mode) and then closes the transfer, de-asserting DMA_ON bit automatically.
It is noted that the respective bus error detection status bit of DMA_INT_STATUS_REG is automatically cleared as soon as the channel is switched on again to perform a new transfer.</description>
	<bitRange>[15:15]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>BURST_MODE</name>
	<description>Enables the DMA read/write bursts according to the following configuration:
00: Bursts are disabled
01: Bursts of 4 are enabled
10: Bursts of 8 are enabled
11: Reserved</description>
	<bitRange>[14:13]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>REQ_SENSE</name>
	<description>0: DMA operates with level-sensitive peripheral requests (default)
1: DMA operates with (positive) edge-sensitive peripheral requests</description>
	<bitRange>[12:12]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DMA_INIT</name>
	<description>0: DMA performs copy A1 to B1, A2 to B2, and so forth...
1: DMA performs copy of A1 to B1, B2, and so forth...
This feature is useful for memory initialization to any value. Thus, BINC must be set to 1, while AINC is don't care, as only one fetch from A is done. This process cannot be interrupted by other DMA channels. It is also noted that DMA_INIT should not be used when DREQ_MODE = 1.</description>
	<bitRange>[11:11]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DMA_IDLE</name>
	<description>0: Blocking mode, the DMA performs a fast back-to-back copy, disabling bus access for any bus master with lower priority.
1: Interrupting mode, the DMA inserts a wait cycle after each store allowing the CPU to steal cycles or cache to perform a burst read.
If DREQ_MODE = 1 or DMA_EXCLUSIVE_ACCESS = 1, DMA_IDLE is don't care.</description>
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DMA_PRIO</name>
	<description>The priority level determines which DMA channel will be granted access for transferring data, in case more than one channels are active and request the bus at the same time. The greater the value, the higher the priority. In specific:
000: Lowest priority
111: Highest priority
If different channels with equal priority level values request the bus at the same time, an inherent priority mechanism is applied. According to this mechanism, if, for example, both the DMA0 and DMA1 channels have the same priority level, then DMA0 will first be granted access to the bus.</description>
	<bitRange>[9:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>CIRCULAR</name>
	<description>0: Normal mode. The DMA channel stops after having completed the transfer of length determined by DMAx_LEN_REG. DMA_ON automatically deasserts when the transfer is completed.
1: Circular mode (applicable only if DREQ_MODE = 1). In this mode, DMA_ON never deasserts, as the DMA channel automatically resets DMAx_IDX_REG and starts a new transfer.</description>
	<bitRange>[6:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>AINC</name>
	<description>Enable increment of source address.
0: Do not increment (source address stays the same during the transfer)
1: Increment according to the value of BW bit-field (by 1, when BW = 00; by 2, when BW = 01; by 4, when BW = 10)</description>
	<bitRange>[5:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>BINC</name>
	<description>Enable increment of destination address.
0: Do not increment (destination address stays the same during the transfer)
1: Increment according to the value of BW bit-field (by 1, when BW = 00; by 2, when BW = 01; by 4, when BW = 10)</description>
	<bitRange>[4:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DREQ_MODE</name>
	<description>0: DMA channel starts immediately
1: DMA channel must be triggered by peripheral DMA request (see also the description of DMA_REQ_MUX_REG)</description>
	<bitRange>[3:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>BW</name>
	<description>Bus transfer width:
00: 1 Byte (suggested for peripherals like UART and 8-bit SPI)
01: 2 Bytes (suggested for peripherals like I2C and 16-bit SPI)
10: 4 Bytes (suggested for Memory-to-Memory transfers)
11: Reserved</description>
	<bitRange>[2:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DMA_ON</name>
	<description>0: DMA channel is off, clocks are disabled
1: DMA channel is enabled. This bit will be automatically cleared after the completion of a transfer, if Circular mode is not enabled. In Circular mode, this bit stays set.
Note: If DMA_ON is disabled by software while the DMA channel is active, it cannot be enabled again until the channel has completed the last on-going read-write cycle and has stopped. Thus, the software has to check that the reading of DMA4_CTRL_REG.DMA_ON returns 0 before setting again the specific bit-field.</description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>DMA4_IDX_REG</name>
	<description>Index pointer register of DMA channel 4</description>
	<addressOffset>0x00000094</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>DMA4_IDX</name>
	<description>This (read-only) register determines the data items already transferred by the DMA channel. Hence, if its value is 1, then the DMA channel has already copied one data item and it is currently performing the next copy. If its value is 2, then two items have already been copied, and so on.
When the transfer is completed (so when DMA4_CTRL_REG[DMA_ON] has been cleared) and DMA4_CTRL_REG[CIRCULAR] is not set, the register keeps its (last) value (which should be equal to DMA4_LEN_REG) and it is automatically reset to 0 upon starting a new transfer. In Circular mode, the register is automatically initialized to 0 as soon as the DMA channel starts over again.</description>
	<bitRange>[15:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>DMA4_INT_REG</name>
	<description>Interrupt length register of DMA channel 4</description>
	<addressOffset>0x00000088</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>DMA4_INT</name>
	<description>Number of transfers until an interrupt is generated. The interrupt is generated after a transfer, if and only if DMA4_INT_REG has reached DMA4_IDX_REG and before DMA4_IDX_REG is incremented. The interrupt enable bit of this channel must be already enabled to let the channel's controller generate the interrupt (see also DMA_INT_MASK_REG and the SET/RESET interrupt registers).</description>
	<bitRange>[15:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>DMA4_LEN_REG</name>
	<description>Transfer length register of DMA channel 4</description>
	<addressOffset>0x0000008c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>DMA4_LEN</name>
	<description>DMA channel's transfer length. DMA4_LEN of value 0, 1, 2, ... results into an actual transfer length of 1, 2, 3, ...</description>
	<bitRange>[15:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>DMA5_A_START_REG</name>
	<description>Source address register of DMA channel 5</description>
	<addressOffset>0x000000a0</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0xffffffff</resetMask>
	<fields><field>
	<name>DMA5_A_START</name>
	<description>Source start address of channel 5</description>
	<bitRange>[31:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>DMA5_B_START_REG</name>
	<description>Destination address register of DMA channel 5</description>
	<addressOffset>0x000000a4</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0xffffffff</resetMask>
	<fields><field>
	<name>DMA5_B_START</name>
	<description>Destination start address of channel 5</description>
	<bitRange>[31:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>DMA5_CTRL_REG</name>
	<description>Control register of DMA channel 5</description>
	<addressOffset>0x000000b0</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00018000</resetValue>
	<resetMask>0x0001ffff</resetMask>
	<fields><field>
	<name>DMA_EXCLUSIVE_ACCESS</name>
	<description>0: DMA channel deasserts the bus request upon completion of the write transfer (burst or single-shot)
1: DMA channel keeps on requesting the bus upon completion of the write. This is effective only in Memory-to-Memory transfers (DREQ_MODE = 0) and results into requesting the bus continuously during the whole transfer to speed up its completion (default).</description>
	<bitRange>[16:16]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>BUS_ERROR_DETECT</name>
	<description>0: Ignores bus error response from the AHB bus, so DMA continues normally.
1: Detects the bus response and tracks any bus error that may occur during the transfer. If a bus error is detected, the channel completes the current read-write DMA cycle (either in burst or single transfers mode) and then closes the transfer, de-asserting DMA_ON bit automatically.
It is noted that the respective bus error detection status bit of DMA_INT_STATUS_REG is automatically cleared as soon as the channel is switched on again to perform a new transfer.
NOTE: This bit-field is overruled to 1 when channel 5 is configured as trusted channel (in Secure Boot mode).</description>
	<bitRange>[15:15]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>BURST_MODE</name>
	<description>Enables the DMA read/write bursts according to the following configuration:
00: Bursts are disabled
01: Bursts of 4 are enabled
10: Bursts of 8 are enabled
11: Reserved</description>
	<bitRange>[14:13]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>REQ_SENSE</name>
	<description>0: DMA operates with level-sensitive peripheral requests (default)
1: DMA operates with (positive) edge-sensitive peripheral requests</description>
	<bitRange>[12:12]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DMA_INIT</name>
	<description>0: DMA performs copy A1 to B1, A2 to B2, and so forth...
1: DMA performs copy of A1 to B1, B2, and so forth...
This feature is useful for memory initialization to any value. Thus, BINC must be set to 1, while AINC is don't care, as only one fetch from A is done. This process cannot be interrupted by other DMA channels. It is also noted that DMA_INIT should not be used when DREQ_MODE = 1.
NOTE: This bit-field is overruled to 0 when channel 5 is configured as trusted channel (in Secure Boot mode).</description>
	<bitRange>[11:11]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DMA_IDLE</name>
	<description>0: Blocking mode, the DMA performs a fast back-to-back copy, disabling bus access for any bus master with lower priority.
1: Interrupting mode, the DMA inserts a wait cycle after each store allowing the CPU to steal cycles or cache to perform a burst read.
If DREQ_MODE = 1 or DMA_EXCLUSIVE_ACCESS = 1, DMA_IDLE is don't care.
NOTE: This bit-field is overruled to 0 when the DMA channel 5 is configured as trusted channel (in Secure Boot mode).</description>
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DMA_PRIO</name>
	<description>The priority level determines which DMA channel will be granted access for transferring data, in case more than one channels are active and request the bus at the same time. The greater the value, the higher the priority. In specific:
000: Lowest priority
111: Highest priority
If different channels with equal priority level values request the bus at the same time, an inherent priority mechanism is applied. According to this mechanism, if, for example, both the DMA0 and DMA1 channels have the same priority level, then DMA0 will first be granted access to the bus.</description>
	<bitRange>[9:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>CIRCULAR</name>
	<description>0: Normal mode. The DMA channel stops after having completed the transfer of length determined by DMAx_LEN_REG. DMA_ON automatically deasserts when the transfer is completed.
1: Circular mode (applicable only if DREQ_MODE = 1). In this mode, DMA_ON never deasserts, as the DMA channel automatically resets DMAx_IDX_REG and starts a new transfer.</description>
	<bitRange>[6:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>AINC</name>
	<description>Enable increment of source address.
0: Do not increment (source address stays the same during the transfer)
1: Increment according to the value of BW bit-field (by 1, when BW = 00; by 2, when BW = 01; by 4, when BW = 10)</description>
	<bitRange>[5:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>BINC</name>
	<description>Enable increment of destination address.
0: Do not increment (destination address stays the same during the transfer)
1: Increment according to the value of BW bit-field (by 1, when BW = 00; by 2, when BW = 01; by 4, when BW = 10)</description>
	<bitRange>[4:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DREQ_MODE</name>
	<description>0: DMA channel starts immediately
1: DMA channel must be triggered by peripheral DMA request (see also the description of DMA_REQ_MUX_REG)
Note: This bit-field is overruled to 0 when channel 5 is configured as trusted channel (in Secure Boot mode).</description>
	<bitRange>[3:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>BW</name>
	<description>Bus transfer width:
00: 1 Byte (suggested for peripherals like UART and 8-bit SPI)
01: 2 Bytes (suggested for peripherals like I2C and 16-bit SPI)
10: 4 Bytes (suggested for Memory-to-Memory transfers)
11: Reserved</description>
	<bitRange>[2:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DMA_ON</name>
	<description>0: DMA channel is off, clocks are disabled
1: DMA channel is enabled. This bit will be automatically cleared after the completion of a transfer, if Circular mode is not enabled. In Circular mode, this bit stays set.
Note: If DMA_ON is disabled by software while the DMA channel is active, it cannot be enabled again until the channel has completed the last on-going read-write cycle and has stopped. Thus, the software has to check that the reading of DMA5_CTRL_REG.DMA_ON returns 0 before setting again the specific bit-field.</description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>DMA5_IDX_REG</name>
	<description>Index pointer register of DMA channel 5</description>
	<addressOffset>0x000000b4</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>DMA5_IDX</name>
	<description>This (read-only) register determines the data items already transferred by the DMA channel. Hence, if its value is 1, then the DMA channel has already copied one data item and it is currently performing the next copy. If its value is 2, then two items have already been copied, and so on.
When the transfer is completed (so when DMA5_CTRL_REG[DMA_ON] has been cleared) and DMA5_CTRL_REG[CIRCULAR] is not set, the register keeps its (last) value (which should be equal to DMA5_LEN_REG) and it is automatically reset to 0 upon starting a new transfer. In Circular mode, the register is automatically initialized to 0 as soon as the DMA channel starts over again.</description>
	<bitRange>[15:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>DMA5_INT_REG</name>
	<description>Interrupt length register of DMA channel 5</description>
	<addressOffset>0x000000a8</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>DMA5_INT</name>
	<description>Number of transfers until an interrupt is generated. The interrupt is generated after a transfer, if and only if DMA5_INT_REG has reached DMA5_IDX_REG and before DMA5_IDX_REG is incremented. The interrupt enable bit of this channel must be already enabled, to let the channel's controller generate the interrupt (see also DMA_INT_MASK_REG and the SET/RESET interrupt registers).</description>
	<bitRange>[15:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>DMA5_LEN_REG</name>
	<description>Transfer length register of DMA channel 5</description>
	<addressOffset>0x000000ac</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>DMA5_LEN</name>
	<description>DMA channel's transfer length. DMA5_LEN of value 0, 1, 2, ... results into an actual transfer length of 1, 2, 3, ...</description>
	<bitRange>[15:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>DMA_CLEAR_INT_REG</name>
	<description>DMA Interrupt clear register</description>
	<addressOffset>0x00000108</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000003f</resetMask>
	<fields><field>
	<name>DMA_RST_IRQ_CH5</name>
	<description>Writing 1 will reset the status bit of DMA_INT_STATUS_REG for channel 5; writing 0 will have no effect</description>
	<bitRange>[5:5]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>DMA_RST_IRQ_CH4</name>
	<description>Writing 1 will reset the status bit of DMA_INT_STATUS_REG for channel 4; writing 0 will have no effect</description>
	<bitRange>[4:4]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>DMA_RST_IRQ_CH3</name>
	<description>Writing 1 will reset the status bit of DMA_INT_STATUS_REG for channel 3; writing 0 will have no effect</description>
	<bitRange>[3:3]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>DMA_RST_IRQ_CH2</name>
	<description>Writing 1 will reset the status bit of DMA_INT_STATUS_REG for channel 2; writing 0 will have no effect</description>
	<bitRange>[2:2]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>DMA_RST_IRQ_CH1</name>
	<description>Writing 1 will reset the status bit of DMA_INT_STATUS_REG for channel 1; writing 0 will have no effect</description>
	<bitRange>[1:1]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>DMA_RST_IRQ_CH0</name>
	<description>Writing 1 will reset the status bit of DMA_INT_STATUS_REG for channel 0; writing 0 will have no effect</description>
	<bitRange>[0:0]</bitRange>
	<access>write-only</access>
	</field></fields>
</register><register>
	<name>DMA_INT_MASK_REG</name>
	<description>DMA Interrupt mask register</description>
	<addressOffset>0x0000010c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000003f</resetMask>
	<fields><field>
	<name>DMA_IRQ_ENABLE5</name>
	<description>0: disable interrupts on channel 5
1: enable interrupts on channel 5</description>
	<bitRange>[5:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DMA_IRQ_ENABLE4</name>
	<description>0: disable interrupts on channel 4
1: enable interrupts on channel 4</description>
	<bitRange>[4:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DMA_IRQ_ENABLE3</name>
	<description>0: disable interrupts on channel 3
1: enable interrupts on channel 3</description>
	<bitRange>[3:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DMA_IRQ_ENABLE2</name>
	<description>0: disable interrupts on channel 2
1: enable interrupts on channel 2</description>
	<bitRange>[2:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DMA_IRQ_ENABLE1</name>
	<description>0: disable interrupts on channel 1
1: enable interrupts on channel 1</description>
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DMA_IRQ_ENABLE0</name>
	<description>0: disable interrupts on channel 0
1: enable interrupts on channel 0</description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>DMA_INT_STATUS_REG</name>
	<description>DMA Interrupt status register</description>
	<addressOffset>0x00000104</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00003fff</resetMask>
	<fields><field>
	<name>DMA_BUS_ERR5</name>
	<description>0: No bus error response is detected for channel 5
1: Bus error response detected for channel 5
Note: This bit-field is auto-clear and it is initialized to 0 as soon as a new transfer is started. It is also noted that when channel 5 is configured as &quot;trusted&quot; (in Secure Boot mode), this bit-field is overruled to 0 masking the bus error status reported to the user.</description>
	<bitRange>[13:13]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>DMA_BUS_ERR4</name>
	<description>0: No bus error response is detected for channel 4
1: Bus error response detected for channel 4
Note: This bit-field is auto-clear and it is initialized to 0 as soon as a new transfer is started.</description>
	<bitRange>[12:12]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>DMA_BUS_ERR3</name>
	<description>0: No bus error response is detected for channel 3
1: Bus error response detected for channel 3
Note: This bit-field is auto-clear and it is initialized to 0 as soon as a new transfer is started.</description>
	<bitRange>[11:11]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>DMA_BUS_ERR2</name>
	<description>0: No bus error response is detected for channel 2
1: Bus error response detected for channel 2
Note: This bit-field is auto-clear and it is initialized to 0 as soon as a new transfer is started.</description>
	<bitRange>[10:10]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>DMA_BUS_ERR1</name>
	<description>0: No bus error response is detected for channel 1
1: Bus error response detected for channel 1
Note: This bit-field is auto-clear and it is initialized to 0 as soon as a new transfer is started.</description>
	<bitRange>[9:9]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>DMA_BUS_ERR0</name>
	<description>0: No bus error response is detected for channel 0
1: Bus error response detected for channel 0
Note: This bit-field is auto-clear and it is initialized to 0 as soon as a new transfer is started.</description>
	<bitRange>[8:8]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>DMA_IRQ_CH5</name>
	<description>0: IRQ on channel 5 is not set
1: IRQ on channel 5 is set</description>
	<bitRange>[5:5]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>DMA_IRQ_CH4</name>
	<description>0: IRQ on channel 4 is not set
1: IRQ on channel 4 is set</description>
	<bitRange>[4:4]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>DMA_IRQ_CH3</name>
	<description>0: IRQ on channel 3 is not set
1: IRQ on channel 3 is set</description>
	<bitRange>[3:3]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>DMA_IRQ_CH2</name>
	<description>0: IRQ on channel 2 is not set
1: IRQ on channel 2 is set</description>
	<bitRange>[2:2]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>DMA_IRQ_CH1</name>
	<description>0: IRQ on channel 1 is not set
1: IRQ on channel 1 is set</description>
	<bitRange>[1:1]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>DMA_IRQ_CH0</name>
	<description>0: IRQ on channel 0 is not set
1: IRQ on channel 0 is set</description>
	<bitRange>[0:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>DMA_REQ_MUX_REG</name>
	<description>DMA channels peripherals mapping register</description>
	<addressOffset>0x00000100</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000fff</resetValue>
	<resetMask>0x00000fff</resetMask>
	<fields><field>
	<name>DMA45_SEL</name>
	<description>Select which combination of peripherals are mapped on the DMA channels. The peripherals are mapped as pairs on two channels.
The first DMA request is mapped on channel 4 and the second on channel 5. Please refer to the description of DMA01_SEL bit-field for the exact peripherals' mapping.
NOTE: When channel 5 is configured as secure channel, it cannot support any peripheral requests, since DREQ_MODE is disabled automatically, overruling the corresponding bit-field of DMA5_CTRL_REG.</description>
	<bitRange>[11:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DMA23_SEL</name>
	<description>Select which combination of peripherals are mapped on the DMA channels. The peripherals are mapped as pairs on two channels.
The first DMA request is mapped on channel 2 and the second on channel 3. Please refer to the description of DMA01_SEL bit-field for the exact peripherals' mapping.</description>
	<bitRange>[7:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DMA01_SEL</name>
	<description>Select which combination of peripherals are mapped on the DMA channels. The peripherals are mapped as pairs on two channels.
The first DMA request is mapped on channel 0 and the second on channel 1 and the peripherals supported are listed below. Note that in the following list, the &quot;rx&quot; implies a Peripheral-to-Memory transfer and the &quot;tx&quot; a Memory-to-Peripheral transfer.
0x0: SPI_rx/SPI_tx
0x1: UART_rx/UART_tx
0x2: UART2_rx/UART2_tx
0x3: I2C_rx/I2C_tx
0x4: PCM/PCM
0x5: SRC1_rx/SRC1_rx
0x6: SRC1_tx/SRC1_tx
0x7: SRC2_rx/SRC2_rx
0x8: SRC2_tx/SRC2_tx
0x9: SRC1_rx/SRC2_tx
0xA: SRC2_rx/SRC1_tx
0xB: SRC1_rx/SRC1_tx
0xC: SRC2_rx/SRC2_tx
0xD: GP_ADC/None
0xE: SDADC/Flash Controller (tx)
0xF: None
Note: If any of the two available peripheral selector fields (DMA01_SEL, DMA23_SEL) have the same value, the lesser significant selector has higher priority and will control the DMA acknowledge signal driven to the selected peripheral. Hence, if DMA01_SEL = DMA23_SEL, the channels 0 and 1 will provide the Rx and Tx DMA acknowledge signals for the selected peripheral.
Consequently, it is suggested to assign the intended peripheral value to a unique selector field. Exceptions are SRC1 and SRC2, for which the mapping of the same peripheral option to more than one channel pairs may be intended (for example, for stereo mode and values 0xB and 0xC, translating to SRC_rx/SRC_tx and SRC2_rx/SRC2_tx).</description>
	<bitRange>[3:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>DMA_RESET_INT_MASK_REG</name>
	<description>DMA Reset Interrupt mask register</description>
	<addressOffset>0x00000114</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000003f</resetMask>
	<fields><field>
	<name>DMA_RESET_IRQ_ENABLE5</name>
	<description>Writing 1 will disable the IRQs in the DMA channel 5, writing 0 has no effect. Reading always returns 0.</description>
	<bitRange>[5:5]</bitRange>
	<access>read-writeOnce</access>
	</field><field>
	<name>DMA_RESET_IRQ_ENABLE4</name>
	<description>Writing 1 will disable the IRQs in the DMA channel 4, writing 0 has no effect. Reading always returns 0.</description>
	<bitRange>[4:4]</bitRange>
	<access>read-writeOnce</access>
	</field><field>
	<name>DMA_RESET_IRQ_ENABLE3</name>
	<description>Writing 1 will disable the IRQs in the DMA channel 3, writing 0 has no effect. Reading always returns 0.</description>
	<bitRange>[3:3]</bitRange>
	<access>read-writeOnce</access>
	</field><field>
	<name>DMA_RESET_IRQ_ENABLE2</name>
	<description>Writing 1 will disable the IRQs in the DMA channel 2, writing 0 has no effect. Reading always returns 0.</description>
	<bitRange>[2:2]</bitRange>
	<access>read-writeOnce</access>
	</field><field>
	<name>DMA_RESET_IRQ_ENABLE1</name>
	<description>Writing 1 will disable the IRQs in the DMA channel 1, writing 0 has no effect. Reading always returns 0.</description>
	<bitRange>[1:1]</bitRange>
	<access>read-writeOnce</access>
	</field><field>
	<name>DMA_RESET_IRQ_ENABLE0</name>
	<description>Writing 1 will disable the IRQs in the DMA channel 0, writing 0 has no effect. Reading always returns 0.</description>
	<bitRange>[0:0]</bitRange>
	<access>read-writeOnce</access>
	</field></fields>
</register><register>
	<name>DMA_SET_INT_MASK_REG</name>
	<description>DMA Set Interrupt mask register</description>
	<addressOffset>0x00000110</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000003f</resetMask>
	<fields><field>
	<name>DMA_SET_IRQ_ENABLE5</name>
	<description>Writing 1 will enable the IRQs in the DMA channel 5, writing 0 has no effect. Reading always returns 0.</description>
	<bitRange>[5:5]</bitRange>
	<access>read-writeOnce</access>
	</field><field>
	<name>DMA_SET_IRQ_ENABLE4</name>
	<description>Writing 1 will enable the IRQs in the DMA channel 4, writing 0 has no effect. Reading always returns 0.</description>
	<bitRange>[4:4]</bitRange>
	<access>read-writeOnce</access>
	</field><field>
	<name>DMA_SET_IRQ_ENABLE3</name>
	<description>Writing 1 will enable the IRQs in the DMA channel 3, writing 0 has no effect. Reading always returns 0.</description>
	<bitRange>[3:3]</bitRange>
	<access>read-writeOnce</access>
	</field><field>
	<name>DMA_SET_IRQ_ENABLE2</name>
	<description>Writing 1 will enable the IRQs in the DMA channel 2, writing 0 has no effect. Reading always returns 0.</description>
	<bitRange>[2:2]</bitRange>
	<access>read-writeOnce</access>
	</field><field>
	<name>DMA_SET_IRQ_ENABLE1</name>
	<description>Writing 1 will enable the IRQs in the DMA channel 1, writing 0 has no effect. Reading always returns 0..</description>
	<bitRange>[1:1]</bitRange>
	<access>read-writeOnce</access>
	</field><field>
	<name>DMA_SET_IRQ_ENABLE0</name>
	<description>Writing 1 will enable the IRQs in the DMA channel 0, writing 0 has no effect. Reading always returns 0.</description>
	<bitRange>[0:0]</bitRange>
	<access>read-writeOnce</access>
	</field></fields>
</register></registers>
</peripheral><peripheral>
	<name>DW</name>
	<version>1.0</version>
	<description>DW registers</description>
	<groupName>Peripheral_Registers</groupName>
	<baseAddress>0x30020000</baseAddress>
	<size>0</size>
	<addressBlock>
	<offset>0</offset>
	<size>148</size>
	<usage>registers</usage>
</addressBlock>

	<registers>
	<register>
	<name>AHB_DMA_CCLM1_REG</name>
	<description>RFTP Master clock tokens (AHB DMA layer only)</description>
	<addressOffset>0x00000054</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x0000000f</resetValue>
	<resetMask>0xffffffff</resetMask>
	<fields><field>
	<name>AHB_DMA_CCLM</name>
	<description>Number of tokens (counted in AHB clock cycles) that a master can use on the bus before it has to arbitrate on a bus master with low priority and having tokens. Masters with tokens remaining have priority over masters that have used all of their tokens. User should configure all the token values ensuring that the sum does not exceed the total allocated number of tokens. If a value of zero is configured, then the bus is deemed to have infinite tokens and will always operate in the upper-tier of arbitration.</description>
	<bitRange>[15:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>AHB_DMA_CCLM2_REG</name>
	<description>GPDMA Master clock tokens (AHB DMA layer only)</description>
	<addressOffset>0x00000058</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x0000000f</resetValue>
	<resetMask>0xffffffff</resetMask>
	<fields><field>
	<name>AHB_DMA_CCLM</name>
	<description>See AHB_DMA_CCLM1_REG</description>
	<bitRange>[15:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>AHB_DMA_CCLM3_REG</name>
	<description>CRYPTO-DMA Master clock tokens (AHB DMA layer only)</description>
	<addressOffset>0x0000005c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x0000000f</resetValue>
	<resetMask>0xffffffff</resetMask>
	<fields><field>
	<name>AHB_DMA_CCLM</name>
	<description>AHB_DMA_CCLM1_REG</description>
	<bitRange>[15:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>AHB_DMA_CCLM4_REG</name>
	<description>DRA Master clock tokens (AHB DMA layer only)</description>
	<addressOffset>0x00000060</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x0000000f</resetValue>
	<resetMask>0xffffffff</resetMask>
	<fields><field>
	<name>AHB_DMA_CCLM</name>
	<description>AHB_DMA_CCLM1_REG</description>
	<bitRange>[15:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>AHB_DMA_DFLT_MASTER_REG</name>
	<description>Default master ID number (AHB DMA layer only)</description>
	<addressOffset>0x00000048</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0xffffffff</resetMask>
	<fields><field>
	<name>AHB_DMA_DFLT_MASTER</name>
	<description>Default master ID number register. The default master is the master that is granted by the bus when no master has requested ownership.
0: Dummy master
1: RFPT
2: GEN-DMA
3: CRYPTO-DMA
4: DRA</description>
	<bitRange>[3:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>AHB_DMA_PL1_REG</name>
	<description>AHB-DMA layer priority level for RFTP (AHB DMA layer only)</description>
	<addressOffset>0x00000000</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x0000000f</resetValue>
	<resetMask>0xffffffff</resetMask>
	<fields><field>
	<name>AHB_DMA_PL1</name>
	<description>Arbitration priority for master RFPT. 0: lowest, 15: highest.</description>
	<bitRange>[3:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>AHB_DMA_PL2_REG</name>
	<description>AHB-DMA layer priority level for GPDMA (AHB DMA layer only)</description>
	<addressOffset>0x00000004</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x0000000e</resetValue>
	<resetMask>0xffffffff</resetMask>
	<fields><field>
	<name>AHB_DMA_PL2</name>
	<description>Arbitration priority for master GPDMA. 0: lowest, 15: highest.</description>
	<bitRange>[3:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>AHB_DMA_PL3_REG</name>
	<description>AHB-DMA layer Priority level for CRYPTO-DMA (AHB DMA layer only)</description>
	<addressOffset>0x00000008</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x0000000d</resetValue>
	<resetMask>0xffffffff</resetMask>
	<fields><field>
	<name>AHB_DMA_PL3</name>
	<description>Arbitration priority for master CRYPTO-DMA. 0: lowest, 15: highest.</description>
	<bitRange>[3:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>AHB_DMA_PL4_REG</name>
	<description>AHB-DMA layer Priority level for DRA (AHB DMA layer only)</description>
	<addressOffset>0x0000000c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x0000000c</resetValue>
	<resetMask>0xffffffff</resetMask>
	<fields><field>
	<name>AHB_DMA_PL4</name>
	<description>Arbitration priority for master DRA-DMA. 0: lowest, 15: highest.</description>
	<bitRange>[3:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>AHB_DMA_TCL_REG</name>
	<description>Master clock refresh period (AHB DMA layer only)</description>
	<addressOffset>0x00000050</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x0000ffff</resetValue>
	<resetMask>0xffffffff</resetMask>
	<fields><field>
	<name>AHB_DMA_TCL</name>
	<description>Master clock refresh period, counting clock cycles. An arbitration period is defined over this number of tokens. When a new arbitration period starts, the master counters are reloaded. Recommended value is the sum of the AHB_DMA_CCLMx_REG values plus two tokens for each master, that is plus six.</description>
	<bitRange>[15:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>AHB_DMA_VERSION_REG</name>
	<description>Version ID (AHB DMA layer only)</description>
	<addressOffset>0x00000090</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x3231332a</resetValue>
	<resetMask>0xffffffff</resetMask>
	<fields><field>
	<name>AHB_DMA_VERSION</name>
	<description>System bus verion ID</description>
	<bitRange>[31:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>AHB_DMA_WTEN_REG</name>
	<description>Weighted-Token Arbitration Scheme Enable (AHB DMA layer only)</description>
	<addressOffset>0x0000004c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0xffffffff</resetMask>
	<fields><field>
	<name>AHB_DMA_WTEN</name>
	<description>Weighted-token arbitration scheme enable.
0: Disabled
1: Enabled</description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register></registers>
</peripheral><peripheral>
	<name>FCU</name>
	<version>1.0</version>
	<description>FCU registers</description>
	<groupName>Peripheral_Registers</groupName>
	<baseAddress>0x50060100</baseAddress>
	<size>0</size>
	<addressBlock>
	<offset>0</offset>
	<size>36</size>
	<usage>registers</usage>
</addressBlock>

	<registers>
	<register>
	<name>FLASH_CTRL_REG</name>
	<description>Flash control register</description>
	<addressOffset>0x00000000</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00020c00</resetValue>
	<resetMask>0x03ffffff</resetMask>
	<fields><field>
	<name>DISCHARGE_STAT</name>
	<description>Flash discharging status
1: Discharging state
0: Normal operation</description>
	<bitRange>[25:25]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>DFT_EN</name>
	<description>1: Enable DFT logic, programming Flash through pins</description>
	<bitRange>[24:24]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>VDD_LEVEL_VALUE</name>
	<description>If VDD_LEVEL_FORCE is set to 0, this register field has no effect.
If VDD_LEVEL_FORCE is set to 1, then if VDD_LEVEL_VALUE is:
1: sets vdd_level value to 1 (Should be used if VDD &gt; 1.08 V. Results in Flash input LVEN = 0)
0: sets vdd_level_value to 0 (Should be used if VDD &lt; 1.08 V. Results in Flash input LVEN = 1)</description>
	<bitRange>[23:23]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>VDD_LEVEL_FORCE</name>
	<description>Used with VDD_LEVEL_VALUE to override the vdd_level FCU input signal, to set the LVEN Flash input signal.
This register does not affect the actual VDD level. It only affects the indication to the FCU.
1: Override vdd_level input and force vdd_level to VDD_LEVEL_VALUE
0: Use vdd_level input and do not use VDD_LEVEL_VALUE register field </description>
	<bitRange>[22:22]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>ERASE_RESUME</name>
	<description>Resumes erase on writing 1.</description>
	<bitRange>[21:21]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>ERASE_SUSPEND_STAT</name>
	<description>Erase Suspend status
1: FLASH erase is suspended. Check FLASH_RTERASE_TOT_CNT_REG for the remaining time needed for the erase to complete.
0: FLASH erase is not suspended. Check PROG_ERS status bit for the erase cycle status.</description>
	<bitRange>[20:20]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>ERASE_SUSPEND_MODE</name>
	<description>Choose mode of erase suspend operation:
1:When a read operation is issued, FCU stalls the read access until the erase segment is completed.
0:When a read operation is issued, erase is immediately suspended and erase segment time is not subtracted from total erase time</description>
	<bitRange>[19:19]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>ERASE_SUSPEND_EN</name>
	<description>1: Enable erase suspend functionality</description>
	<bitRange>[18:18]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SLEEP</name>
	<description>Sleep mode status
1: FCU is in sleeping mode. This register's value is cleared on the next read access, and the FCU automatically wakes up.
0: FCU is in standby mode.</description>
	<bitRange>[17:17]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>DMA_EN</name>
	<description>1: Enable DMA handshake when writing to the FCU. It also disables IRQ generation.
0: Disable DMA handshake when writing to the FCU. IRQ generation remains enabled.</description>
	<bitRange>[16:16]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>BUS_ERROR_EN</name>
	<description>1: Bus error response enabled.
0: Bus error response disabled.
The BUS_ERROR status register is not affected by this register's value.
This bit can only be set!! and is reset by RSTn.</description>
	<bitRange>[15:15]</bitRange>
	<access>read-writeOnce</access>
	</field><field>
	<name>BUS_ERROR</name>
	<description>Flash bus error status
1: Bus error occurred in the last FCU AHB access. Register gets cleared on next FCU AHB access.
0: Bus error did not occur in the last FCU AHB access. </description>
	<bitRange>[14:14]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>IRQ_CLEAR</name>
	<description>Clears the IRQ on writing 1</description>
	<bitRange>[13:13]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>WAIT_CYCLES</name>
	<description>Number of wait cycles to be programmed in case HCLK is faster than the worst case access time (Tacc) specified in the Flash memory datasheet.
0: 0 wait cycles
1: 1 wait cycle
2: 2 wait cycles (default)
3: 3 wait cycles
4: 4 wait cycles
5: 5 wait cycles
6: 6 wait cycles
7: 7 wait cycles
Note: When dcore is running at 0.9 V, worst case Tacc = 65 ns, when running at 1.2 V, worst case Tacc = 23 ns.
The combinatorial path from cell to DFF is 5.66 ns.
Use cases:
HCLK = 64 MHz, VDD = 1.2 V -&gt; 1 wait cycles
HCLK = 32 MHz, VDD = 0.9 V -&gt; 2 wait cycles (default conditions on power up)
HCLK = 32 MHz, VDD = 1.2 V -&gt; 0 wait cycles
HCLK = 16 MHz, VDD = 0.9 V -&gt; 1 wait cycles
HCLK = 16 MHz, VDD = 1.2 V -&gt; 0 wait cycles
HCLK = slower than above -&gt; 0 wait cycles

Warning: User must not use 0 wait cycles with 64 MHz clk.</description>
	<bitRange>[12:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>FLASH_RPROT</name>
	<description>If 1 the FLASH can not be read.
This bit can only be set and is reset by RSTn.</description>
	<bitRange>[9:9]</bitRange>
	<access>read-writeOnce</access>
	</field><field>
	<name>FLASH_WPROT</name>
	<description>If 1 the FLASH cannot be written/erased.
This bit can only be set and is reset by RSTn.</description>
	<bitRange>[8:8]</bitRange>
	<access>read-writeOnce</access>
	</field><field>
	<name>FLASH_PROT</name>
	<description>If 1 the FLASH can not be read, written or erased.</description>
	<bitRange>[7:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PROG_RMIN</name>
	<description>FLASH read mode inhibit.
1: Read mode may not be selected after a write, page
erase or mass erase of the selected FLASH as long as this
bit is 1.
0: Read mode may be selected.</description>
	<bitRange>[6:6]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>PROG_ERS</name>
	<description>FLASH erase status
1: Erase cycle in progress
0: Erase cycle ready</description>
	<bitRange>[5:5]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>PROG_WRS</name>
	<description>FLASH write status
1: Write cycle in progress
0: Write cycle ready</description>
	<bitRange>[4:4]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>PROG_SEL</name>
	<description>Select FLASH access mode:
0 : FLASH: Read access mode selected
1 : FLASH: Erase/write access mode selected
Must be set back to 0 to reduce power consumption.</description>
	<bitRange>[3:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SLEEP_MODE</name>
	<description>Puts flash in sleep mode for lower leakage current on writing 1.
Automatically wakes up on read access.</description>
	<bitRange>[2:2]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>PROG_MODE</name>
	<description>Select FLASH programming mode
00 : No write or erase to flash(es) possible.
01 : Write page
10 : Erase page. Address first written to select page.
11 : Erase one of the flash blocks completely (bulk erase)
If the address that starts the erase belongs to the info block, info block and main block are mass erased.
If the address that starts the erase belongs to the main block, only the main block is erased.
To only erase the info block, a page erase of the info block must be done.</description>
	<bitRange>[1:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>FLASH_PTERASE_REG</name>
	<description>Page Erase time register</description>
	<addressOffset>0x0000000c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00013880</resetValue>
	<resetMask>0x00ffffff</resetMask>
	<fields><field>
	<name>PTERASE</name>
	<description>Program flash page Erase time.
T= PTERASE x 1 us = 80 ms (min)
This register can be programmed with values from 1 up to 262143.</description>
	<bitRange>[23:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>FLASH_PTERASE_SEG_REG</name>
	<description>Page erase segment time register</description>
	<addressOffset>0x00000018</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x000003e8</resetValue>
	<resetMask>0x00ffffff</resetMask>
	<fields><field>
	<name>PTERASE_SEG</name>
	<description>Program flash segment of page erase time for suspend erase.
T=PTERASE_SEG x 1 us = 1 ms
This register can be programmed with values from 1 up to 262143.
Note: PTERASE should be a multiple of PTERASE_SEG</description>
	<bitRange>[23:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>FLASH_PTME_REG</name>
	<description>Mass Erase time register</description>
	<addressOffset>0x00000010</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00013880</resetValue>
	<resetMask>0x00ffffff</resetMask>
	<fields><field>
	<name>PTME</name>
	<description>Program flash mass Erase time.
T= PTME x 1 us = 80 ms (min)
This register can be programmed with values from 1 up to 262143.</description>
	<bitRange>[23:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>FLASH_PTNVH1_REG</name>
	<description>NVSTR1 hold time register</description>
	<addressOffset>0x00000004</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000064</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>PTNVH1</name>
	<description>Program flash NVSTR1 hold time.
T = PTNVH1 x 1 us = 100 us (min)</description>
	<bitRange>[15:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>FLASH_PTPROG_REG</name>
	<description>Flash programming time register</description>
	<addressOffset>0x00000008</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000008</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>PTPROG</name>
	<description>Program flash programming time.
T = PTPROG x 1 us = 8 us (min)</description>
	<bitRange>[15:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>FLASH_PTWK_SP_REG</name>
	<description>Wake-up time of sleep to standby register</description>
	<addressOffset>0x00000014</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000003</resetValue>
	<resetMask>0x000000ff</resetMask>
	<fields><field>
	<name>PTWK_SP</name>
	<description>Program flash wake-up time of sleep to standby
T=PTWK_SP x 1 us = 3 us</description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>FLASH_RTERASE_SEG_CNT_REG</name>
	<description>Segment erase time counter register</description>
	<addressOffset>0x00000020</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00ffffff</resetMask>
	<fields><field>
	<name>RTERASE_SEG_CNT</name>
	<description>Returns segment erase time counter value. </description>
	<bitRange>[23:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>FLASH_RTERASE_TOT_CNT_REG</name>
	<description>Total erase time counter register</description>
	<addressOffset>0x0000001c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00ffffff</resetMask>
	<fields><field>
	<name>RTERASE_TOT_CNT</name>
	<description>Returns total erase time counter value. </description>
	<bitRange>[23:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register></registers>
</peripheral><peripheral>
	<name>GPADC</name>
	<version>1.0</version>
	<description>GPADC registers</description>
	<groupName>Peripheral_Registers</groupName>
	<baseAddress>0x50040900</baseAddress>
	<size>0</size>
	<addressBlock>
	<offset>0</offset>
	<size>36</size>
	<usage>registers</usage>
</addressBlock>

	<registers>
	<register>
	<name>GP_ADC_CLEAR_INT_REG</name>
	<description>General Purpose ADC Clear Interrupt Register</description>
	<addressOffset>0x0000001c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>GP_ADC_CLR_INT</name>
	<description>Writing any value to this register will clear the ADC_INT interrupt. Reading returns 0. </description>
	<bitRange>[15:0]</bitRange>
	<access>write-only</access>
	</field></fields>
</register><register>
	<name>GP_ADC_CTRL2_REG</name>
	<description>General Purpose ADC Second Control Register</description>
	<addressOffset>0x00000004</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000200</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>GP_ADC_STORE_DEL</name>
	<description>0: Data is stored after handshake synchronization
1: Data is stored 2 ADC_CLK cycles after internal start trigger
2: Data is stored 3 ADC_CLK cycles after internal start trigger
7: Data is stored 8 ADC_CLK cycles after internal start trigger</description>
	<bitRange>[15:13]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>GP_ADC_SMPL_TIME</name>
	<description>0: The sample time (switch is closed) is two ADC_CLK cycles
1: The sample time is 1*8 ADC_CLK cycles
2: The sample time is 2*8 ADC_CLK cycles
15: The sample time is 15*8 ADC_CLK cycles</description>
	<bitRange>[12:9]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>GP_ADC_CONV_NRS</name>
	<description>0: 1 sample is taken or 2 in case ADC_CHOP is active.
1: 2 samples are taken.
2: 4 samples are taken.
7: 128 samples are taken.</description>
	<bitRange>[8:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>GP_ADC_I20U</name>
	<description>1: Adds 20 uA constant load current at the ADC LDO to minimize ripple on the reference voltage of the ADC.</description>
	<bitRange>[2:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>GP_ADC_ATTN</name>
	<description>0: No attenuator (input voltages up to 0.9 V allowed)
1: Enabling 2x attenuator (input voltages up to 1.8 V allowed)
2: Enabling 3x attenuator (input voltages up to 2.7 V allowed)
3: Enabling 4x attenuator (input voltages up to 3.6 V allowed)
Enabling the attenuator requires a longer sampling time.</description>
	<bitRange>[1:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>GP_ADC_CTRL3_REG</name>
	<description>General Purpose ADC Third Control Register</description>
	<addressOffset>0x00000008</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000040</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>GP_ADC_INTERVAL</name>
	<description>Defines the interval between two ADC conversions in case GP_ADC_CONT is set.
0: No extra delay between two conversions.
1: 1.024 ms interval between two conversions.
2: 2.048 ms interval between two conversions.
255: 261.12 ms interval between two conversions.</description>
	<bitRange>[15:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>GP_ADC_EN_DEL</name>
	<description>Defines the delay for enabling the ADC after enabling the LDO.
0: Not allowed
1: 4x ADC_CLK period.
n: n*4x ADC_CLK period.</description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>GP_ADC_CTRL_REG</name>
	<description>General Purpose ADC Control Register</description>
	<addressOffset>0x00000000</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00001fff</resetMask>
	<fields><field>
	<name>DIE_TEMP_EN</name>
	<description>Enables the die-temperature sensor. Output can be measured on GPADC input 4.</description>
	<bitRange>[12:12]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>GP_ADC_LDO_HOLD</name>
	<description>0: GPADC LDO tracking bandgap reference
1: GPADC LDO hold sampled bandgap reference</description>
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>GP_ADC_CHOP</name>
	<description>0: Chopper mode off
1: Chopper mode enabled. Takes two samples with opposite GP_ADC_SIGN to cancel the internal offset voltage of the ADC; Highly recommended for DC-measurements.</description>
	<bitRange>[9:9]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>GP_ADC_SIGN</name>
	<description>0: Default
1: Conversion with opposite sign at input and output to cancel out the internal offset of the ADC and low-frequency</description>
	<bitRange>[8:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>GP_ADC_MUTE</name>
	<description>0: Normal operation
1: Mute ADC input. Takes sample at mid-scale (to determine the internal offset and/or noise of the ADC with regards to VDD_REF which is also sampled by the ADC).</description>
	<bitRange>[7:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>GP_ADC_SE</name>
	<description>0: Differential mode
1: Single-ended mode</description>
	<bitRange>[6:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>GP_ADC_MINT</name>
	<description>0: Disable (mask) GP_ADC_INT.
1: Enable GP_ADC_INT to ICU.</description>
	<bitRange>[5:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>GP_ADC_INT</name>
	<description>1: AD conversion ready and has generated an interrupt. Must be cleared by writing any value to GP_ADC_CLEAR_INT_REG.</description>
	<bitRange>[4:4]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>GP_ADC_DMA_EN</name>
	<description>0: DMA functionality disabled
1: DMA functionality enabled</description>
	<bitRange>[3:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>GP_ADC_CONT</name>
	<description>0: Manual ADC mode, a single result will be generated after setting the GP_ADC_START bit.
1: Continuous ADC mode, new ADC results will be constantly stored in GP_ADC_RESULT_REG. Still GP_ADC_START has to be set to start the execution. The time between conversions is configurable with GP_ADC_INTERVAL.</description>
	<bitRange>[2:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>GP_ADC_START</name>
	<description>0: ADC conversion ready.
1: If a 1 is written, the ADC starts a conversion. After the conversion this bit will be set to 0 and the GP_ADC_INT bit will be set. It is not allowed to write this bit while it is not (yet) zero.</description>
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>GP_ADC_EN</name>
	<description>0: LDO is off and ADC is disabled.
1: LDO is turned on and afterwards the ADC is enabled.</description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>GP_ADC_OFFN_REG</name>
	<description>General Purpose ADC Negative Offset Register</description>
	<addressOffset>0x00000014</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000200</resetValue>
	<resetMask>0x000003ff</resetMask>
	<fields><field>
	<name>GP_ADC_OFFN</name>
	<description>Offset adjust of the &quot;negative&quot; array of ADC-network. Effective if one of the following conditions holds:
ADC_SE = 0
ADC_SE_1 and ADC_SIGN = 1
ADC_SE = 1 and ADC_CHOP = 1</description>
	<bitRange>[9:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>GP_ADC_OFFP_REG</name>
	<description>General Purpose ADC Positive Offset Register</description>
	<addressOffset>0x00000010</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000200</resetValue>
	<resetMask>0x000003ff</resetMask>
	<fields><field>
	<name>GP_ADC_OFFP</name>
	<description>Offset adjust of the &quot;positive&quot; array of ADC-network. Effective if one of the following conditions holds:
ADC_SE = 0
ADC_SE = 1 and ADC_SIGN = 0
ADC_SE = 1 and ADC_CHOP = 1</description>
	<bitRange>[9:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>GP_ADC_RESULT_REG</name>
	<description>General Purpose ADC Result Register</description>
	<addressOffset>0x00000020</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>GP_ADC_VAL</name>
	<description>Returns 10 up to 16 bits linear value of the last AD conversion. The upper 10 bits are always valid, the lower 6 bits are only valid in case oversampling has been applied. Two samples result in one extra bit and 64 samples result in six extra bits.</description>
	<bitRange>[15:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>GP_ADC_SEL_REG</name>
	<description>General Purpose ADC Input Selection Register</description>
	<addressOffset>0x0000000c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x000000ff</resetMask>
	<fields><field>
	<name>GP_ADC_SEL_P</name>
	<description>ADC positive input selection.
0: ADC0 (P1[0])
1: ADC1 (P1[1])
2: ADC2 (P1[2])
3: ADC3 (P0[10])
4: Temperature Sensor
5: VDCDC
6: VBAT
7: VDDD
8: VSSA
9: VDDIO
A: ADC4 (P1[5])
B: ADC5 (P1[6])
C: ADC6 (P1[9])
D: ADC7 (P1[11])
E: TESTBUS[0]
F: TESTBUS[1]</description>
	<bitRange>[7:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>GP_ADC_SEL_N</name>
	<description>ADC negative input selection. Differential only (GP_ADC_SE=0).
0: ADC0 (P1[0])
1: ADC1 (P1[1])
2: ADC2 (P1[2])
3: ADC3 (P0[10])
A: ADC4 (P1[5])
B: ADC5 (P1[6])
C: ADC6 (P1[9])
D: ADC7 (P1[11])
E: TESTBUS[0]
F: TESTBUS[1]</description>
	<bitRange>[3:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register></registers>
</peripheral><peripheral>
	<name>GPIO</name>
	<version>1.0</version>
	<description>GPIO registers</description>
	<groupName>Peripheral_Registers</groupName>
	<baseAddress>0x50020600</baseAddress>
	<size>0</size>
	<addressBlock>
	<offset>0</offset>
	<size>172</size>
	<usage>registers</usage>
</addressBlock>

	<registers>
	<register>
	<name>GPIO_CLK_SEL_REG</name>
	<description>Select which clock to map on ports P0/P1</description>
	<addressOffset>0x000000a0</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x000003ff</resetMask>
	<fields><field>
	<name>DIVN_OUTPUT_EN</name>
	<description>DIVN output enable bit-field. When set, it enables the mapping of DIVN clock on dedicated GPIO (P0_08). The specific GPIO must be configured as GPIO output.</description>
	<bitRange>[9:9]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RC32M_OUTPUT_EN</name>
	<description>RC32M output enable bit-field. When set, it enables the mapping of RC32M clock on dedicated GPIO (P1_02). The specific GPIO must be configured as GPIO output.</description>
	<bitRange>[8:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>XTAL32M_OUTPUT_EN</name>
	<description>XTAL32M output enable bit-field. When set, it enables the mapping of XTAL32M clock on dedicated GPIO (P0_11). The specific GPIO must be configured as GPIO output.</description>
	<bitRange>[7:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>FUNC_CLOCK_EN</name>
	<description>If set, it enables the mapping of the selected clock signal, according to FUNC_CLOCK_SEL bit-field.</description>
	<bitRange>[3:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>FUNC_CLOCK_SEL</name>
	<description>Select which clock to map when PID = FUNC_CLOCK.
0x0: XTAL32K
0x1: RCLP
0x2: RCX
0x3: XTAL32M
0x4: RC32M
0x5: DIVN
0x6: Reserved
0x7: Reserved</description>
	<bitRange>[2:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>P0_00_MODE_REG</name>
	<description>P0_00 Mode Register</description>
	<addressOffset>0x00000018</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000200</resetValue>
	<resetMask>0x000007ff</resetMask>
	<fields><field>
	<name>PPOD</name>
	<description>0: Push pull
1: Open drain</description>
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PUPD</name>
	<description>00: Input, no resistors selected
01: Input, pull-up selected
10: Input, pull-down selected
11: Output, no resistors selected
In ADC mode, these bits are don't care.</description>
	<bitRange>[9:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PID</name>
	<description>Function of port:
0: GPIO (see also the PUPD bit-field)
1: UART_RX
2: UART_TX
3: UART2_RX
4: UART2_TX
5: UART2_CTSN
6: UART2_RTSN
7: ISO_CLK
8: ISO_DATA
9: SPI_DI
10: SPI_DO
11: SPI_CLK
12: SPI_EN
13: SPI_EN2
14: I2C_SCL
15: I2C_SDA
16: ADC (dedicated pins, see also the &quot;Input/Output Ports&quot; chapter of Datasheet)
17: PCM_DI
18: PCM_DO
19: PCM_FSC
20: PCM_CLK
21: PDM_DATA
22: PDM_CLK
23: CLOCK (see also GPIO_CLK_SEL_REG for the dedicated pins mapping of supported clocks)
24: TIM_PWM
25: TIM2_PWM
26: TIM_1SHOT
27: TIM2_1SHOT
28: TIM3_PWM
29: TIM4_PWM
30: COEX_EXT_ACT
31: COEX_SMART_ACT
32: COEX_SMART_PRI
33: PORT0_DCF
34: PORT1_DCF
35: PORT2_DCF
36: PORT3_DCF
37: PORT4_DCF
38: CMAC_DIAG0
39: CMAC_DIAG1
40: CMAC_DIAG2
41: CMAC_DIAG3
42: CMAC_DIAG4
43: CMAC_DIAG5
44: CMAC_DIAG6
45: CMAC_DIAG7
46: CMAC_DIAG8
47: CMAC_DIAG9
48: CMAC_DIAG10
49: CMAC_DIAG11
50: CMAC_DIAG12
51: CMAC_DIAG13
52: CMAC_DIAG14
53: CMAC_DIAG15
54: Reserved
55: Reserved
56: Reserved
57: Reserved
58: Reserved
59: Reserved
60: Reserved
61: Reserved
62: Reserved
63: Reserved</description>
	<bitRange>[5:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>P0_01_MODE_REG</name>
	<description>P0_01 Mode Register</description>
	<addressOffset>0x0000001c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000100</resetValue>
	<resetMask>0x000007ff</resetMask>
	<fields><field>
	<name>PPOD</name>
	<description>0: Push pull
1: Open drain</description>
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PUPD</name>
	<description>00 = Input, no resistors selected
01 = Input, pull-up selected
10 = Input, pull-down selected
11 = Output, no resistors selected
In ADC mode, these bits are don't care </description>
	<bitRange>[9:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PID</name>
	<description>See P0_00_MODE_REG[PID]</description>
	<bitRange>[5:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>P0_02_MODE_REG</name>
	<description>P0_02 Mode Register</description>
	<addressOffset>0x00000020</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000200</resetValue>
	<resetMask>0x000007ff</resetMask>
	<fields><field>
	<name>PPOD</name>
	<description>0: Push pull
1: Open drain</description>
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PUPD</name>
	<description>00 = Input, no resistors selected
01 = Input, pull-up selected
10 = Input, pull-down selected
11 = Output, no resistors selected
In ADC mode, these bits are don't care </description>
	<bitRange>[9:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PID</name>
	<description>See P0_00_MODE_REG[PID]</description>
	<bitRange>[5:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>P0_03_MODE_REG</name>
	<description>P0_03 Mode Register</description>
	<addressOffset>0x00000024</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000200</resetValue>
	<resetMask>0x000007ff</resetMask>
	<fields><field>
	<name>PPOD</name>
	<description>0: Push pull
1: Open drain</description>
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PUPD</name>
	<description>00 = Input, no resistors selected
01 = Input, pull-up selected
10 = Input, pull-down selected
11 = Output, no resistors selected
In ADC mode, these bits are don't care </description>
	<bitRange>[9:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PID</name>
	<description>See P0_00_MODE_REG[PID]</description>
	<bitRange>[5:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>P0_04_MODE_REG</name>
	<description>P0_04 Mode Register</description>
	<addressOffset>0x00000028</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000200</resetValue>
	<resetMask>0x000007ff</resetMask>
	<fields><field>
	<name>PPOD</name>
	<description>0: Push pull
1: Open drain</description>
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PUPD</name>
	<description>00 = Input, no resistors selected
01 = Input, pull-up selected
10 = Input, pull-down selected
11 = Output, no resistors selected
In ADC mode, these bits are don't care </description>
	<bitRange>[9:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PID</name>
	<description>See P0_00_MODE_REG[PID]</description>
	<bitRange>[5:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>P0_05_MODE_REG</name>
	<description>P0_05 Mode Register</description>
	<addressOffset>0x0000002c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000200</resetValue>
	<resetMask>0x000007ff</resetMask>
	<fields><field>
	<name>PPOD</name>
	<description>0: Push pull
1: Open drain</description>
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PUPD</name>
	<description>00 = Input, no resistors selected
01 = Input, pull-up selected
10 = Input, pull-down selected
11 = Output, no resistors selected
In ADC mode, these bits are don't care </description>
	<bitRange>[9:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PID</name>
	<description>See P0_00_MODE_REG[PID]</description>
	<bitRange>[5:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>P0_06_MODE_REG</name>
	<description>P0_06 Mode Register</description>
	<addressOffset>0x00000030</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000100</resetValue>
	<resetMask>0x000007ff</resetMask>
	<fields><field>
	<name>PPOD</name>
	<description>0: Push pull
1: Open drain</description>
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PUPD</name>
	<description>00 = Input, no resistors selected
01 = Input, pull-up selected
10 = Input, pull-down selected
11 = Output, no resistors selected
In ADC mode, these bits are don't care </description>
	<bitRange>[9:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PID</name>
	<description>See P0_00_MODE_REG[PID]</description>
	<bitRange>[5:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>P0_07_MODE_REG</name>
	<description>P0_07 Mode Register</description>
	<addressOffset>0x00000034</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000200</resetValue>
	<resetMask>0x000007ff</resetMask>
	<fields><field>
	<name>PPOD</name>
	<description>0: Push pull
1: Open drain</description>
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PUPD</name>
	<description>00 = Input, no resistors selected
01 = Input, pull-up selected
10 = Input, pull-down selected
11 = Output, no resistors selected
In ADC mode, these bits are don't care.</description>
	<bitRange>[9:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PID</name>
	<description>See P0_00_MODE_REG[PID]</description>
	<bitRange>[5:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>P0_08_MODE_REG</name>
	<description>P0_08 Mode Register</description>
	<addressOffset>0x00000038</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000100</resetValue>
	<resetMask>0x000007ff</resetMask>
	<fields><field>
	<name>PPOD</name>
	<description>0: Push pull
1: Open drain</description>
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PUPD</name>
	<description>00 = Input, no resistors selected
01 = Input, pull-up selected
10 = Input, pull-down selected
11 = Output, no resistors selected
In ADC mode, these bits are don't care.</description>
	<bitRange>[9:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PID</name>
	<description>See P0_00_MODE_REG[PID] </description>
	<bitRange>[5:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>P0_09_MODE_REG</name>
	<description>P0_09 Mode Register</description>
	<addressOffset>0x0000003c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000200</resetValue>
	<resetMask>0x000007ff</resetMask>
	<fields><field>
	<name>PPOD</name>
	<description>0: Push pull
1: Open drain</description>
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PUPD</name>
	<description>00 = Input, no resistors selected
01 = Input, pull-up selected
10 = Input, pull-down selected
11 = Output, no resistors selected
In ADC mode, these bits are don't care.</description>
	<bitRange>[9:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PID</name>
	<description>See P0_00_MODE_REG[PID] </description>
	<bitRange>[5:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>P0_10_MODE_REG</name>
	<description>P0_10 Mode Register</description>
	<addressOffset>0x00000040</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000200</resetValue>
	<resetMask>0x000007ff</resetMask>
	<fields><field>
	<name>PPOD</name>
	<description>0: Push pull
1: Open drain</description>
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PUPD</name>
	<description>00 = Input, no resistors selected
01 = Input, pull-up selected
10 = Input, pull-down selected
11 = Output, no resistors selected
In ADC mode, these bits are don't care.</description>
	<bitRange>[9:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PID</name>
	<description>See P0_00_MODE_REG[PID]</description>
	<bitRange>[5:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>P0_11_MODE_REG</name>
	<description>P0_11 Mode Register</description>
	<addressOffset>0x00000044</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000200</resetValue>
	<resetMask>0x000007ff</resetMask>
	<fields><field>
	<name>PPOD</name>
	<description>0: Push pull
1: Open drain</description>
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PUPD</name>
	<description>00 = Input, no resistors selected
01 = Input, pull-up selected
10 = Input, pull-down selected
11 = Output, no resistors selected
In ADC mode, these bits are don't care.</description>
	<bitRange>[9:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PID</name>
	<description>See P0_00_MODE_REG[PID]</description>
	<bitRange>[5:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>P0_12_MODE_REG</name>
	<description>P0_12 Mode Register</description>
	<addressOffset>0x00000048</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000200</resetValue>
	<resetMask>0x000007ff</resetMask>
	<fields><field>
	<name>PPOD</name>
	<description>0: Push pull
1: Open drain</description>
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PUPD</name>
	<description>00 = Input, no resistors selected
01 = Input, pull-up selected
10 = Input, pull-down selected
11 = Output, no resistors selected
In ADC mode, these bits are don't care.</description>
	<bitRange>[9:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PID</name>
	<description>See P0_00_MODE_REG[PID]</description>
	<bitRange>[5:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>P0_13_MODE_REG</name>
	<description>P0_13 Mode Register</description>
	<addressOffset>0x0000004c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000200</resetValue>
	<resetMask>0x000007ff</resetMask>
	<fields><field>
	<name>PPOD</name>
	<description>0: Push pull
1: Open drain</description>
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PUPD</name>
	<description>00 = Input, no resistors selected
01 = Input, pull-up selected
10 = Input, pull-down selected
11 = Output, no resistors selected
In ADC mode, these bits are don't care.</description>
	<bitRange>[9:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PID</name>
	<description>See P0_00_MODE_REG[PID]</description>
	<bitRange>[5:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>P0_14_MODE_REG</name>
	<description>P0_14 Mode Register</description>
	<addressOffset>0x00000050</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000200</resetValue>
	<resetMask>0x000007ff</resetMask>
	<fields><field>
	<name>PPOD</name>
	<description>0: Push pull
1: Open drain</description>
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PUPD</name>
	<description>00 = Input, no resistors selected
01 = Input, pull-up selected
10 = Input, pull-down selected
11 = Output, no resistors selected
In ADC mode, these bits are don't care.</description>
	<bitRange>[9:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PID</name>
	<description>See P0_00_MODE_REG[PID]</description>
	<bitRange>[5:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>P0_15_MODE_REG</name>
	<description>P0_15 Mode Register</description>
	<addressOffset>0x00000054</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000200</resetValue>
	<resetMask>0x000007ff</resetMask>
	<fields><field>
	<name>PPOD</name>
	<description>0: Push pull
1: Open drain</description>
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PUPD</name>
	<description>00 = Input, no resistors selected
01 = Input, pull-up selected
10 = Input, pull-down selected
11 = Output, no resistors selected
In ADC mode, these bits are don't care.</description>
	<bitRange>[9:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PID</name>
	<description>See P0_00_MODE_REG[PID]</description>
	<bitRange>[5:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>P0_DATA_REG</name>
	<description>P0 Data input/output Register</description>
	<addressOffset>0x00000000</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000142</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>P0_DATA</name>
	<description>Set P0 output register when written;
Returns the value of P0 port when read </description>
	<bitRange>[15:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>P0_RESET_DATA_REG</name>
	<description>P0 Reset port pins Register</description>
	<addressOffset>0x00000010</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>P0_RESET</name>
	<description>Writing a 1 to P0[y] sets P0[y] to 0. Writing 0 is discarded;
Reading returns 0 </description>
	<bitRange>[15:0]</bitRange>
	<access>write-only</access>
	</field></fields>
</register><register>
	<name>P0_SET_DATA_REG</name>
	<description>P0 Set port pins Register</description>
	<addressOffset>0x00000008</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>P0_SET</name>
	<description>Writing a 1 to P0[y] sets P0[y] to 1. Writing 0 is discarded;
Reading returns 0 </description>
	<bitRange>[15:0]</bitRange>
	<access>write-only</access>
	</field></fields>
</register><register>
	<name>P0_WEAK_CTRL_REG</name>
	<description>Weak Pads Control Register</description>
	<addressOffset>0x000000a4</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffc0</resetMask>
	<fields><field>
	<name>P0_LOWDRV</name>
	<description>0 = P0_x port is driven with normal drive strength (default)
1 = P0_x port is driven with reduced drive strength</description>
	<bitRange>[15:6]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>P1_00_MODE_REG</name>
	<description>P1_00 Mode Register</description>
	<addressOffset>0x00000058</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000200</resetValue>
	<resetMask>0x000007ff</resetMask>
	<fields><field>
	<name>PPOD</name>
	<description>0: Push pull
1: Open drain</description>
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PUPD</name>
	<description>00 = Input, no resistors selected
01 = Input, pull-up selected
10 = Input, pull-down selected
11 = Output, no resistors selected
In ADC mode, these bits are don't care </description>
	<bitRange>[9:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PID</name>
	<description>See P0_00_MODE_REG[PID]</description>
	<bitRange>[5:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>P1_01_MODE_REG</name>
	<description>P1_01 Mode Register</description>
	<addressOffset>0x0000005c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000200</resetValue>
	<resetMask>0x000007ff</resetMask>
	<fields><field>
	<name>PPOD</name>
	<description>0: Push pull
1: Open drain</description>
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PUPD</name>
	<description>00 = Input, no resistors selected
01 = Input, pull-up selected
10 = Input, pull-down selected
11 = Output, no resistors selected
In ADC mode, these bits are don't care </description>
	<bitRange>[9:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PID</name>
	<description>See P0_00_MODE_REG[PID]</description>
	<bitRange>[5:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>P1_02_MODE_REG</name>
	<description>P1_02 Mode Register</description>
	<addressOffset>0x00000060</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000200</resetValue>
	<resetMask>0x000007ff</resetMask>
	<fields><field>
	<name>PPOD</name>
	<description>0: Push pull
1: Open drain</description>
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PUPD</name>
	<description>00 = Input, no resistors selected
01 = Input, pull-up selected
10 = Input, pull-down selected
11 = Output, no resistors selected
In ADC mode, these bits are don't care </description>
	<bitRange>[9:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PID</name>
	<description>See P0_00_MODE_REG[PID]</description>
	<bitRange>[5:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>P1_03_MODE_REG</name>
	<description>P1_03 Mode Register</description>
	<addressOffset>0x00000064</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000200</resetValue>
	<resetMask>0x000007ff</resetMask>
	<fields><field>
	<name>PPOD</name>
	<description>0: Push pull
1: Open drain</description>
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PUPD</name>
	<description>00 = Input, no resistors selected
01 = Input, pull-up selected
10 = Input, pull-down selected
11 = Output, no resistors selected
In ADC mode, these bits are don't care </description>
	<bitRange>[9:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PID</name>
	<description>See P0_00_MODE_REG[PID]</description>
	<bitRange>[5:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>P1_04_MODE_REG</name>
	<description>P1_04 Mode Register</description>
	<addressOffset>0x00000068</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000200</resetValue>
	<resetMask>0x000007ff</resetMask>
	<fields><field>
	<name>PPOD</name>
	<description>0: Push pull
1: Open drain</description>
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PUPD</name>
	<description>00 = Input, no resistors selected
01 = Input, pull-up selected
10 = Input, pull-down selected
11 = Output, no resistors selected
In ADC mode, these bits are don't care</description>
	<bitRange>[9:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PID</name>
	<description>See P0_00_MODE_REG[PID]</description>
	<bitRange>[5:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>P1_05_MODE_REG</name>
	<description>P1_05 Mode Register</description>
	<addressOffset>0x0000006c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000200</resetValue>
	<resetMask>0x000007ff</resetMask>
	<fields><field>
	<name>PPOD</name>
	<description>0: Push pull
1: Open drain</description>
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PUPD</name>
	<description>00 = Input, no resistors selected
01 = Input, pull-up selected
10 = Input, pull-down selected
11 = Output, no resistors selected
In ADC mode, these bits are don't care</description>
	<bitRange>[9:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PID</name>
	<description>See P0_00_MODE_REG[PID]</description>
	<bitRange>[5:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>P1_06_MODE_REG</name>
	<description>P1_06 Mode Register</description>
	<addressOffset>0x00000070</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000200</resetValue>
	<resetMask>0x000007ff</resetMask>
	<fields><field>
	<name>PPOD</name>
	<description>0: Push pull
1: Open drain</description>
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PUPD</name>
	<description>00 = Input, no resistors selected
01 = Input, pull-up selected
10 = Input, pull-down selected
11 = Output, no resistors selected
In ADC mode, these bits are don't care </description>
	<bitRange>[9:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PID</name>
	<description>See P0_00_MODE_REG[PID]</description>
	<bitRange>[5:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>P1_07_MODE_REG</name>
	<description>P1_07 Mode Register</description>
	<addressOffset>0x00000074</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000200</resetValue>
	<resetMask>0x000007ff</resetMask>
	<fields><field>
	<name>PPOD</name>
	<description>0: Push pull
1: Open drain</description>
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PUPD</name>
	<description>00 = Input, no resistors selected
01 = Input, pull-up selected
10 = Input, pull-down selected
11 = Output, no resistors selected
In ADC mode, these bits are don't care </description>
	<bitRange>[9:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PID</name>
	<description>See P0_00_MODE_REG[PID]</description>
	<bitRange>[5:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>P1_08_MODE_REG</name>
	<description>P1_08 Mode Register</description>
	<addressOffset>0x00000078</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000200</resetValue>
	<resetMask>0x000007ff</resetMask>
	<fields><field>
	<name>PPOD</name>
	<description>0: Push pull
1: Open drain</description>
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PUPD</name>
	<description>00 = Input, no resistors selected
01 = Input, pull-up selected
10 = Input, pull-down selected
11 = Output, no resistors selected
In ADC mode, these bits are don't care.</description>
	<bitRange>[9:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PID</name>
	<description>See P0_00_MODE_REG[PID]</description>
	<bitRange>[5:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>P1_09_MODE_REG</name>
	<description>P1_09 Mode Register</description>
	<addressOffset>0x0000007c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000200</resetValue>
	<resetMask>0x000007ff</resetMask>
	<fields><field>
	<name>PPOD</name>
	<description>0: Push pull
1: Open drain</description>
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PUPD</name>
	<description>00 = Input, no resistors selected
01 = Input, pull-up selected
10 = Input, pull-down selected
11 = Output, no resistors selected
In ADC mode, these bits are don't care.</description>
	<bitRange>[9:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PID</name>
	<description>See P0_00_MODE_REG[PID]</description>
	<bitRange>[5:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>P1_10_MODE_REG</name>
	<description>P1_10 Mode Register</description>
	<addressOffset>0x00000080</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000200</resetValue>
	<resetMask>0x000007ff</resetMask>
	<fields><field>
	<name>PPOD</name>
	<description>0: Push pull
1: Open drain</description>
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PUPD</name>
	<description>00 = Input, no resistors selected
01 = Input, pull-up selected
10 = Input, pull-down selected
11 = Output, no resistors selected
In ADC mode, these bits are don't care.</description>
	<bitRange>[9:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PID</name>
	<description>See P0_00_MODE_REG[PID]</description>
	<bitRange>[5:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>P1_11_MODE_REG</name>
	<description>P1_11 Mode Register</description>
	<addressOffset>0x00000084</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000200</resetValue>
	<resetMask>0x000007ff</resetMask>
	<fields><field>
	<name>PPOD</name>
	<description>0: Push pull
1: Open drain</description>
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PUPD</name>
	<description>00 = Input, no resistors selected
01 = Input, pull-up selected
10 = Input, pull-down selected
11 = Output, no resistors selected
In ADC mode, these bits are don't care.</description>
	<bitRange>[9:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PID</name>
	<description>See P0_00_MODE_REG[PID]</description>
	<bitRange>[5:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>P1_12_MODE_REG</name>
	<description>P1_12 Mode Register</description>
	<addressOffset>0x00000088</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000200</resetValue>
	<resetMask>0x000007ff</resetMask>
	<fields><field>
	<name>PPOD</name>
	<description>0: Push pull
1: Open drain</description>
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PUPD</name>
	<description>00 = Input, no resistors selected
01 = Input, pull-up selected
10 = Input, pull-down selected
11 = Output, no resistors selected
In ADC mode, these bits are don't care.</description>
	<bitRange>[9:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PID</name>
	<description>See P0_00_MODE_REG[PID]</description>
	<bitRange>[5:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>P1_13_MODE_REG</name>
	<description>P1_13 Mode Register</description>
	<addressOffset>0x0000008c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000200</resetValue>
	<resetMask>0x000007ff</resetMask>
	<fields><field>
	<name>PPOD</name>
	<description>0: Push pull
1: Open drain</description>
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PUPD</name>
	<description>00 = Input, no resistors selected
01 = Input, pull-up selected
10 = Input, pull-down selected
11 = Output, no resistors selected
In ADC mode, these bits are don't care.</description>
	<bitRange>[9:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PID</name>
	<description>See P0_00_MODE_REG[PID]</description>
	<bitRange>[5:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>P1_14_MODE_REG</name>
	<description>P1_14 Mode Register</description>
	<addressOffset>0x00000090</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000200</resetValue>
	<resetMask>0x000007ff</resetMask>
	<fields><field>
	<name>PPOD</name>
	<description>0: Push pull
1: Open drain</description>
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PUPD</name>
	<description>00 = Input, no resistors selected
01 = Input, pull-up selected
10 = Input, pull-down selected
11 = Output, no resistors selected
In ADC mode, these bits are don't care.</description>
	<bitRange>[9:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PID</name>
	<description>See P0_00_MODE_REG[PID]</description>
	<bitRange>[5:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>P1_15_MODE_REG</name>
	<description>P1_15 Mode Register</description>
	<addressOffset>0x00000094</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000200</resetValue>
	<resetMask>0x000007ff</resetMask>
	<fields><field>
	<name>PPOD</name>
	<description>0: Push pull
1: Open drain</description>
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PUPD</name>
	<description>00 = Input, no resistors selected
01 = Input, pull-up selected
10 = Input, pull-down selected
11 = Output, no resistors selected
In ADC mode, these bits are don't care.</description>
	<bitRange>[9:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PID</name>
	<description>See P0_00_MODE_REG[PID]</description>
	<bitRange>[5:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>P1_DATA_REG</name>
	<description>P1 Data input/output Register</description>
	<addressOffset>0x00000004</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>P1_DATA</name>
	<description>Set P1 output register when written;
Returns the value of P1 port when read </description>
	<bitRange>[15:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>P1_RESET_DATA_REG</name>
	<description>P1 Reset port pins Register</description>
	<addressOffset>0x00000014</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>P1_RESET</name>
	<description>Writing a 1 to P1[y] sets P1[y] to 0. Writing 0 is discarded;
Reading returns 0 </description>
	<bitRange>[15:0]</bitRange>
	<access>write-only</access>
	</field></fields>
</register><register>
	<name>P1_SET_DATA_REG</name>
	<description>P1 Set port pins Register</description>
	<addressOffset>0x0000000c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>P1_SET</name>
	<description>Writing a 1 to P1[y] sets P1[y] to 1. Writing 0 is discarded;
Reading returns 0 </description>
	<bitRange>[15:0]</bitRange>
	<access>write-only</access>
	</field></fields>
</register><register>
	<name>P1_WEAK_CTRL_REG</name>
	<description>Weak Pads Control Register</description>
	<addressOffset>0x000000a8</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>P1_LOWDRV</name>
	<description>0 = P1_x port is driven with normal drive strength (default)
1 = P1_x port is driven with reduced drive strength</description>
	<bitRange>[15:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register></registers>
</peripheral><peripheral>
	<name>GPREG</name>
	<version>1.0</version>
	<description>GPREG registers</description>
	<groupName>Peripheral_Registers</groupName>
	<baseAddress>0x50050300</baseAddress>
	<size>0</size>
	<addressBlock>
	<offset>0</offset>
	<size>24</size>
	<usage>registers</usage>
</addressBlock>

	<registers>
	<register>
	<name>DEBUG_REG</name>
	<description>Various debug information register.</description>
	<addressOffset>0x00000008</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000101</resetValue>
	<resetMask>0xffffffff</resetMask>
	<fields><field>
	<name>CROSS_CPU_HALT_SENSITIVITY</name>
	<description>Select the cross CPU halt sensitivity.
0: Level triggered,
1: Pulse triggered.
Note: This bit is retained.</description>
	<bitRange>[8:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SYS_CPUWAIT_ON_JTAG</name>
	<description>1: Stall the processor core out of reset (only after a wake-up from JTAG). Debugger access continue when the core is stalled. When set to 0 again, the core resumes instruction execution.
This feature is independent of the PDC (Power Domain Controller) settings. If this bit is set and there is SW/JTAG activity during deep sleep, the SYS CPU is stalled after the wake-up.
Note: This bit is retained.</description>
	<bitRange>[7:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SYS_CPUWAIT</name>
	<description>1: Stall the processor core out of reset (always after a wake-up). Debugger access continue when the core is stalled. When set to 0 again, the core resumes instruction execution.
Note: This bit is retained.</description>
	<bitRange>[6:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>CMAC_CPU_IS_HALTED</name>
	<description>1: CMAC CPU is halted.</description>
	<bitRange>[5:5]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>SYS_CPU_IS_HALTED</name>
	<description>1: SYS CPU (ARM CM33) is halted.</description>
	<bitRange>[4:4]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>HALT_CMAC_SYS_CPU_EN</name>
	<description>1: Enable CMAC CPU halting to the SYS CPU (ARM CM33).
Note 1: This bit is retained.
Note 2: Set this bit to 0 before going into deep sleep to prevent unpredictable halting behavior after waking up.</description>
	<bitRange>[3:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>HALT_SYS_CMAC_CPU_EN</name>
	<description>1: Enable SYS CPU (ARM CM33) halting to the CMAC CPU.
Note 1: This bit is retained.
Note 2: Set this bit to 0 before going into deep sleep to prevent unpredictable halting behavior after waking up.</description>
	<bitRange>[2:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>CMAC_CPU_FREEZE_EN</name>
	<description>1: Enable Freezing on-chip peripherals (see Note 2) by the CMAC CPU.
Note 1: This bit is retained.
Note 2: See [RE]SET_FREEZE_REG for the specific on-chip peripherals.</description>
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SYS_CPU_FREEZE_EN</name>
	<description>1: Enable Freezing on-chip peripherals (see Note 2) by the SYS CPU (ARM CM33).
Default 1, freezing of the on-chip peripherals is enabled when the Cortex-M33 is halted in DEBUG State.
If 0, freezing of the on-chip peripherals is only depending on [RE]SET_FREEZE_REG except the system watchdog timer. The system watchdog timer is always frozen when the Cortex-M33 is halted in the DEBUG state.
Note 1: This bit is retained.
Note 2: See [RE]SET_FREEZE_REG for the specific on-chip peripherals.</description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>GP_STATUS_REG</name>
	<description>General purpose system status register.</description>
	<addressOffset>0x0000000c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0xffffffff</resetMask>
	<fields><field>
	<name>CAL_PHASE</name>
	<description>If 1, it designates that the chip is in Calibration Phase, that means the Information Page (IP) has been initially programmed but no Calibration has occurred. </description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>RESET_FREEZE_REG</name>
	<description>Controls unfreezing of various timers/counters (incl. DMA).</description>
	<addressOffset>0x00000004</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0xffffffff</resetMask>
	<fields><field>
	<name>FRZ_CMAC_WDOG</name>
	<description>If 1, the CMAC SW Watchdog Timer continues, 0 is discarded. </description>
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>FRZ_SWTIM4</name>
	<description>If 1, the SW Timer4 continues, 0 is discarded. </description>
	<bitRange>[9:9]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>FRZ_SWTIM3</name>
	<description>If 1, the SW Timer3 continues, 0 is discarded. </description>
	<bitRange>[8:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>FRZ_SWTIM2</name>
	<description>If 1, the SW Timer2 continues, 0 is discarded. </description>
	<bitRange>[6:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>FRZ_DMA</name>
	<description>If 1, the DMA continues, 0 is discarded. </description>
	<bitRange>[5:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>FRZ_SYS_WDOG</name>
	<description>If 1, the SYS SW Watchdog Timer continues, 0 is discarded. </description>
	<bitRange>[3:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>FRZ_RESERVED</name>

	<bitRange>[2:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>FRZ_SWTIM</name>
	<description>If 1, the SW Timer continues, 0 is discarded. </description>
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>FRZ_WKUPTIM</name>
	<description>If 1, the Wake Up Timer continues, 0 is discarded. </description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>SCPU_FCU_TAG_REG</name>
	<description>SysCPU FCU tag register.</description>
	<addressOffset>0x00000014</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0xffffffff</resetMask>
	<fields><field>
	<name>SCPU_FCU_TAG_ALL_TRANS</name>
	<description>0: Tag only FCU/eFlash instruction fetches from CPUC (default).
1: Tag all FCU/eFlash transactions from CPUC.
Note 1: The (CM33) CPUS transactions are not tagged.
Note 2: This bit is retained.</description>
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SCPU_FCU_TAG_EN</name>
	<description>For activation of FCU buffering by the SYS CPU (ARM CM33):
0: Disable the tagging of transfers as bufferable (default).
1: Enable the tagging of transfers as bufferable.
Note: This bit is retained.</description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>SET_FREEZE_REG</name>
	<description>Controls freezing of various timers/counters (incl. DMA).</description>
	<addressOffset>0x00000000</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0xffffffff</resetMask>
	<fields><field>
	<name>FRZ_CMAC_WDOG</name>
	<description>If 1, the CMAC SW Watchdog Timer is frozen, 0 is discarded. </description>
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>FRZ_SWTIM4</name>
	<description>If 1, the SW Timer4 is frozen, 0 is discarded. </description>
	<bitRange>[9:9]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>FRZ_SWTIM3</name>
	<description>If 1, the SW Timer3 is frozen, 0 is discarded. </description>
	<bitRange>[8:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>FRZ_SWTIM2</name>
	<description>If 1, the SW Timer2 is frozen, 0 is discarded. </description>
	<bitRange>[6:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>FRZ_DMA</name>
	<description>If 1, the DMA is frozen, 0 is discarded. </description>
	<bitRange>[5:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>FRZ_SYS_WDOG</name>
	<description>If 1, the SYS SW Watchdog Timer is frozen, 0 is discarded. WATCHDOG_CTRL_REG[NMI_RST] must be 0 to allow the freeze function. </description>
	<bitRange>[3:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>FRZ_RESERVED</name>

	<bitRange>[2:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>FRZ_SWTIM</name>
	<description>If 1, the SW Timer is frozen, 0 is discarded. </description>
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>FRZ_WKUPTIM</name>
	<description>If 1, the Wake-Up Timer is frozen, 0 is discarded. </description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register></registers>
</peripheral><peripheral>
	<name>I2C</name>
	<version>1.0</version>
	<description>I2C registers</description>
	<groupName>Peripheral_Registers</groupName>
	<baseAddress>0x50020300</baseAddress>
	<size>0</size>
	<addressBlock>
	<offset>0</offset>
	<size>168</size>
	<usage>registers</usage>
</addressBlock>

	<registers>
	<register>
	<name>I2C_ACK_GENERAL_CALL_REG</name>
	<description>I2C ACK General Call Register</description>
	<addressOffset>0x00000098</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>ACK_GEN_CALL</name>
	<description>ACK General Call. When set to 1, I2C Ctrl responds with a ACK (by asserting ic_data_oe) when it receives a General Call. When set to 0, the controller does not generate General Call interrupts.
1 = Generate ACK for a General Call
0 = Generate NACK for General Call </description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>I2C_CLR_ACTIVITY_REG</name>
	<description>Clear ACTIVITY Interrupt Register</description>
	<addressOffset>0x0000005c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0xffffffff</resetMask>
	<fields><field>
	<name>CLR_ACTIVITY</name>
	<description>Reading this register clears the ACTIVITY interrupt if the I2C is not active anymore. If the I2C module is still active on the bus, the ACTIVITY interrupt bit continues to be set. It is automatically cleared by hardware if the module is disabled and if there is no further activity on the bus. The value read from this register to get status of the ACTIVITY interrupt (bit 8) of the IC_RAW_INTR_STAT register </description>
	<bitRange>[0:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>I2C_CLR_GEN_CALL_REG</name>
	<description>Clear GEN_CALL Interrupt Register</description>
	<addressOffset>0x00000068</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0xffffffff</resetMask>
	<fields><field>
	<name>CLR_GEN_CALL</name>
	<description>Read this register to clear the GEN_CALL interrupt (bit 11) of
I2C_RAW_INTR_STAT register. </description>
	<bitRange>[0:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>I2C_CLR_INTR_REG</name>
	<description>Clear Combined and Individual Interrupt Register</description>
	<addressOffset>0x00000040</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0xffffffff</resetMask>
	<fields><field>
	<name>CLR_INTR</name>
	<description>Read this register to clear the combined interrupt, all individual interrupts, and the I2C_TX_ABRT_SOURCE register. This bit does not clear hardware clearable interrupts but software clearable interrupts. Refer to Bit 9 of the I2C_TX_ABRT_SOURCE register for an exception to clearing I2C_TX_ABRT_SOURCE </description>
	<bitRange>[0:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>I2C_CLR_RD_REQ_REG</name>
	<description>Clear RD_REQ Interrupt Register</description>
	<addressOffset>0x00000050</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0xffffffff</resetMask>
	<fields><field>
	<name>CLR_RD_REQ</name>
	<description>Read this register to clear the RD_REQ interrupt (bit 5) of the I2C_RAW_INTR_STAT register. </description>
	<bitRange>[0:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>I2C_CLR_RX_DONE_REG</name>
	<description>Clear RX_DONE Interrupt Register</description>
	<addressOffset>0x00000058</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0xffffffff</resetMask>
	<fields><field>
	<name>CLR_RX_DONE</name>
	<description>Read this register to clear the RX_DONE interrupt (bit 7) of the
I2C_RAW_INTR_STAT register. </description>
	<bitRange>[0:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>I2C_CLR_RX_OVER_REG</name>
	<description>Clear RX_OVER Interrupt Register</description>
	<addressOffset>0x00000048</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0xffffffff</resetMask>
	<fields><field>
	<name>CLR_RX_OVER</name>
	<description>Read this register to clear the RX_OVER interrupt (bit 1) of the
I2C_RAW_INTR_STAT register. </description>
	<bitRange>[0:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>I2C_CLR_RX_UNDER_REG</name>
	<description>Clear RX_UNDER Interrupt Register</description>
	<addressOffset>0x00000044</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0xffffffff</resetMask>
	<fields><field>
	<name>CLR_RX_UNDER</name>
	<description>Read this register to clear the RX_UNDER interrupt (bit 0) of the
I2C_RAW_INTR_STAT register. </description>
	<bitRange>[0:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>I2C_CLR_START_DET_REG</name>
	<description>Clear START_DET Interrupt Register</description>
	<addressOffset>0x00000064</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0xffffffff</resetMask>
	<fields><field>
	<name>CLR_START_DET</name>
	<description>Read this register to clear the START_DET interrupt (bit 10) of the IC_RAW_INTR_STAT register. </description>
	<bitRange>[0:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>I2C_CLR_STOP_DET_REG</name>
	<description>Clear STOP_DET Interrupt Register</description>
	<addressOffset>0x00000060</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0xffffffff</resetMask>
	<fields><field>
	<name>CLR_STOP_DET</name>
	<description>Read this register to clear the STOP_DET interrupt (bit 9) of the IC_RAW_INTR_STAT register. </description>
	<bitRange>[0:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>I2C_CLR_TX_ABRT_REG</name>
	<description>Clear TX_ABRT Interrupt Register</description>
	<addressOffset>0x00000054</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0xffffffff</resetMask>
	<fields><field>
	<name>CLR_TX_ABRT</name>
	<description>Read this register to clear the TX_ABRT interrupt (bit 6) of the
IC_RAW_INTR_STAT register, and the I2C_TX_ABRT_SOURCE register. This also releases the TX FIFO from the flushed/reset state, allowing more writes to the TX FIFO. Refer to Bit 9 of the I2C_TX_ABRT_SOURCE register for an exception to clearing IC_TX_ABRT_SOURCE. </description>
	<bitRange>[0:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>I2C_CLR_TX_OVER_REG</name>
	<description>Clear TX_OVER Interrupt Register</description>
	<addressOffset>0x0000004c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0xffffffff</resetMask>
	<fields><field>
	<name>CLR_TX_OVER</name>
	<description>Read this register to clear the TX_OVER interrupt (bit 3) of the I2C_RAW_INTR_STAT register. </description>
	<bitRange>[0:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>I2C_CON_REG</name>
	<description>I2C Control Register</description>
	<addressOffset>0x00000000</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x0000007f</resetValue>
	<resetMask>0xffffffff</resetMask>
	<fields><field>
	<name>I2C_STOP_DET_IF_MASTER_ACTIVE</name>
	<description>In Master mode:
1 = Issues the STOP_DET interrupt only when master is active.
0 = Issues the STOP_DET irrespective of whether master is active or not. </description>
	<bitRange>[10:10]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>I2C_RX_FIFO_FULL_HLD_CTRL</name>
	<description>This bit controls whether DW_apb_i2c should hold the bus when the Rx FIFO is physically full to its RX_BUFFER_DEPTH
1 = Hold bus when RX_FIFO is full
0 = Overflow when RX_FIFO is full</description>
	<bitRange>[9:9]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>I2C_TX_EMPTY_CTRL</name>
	<description>This bit controls the generation of the TX_EMPTY interrupt, as described in the IC_RAW_INTR_STAT register.
1 = Controlled generation of TX_EMPTY interrupt
0 = Default behaviour of TX_EMPTY interrupt </description>
	<bitRange>[8:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>I2C_STOP_DET_IFADDRESSED</name>
	<description>1 = Slave issues STOP_DET interrupt only if addressed
0 = Slave issues STOP_DET interrupt always
During a general call address, this slave does not issue the STOP_DET interrupt if STOP_DET_IF_ADDRESSED = 1'b1, even if the slave responds to the general call address by generating ACK. The STOP_DET interrupt is generated only when the transmitted address matches the slave address (SAR).</description>
	<bitRange>[7:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>I2C_SLAVE_DISABLE</name>
	<description>Slave enabled or disabled after reset is applied, which means software does not have to configure the slave.
0 = Slave is enabled
1 = Slave is disabled
Software should ensure that if this bit is written with 0, then bit 0 should also be written with a 0. </description>
	<bitRange>[6:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>I2C_RESTART_EN</name>
	<description>Determines whether RESTART conditions may be sent when acting as a master
0 = Disable
1 = Enable </description>
	<bitRange>[5:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>I2C_10BITADDR_MASTER</name>
	<description>Controls whether the controller starts its transfers in 7- or 10-bit addressing mode when acting as a master.
0 = 7-bit addressing
1 = 10-bit addressing </description>
	<bitRange>[4:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>I2C_10BITADDR_SLAVE</name>
	<description>When acting as a slave, this bit controls whether the controller responds to 7- or 10-bit addresses.
0= 7-bit addressing
1= 10-bit addressing </description>
	<bitRange>[3:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>I2C_SPEED</name>
	<description>These bits control at which speed the controller operates.
1 = Standard mode (100 kbit/s)
2 = Fast mode (400 kbit/s)
3 = High speed mode </description>
	<bitRange>[2:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>I2C_MASTER_MODE</name>
	<description>This bit controls whether the controller master is enabled.
0 = Master disabled
1 = Master enabled
Software should ensure that if this bit is written with 1 then bit 6 should also be written with a 1. </description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>I2C_DATA_CMD_REG</name>
	<description>I2C Rx/Tx Data Buffer and Command Register</description>
	<addressOffset>0x00000010</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x7fffffff</resetMask>
	<fields><field>
	<name>I2C_RESTART</name>
	<description>This bit controls whether a RESTART is issued before the byte is sent or received.
1 = If IC_RESTART_EN is 1, a RESTART is issued before the data is sent/received (according to the value of CMD), regardless of whether or not the transfer direction is changing from the previous command; if IC_RESTART_EN is 0, a STOP followed by a START is issued instead.
0 = If IC_RESTART_EN is 1, a RESTART is issued only if the transfer direction is changing from the previous command; if IC_RESTART_EN is 0, a STOP followed by a START is issued instead.</description>
	<bitRange>[10:10]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>I2C_STOP</name>
	<description>This bit controls whether a STOP is issued after the byte is sent or received.
1 = STOP is issued after this byte, regardless of whether or not the Tx FIFO is empty. If the Tx FIFO is not empty, the master immediately tries to start a new transfer by issuing a START and arbitrating for the bus.
0 = STOP is not issued after this byte, regardless of whether or not the Tx FIFO is empty. If the Tx FIFO is not empty, the master continues the current transfer by sending/receiving data bytes according to the value of the CMD bit. If the Tx FIFO is empty, the master holds the SCL line low and stalls the bus until a new command is available in the Tx FIFO. </description>
	<bitRange>[9:9]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>I2C_CMD</name>
	<description>This bit controls whether a read or a write is performed. This bit does not control the direction when the I2C Ctrl acts as a slave. It controls only the direction when it acts as a master.
1 = Read
0 = Write
When a command is entered in the TX FIFO, this bit distinguishes the write and read commands. In slave-receiver mode, this bit is a &quot;don't care&quot; because writes to this register are not required. In slave-transmitter mode, a &quot;0&quot; indicates that CPU data is to be transmitted and as DAT or IC_DATA_CMD[7:0]. When programming this bit, you should remember the following: attempting to perform a read operation after a General Call command has been sent results in a TX_ABRT interrupt (bit 6 of the I2C_RAW_INTR_STAT_REG), unless bit 11 (SPECIAL) in the I2C_TAR register has been cleared.
If a &quot;1&quot; is written to this bit after receiving a RD_REQ interrupt, then a TX_ABRT interrupt occurs.
NOTE: It is possible that while attempting a master I2C read transfer on the controller, a RD_REQ interrupt may have occurred simultaneously due to a remote I2C master addressing the controller. In this type of scenario, it ignores the I2C_DATA_CMD write, generates a TX_ABRT interrupt, and waits to service the RD_REQ interrupt </description>
	<bitRange>[8:8]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>I2C_DAT</name>
	<description>This register contains the data to be transmitted or received on the I2C bus. If you are writing to this register and want to perform a read, bits 7:0 (DAT) are ignored by the controller. However, when you read this register, these bits return the value of data received on the controller's interface. </description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>I2C_DMA_CR_REG</name>
	<description>DMA Control Register</description>
	<addressOffset>0x00000088</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00000003</resetMask>
	<fields><field>
	<name>TDMAE</name>
	<description>Transmit DMA Enable. //This bit enables/disables the transmit FIFO DMA channel.
0 = Transmit DMA disabled
1 = Transmit DMA enabled </description>
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RDMAE</name>
	<description>Receive DMA Enable. This bit enables/disables the receive FIFO DMA channel.
0 = Receive DMA disabled
1 = Receive DMA enabled </description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>I2C_DMA_RDLR_REG</name>
	<description>I2C Receive Data Level Register</description>
	<addressOffset>0x00000090</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000001f</resetMask>
	<fields><field>
	<name>DMARDL</name>
	<description>Receive Data Level. This bit field controls the level at which a DMA request is made by the receive logic. The watermark level = DMARDL+1; that is, dma_rx_req is generated when the number of valid data entries in the receive FIFO is equal to or more than this field value + 1, and RDMAE =1. For instance, when DMARDL is 0, then dma_rx_req is asserted when 1 or more data entries are present in the receive FIFO.</description>
	<bitRange>[4:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>I2C_DMA_TDLR_REG</name>
	<description>DMA Transmit Data Level Register</description>
	<addressOffset>0x0000008c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000001f</resetMask>
	<fields><field>
	<name>DMATDL</name>
	<description>Transmit Data Level. This bit field controls the level at which a DMA request is made by the transmit logic. It is equal to the watermark level; that is, the dma_tx_req signal is generated when the number of valid data entries in the transmit FIFO is equal to or below this field value, and TDMAE = 1.</description>
	<bitRange>[4:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>I2C_ENABLE_REG</name>
	<description>I2C Enable Register</description>
	<addressOffset>0x0000006c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0xffffffff</resetMask>
	<fields><field>
	<name>I2C_TX_CMD_BLOCK</name>
	<description>In Master mode:
1 = Blocks the transmission of data on I2C bus even if Tx FIFO has data to transmit.
0 = The transmission of data starts on I2C bus automatically, as soon as the first data is available in the Tx FIFO. </description>
	<bitRange>[2:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>I2C_ABORT</name>
	<description>The software can abort the I2C transfer in master mode by setting this bit. The software can set this bit only when ENABLE is already set; otherwise, the controller ignores any write to ABORT bit. The software cannot clear the ABORT bit once set. In response to an ABORT, the controller issues a STOP and flushes the Tx FIFO after completing the current transfer, then sets the TX_ABORT interrupt after the abort operation. The ABORT bit is cleared automatically after the abort operation. </description>
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>I2C_EN</name>
	<description>Controls whether the controller is enabled.
0 = Disables the controller (TX and RX FIFOs are held in an erased state)
1 = Enables the controller
Software can disable the controller while it is active. However, it is important that care be taken to ensure that the controller is disabled properly. When the controller is disabled, the following occurs:
* The TX FIFO and RX FIFO get flushed.
* Status bits in the IC_INTR_STAT register are still active until the controller goes into IDLE state.
If the module is transmitting, it stops as well as deletes the contents of the transmit buffer after the current transfer is complete. If the module is receiving, the controller stops the current transfer at the end of the current byte and does not acknowledge the transfer.
There is a two ic_clk delay when enabling or disabling the controller </description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>I2C_ENABLE_STATUS_REG</name>
	<description>I2C Enable Status Register</description>
	<addressOffset>0x0000009c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>SLV_RX_DATA_LOST</name>
	<description>Slave Received Data Lost. This bit indicates if a Slave-Receiver operation has been aborted with at least one data byte received from an I2C transfer due to the setting of IC_ENABLE from 1 to 0. When read as 1, the controller is deemed to have been actively engaged in an aborted I2C transfer (with matching address) and the data phase of the I2C transfer has been entered, even though a data byte has been responded with a NACK. NOTE: If the remote I2C master terminates the transfer with a STOP condition before the controller has a chance to NACK a transfer, and IC_ENABLE has been set to 0, then this bit is also set to 1. When read as 0, the controller is deemed to have been disabled without being actively involved in the data phase of a Slave-Receiver transfer.
NOTE: The CPU can safely read this bit when IC_EN (bit 0) is read as 0.
1 = Slave RX Data is lost
0 = Slave RX Data is not lost </description>
	<bitRange>[2:2]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>SLV_DISABLED_WHILE_BUSY</name>
	<description>Slave Disabled While Busy (Transmit, Receive). This bit indicates if a potential or active Slave operation has been aborted due to the setting of the IC_ENABLE register from 1 to 0. This bit is set when the CPU writes a 0 to the IC_ENABLE register while:
(a) I2C Ctrl is receiving the address byte of the Slave-Transmitter operation from a remote master; OR,
(b) address and data bytes of the Slave-Receiver operation from a remote master. When read as 1, the controller is deemed to have forced a NACK during any part of an I2C transfer, irrespective of whether the I2C address matches the slave address set in I2C Ctrl (IC_SAR register) OR if the transfer is completed before IC_ENABLE is set to 0 but has not taken effect.
NOTE: If the remote I2C master terminates the transfer with a STOP condition before the the controller has a chance to NACK a transfer, and IC_ENABLE has been set to 0, then this bit will also be set to 1.
When read as 0, the controller is deemed to have been disabled when there is master activity, or when the I2C bus is idle.
NOTE: The CPU can safely read this bit when IC_EN (bit 0) is read as 0.
1 = Slave is disabled when it is active
0 = Slave is disabled when it is idle </description>
	<bitRange>[1:1]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>IC_EN</name>
	<description>ic_en Status. This bit always reflects the value driven on the output port ic_en. When read as 1, the controller is deemed to be in an enabled state.
When read as 0, the controller is deemed completely inactive.
NOTE: The CPU can safely read this bit anytime. When this bit is read as 0, the CPU can safely read SLV_RX_DATA_LOST (bit 2) and SLV_DISABLED_WHILE_BUSY (bit 1).
1 = I2C enabled
0 = I2C disabled </description>
	<bitRange>[0:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>I2C_FS_SCL_HCNT_REG</name>
	<description>Fast Speed I2C Clock SCL High Count Register</description>
	<addressOffset>0x0000001c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x0000001a</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>IC_FS_SCL_HCNT</name>
	<description>This register must be set before any I2C bus transaction can take place to ensure proper I/O timing. This register sets the SCL clock high-period count for fast speed. It is used in high-speed mode to send the Master Code and START BYTE or General CALL. This register can be written only when the I2C interface is disabled, which corresponds to the I2C_ENABLE register being set to 0. Writes at other times have no effect.
The minimum valid value is 6; hardware prevents values less than this being written, and if attempted results in 6 being set. </description>
	<bitRange>[15:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>I2C_FS_SCL_LCNT_REG</name>
	<description>Fast Speed I2C Clock SCL Low Count Register</description>
	<addressOffset>0x00000020</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000032</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>IC_FS_SCL_LCNT</name>
	<description>This register must be set before any I2C bus transaction can take place to ensure proper I/O timing. This register sets the SCL clock low-period count for fast speed. It is used in high-speed mode to send the Master Code and START BYTE or General CALL. This register can be written only when the I2C interface is disabled, which corresponds to the I2C_ENABLE register being set to 0. Writes at other times have no effect.
The minimum valid value is 8; hardware prevents values less than this being written, and if attempted results in 8 being set. For designs with APB_DATA_WIDTH = 8 the order of programming is important to ensure the correct operation of the controller. The lower byte must be programmed first. Then the upper byte is programmed. </description>
	<bitRange>[15:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>I2C_HS_MADDR_REG</name>
	<description>I2C High Speed Master Mode Code Address Register</description>
	<addressOffset>0x0000000c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000001</resetValue>
	<resetMask>0x00000007</resetMask>
	<fields><field>
	<name>I2C_IC_HS_MAR</name>
	<description>This bit field holds the value of the I2C HS mode master code. HS-mode master codes are reserved 8-bit codes (00001xxx) that are not used for slave addressing or other purposes. Each master has its unique master code; up to eight high-speed mode masters can be present on the same I2C bus system. Valid values are from 0 to 7. This register can be written only when the I2C interface is disabled, which corresponds to the IC_ENABLE[0] register being set to 0. Writes at other times have no effect.</description>
	<bitRange>[2:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>I2C_HS_SCL_HCNT_REG</name>
	<description>High Speed I2C Clock SCL High Count Register</description>
	<addressOffset>0x00000024</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000006</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>IC_HS_SCL_HCNT</name>
	<description>This register must be set before any I2C bus transaction can take place to ensure proper I/O timing. This register sets the SCL clock high period count for high speed.refer to &quot;IC_CLK Frequency Configuration&quot;.
The SCL High time depends on the loading of the bus. For 100 pF loading, the SCL High time is 60 ns; for 400 pF loading, the SCL High time is 120 ns. This register goes away and becomes read-only returning 0 s if IC_MAX_SPEED_MODE != high.
This register can be written only when the I2C interface is disabled, which corresponds to the IC_ENABLE[0] register being set to 0. Writes at other times have no effect.
The minimum valid value is 6; hardware prevents values less than this being written, and if attempted results in 6 being set. For designs with APB_DATA_WIDTH = 8 the order of programming is important to ensure the correct operation of the DW_apb_i2c. The lower byte must be programmed first. Then the upper byte is programmed. </description>
	<bitRange>[15:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>I2C_HS_SCL_LCNT_REG</name>
	<description>High Speed I2C Clock SCL Low Count Register</description>
	<addressOffset>0x00000028</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000010</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>IC_HS_SCL_LCNT</name>
	<description>This register must be set before any I2C bus transaction can take place to ensure proper I/O timing. This register sets the SCL clock low period count for high speed. For more information, refer to &quot;IC_CLK Frequency Configuration&quot;.
The SCL low time depends on the loading of the bus. For 100 pF loading, the SCL low time is 160 ns; for 400 pF loading, the SCL low time is 320 ns. This register goes away and becomes read-only returning 0s if IC_MAX_SPEED_MODE != high.
This register can be written only when the I2C interface is disabled, which corresponds to the IC_ENABLE[0] register being set to 0. Writes at other times have no effect.
The minimum valid value is 8; hardware prevents values less than this being written, and if attempted results in 8 being set. For designs with APB_DATA_WIDTH == 8 the order of programming is important to ensure the correct operation of the DW_apb_i2c. The lower byte must be programmed first. Then the upper byte is programmed. If the value is less than 8 then the count value gets changed to 8. </description>
	<bitRange>[15:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>I2C_IC_FS_SPKLEN_REG</name>
	<description>I2C SS and FS spike suppression limit Size</description>
	<addressOffset>0x000000a0</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000001</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>I2C_FS_SPKLEN</name>
	<description>This register must be set before any I2C bus transaction can take place to ensure stable operation. This register sets the duration, measured in ic_clk cycles, of the longest spike in the SCL or SDA lines that will be filtered out by the spike suppression logic. This register can be written only when the I2C interface is disabled which corresponds to the IC_ENABLE register being set to 0. Writes at other times have no effect. The minimum valid value is 1; hardware prevents values less than this being written, and if attempted results in 1 being set. </description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>I2C_IC_HS_SPKLEN_REG</name>
	<description>I2C HS spike suppression limit Size</description>
	<addressOffset>0x000000a4</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000001</resetValue>
	<resetMask>0x000000ff</resetMask>
	<fields><field>
	<name>I2C_HS_SPKLEN</name>
	<description>This register must be set before any I2C bus transaction can take place to ensure stable operation. This register sets the duration, measured in ic_clk cycles, of the longest spike in the SCL or SDA lines that will be filtered out by the spike suppression logic. This register can be written only when the I2C interface is disabled which corresponds to the IC_ENABLE[0] register being set to 0. Writes at other times have no effect.
The minimum valid value is 1; hardware prevents values less than this being written, and if attempted results in 1 being set.</description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>I2C_INTR_MASK_REG</name>
	<description>I2C Interrupt Mask Register</description>
	<addressOffset>0x00000030</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x000008ff</resetValue>
	<resetMask>0xffffffff</resetMask>
	<fields><field>
	<name>M_SCL_STUCK_AT_LOW</name>
	<description>M_SCL_STUCK_AT_LOW Register field Reserved bits</description>
	<bitRange>[14:14]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>M_MASTER_ON_HOLD</name>
	<description>These bits mask their corresponding interrupt status bits in the I2C_INTR_STAT register.</description>
	<bitRange>[13:13]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>M_RESTART_DET</name>
	<description>These bits mask their corresponding interrupt status bits in the I2C_INTR_STAT register.</description>
	<bitRange>[12:12]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>M_GEN_CALL</name>
	<description>These bits mask their corresponding interrupt status bits in the I2C_INTR_STAT register. </description>
	<bitRange>[11:11]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>M_START_DET</name>
	<description>These bits mask their corresponding interrupt status bits in the I2C_INTR_STAT register. </description>
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>M_STOP_DET</name>
	<description>These bits mask their corresponding interrupt status bits in the I2C_INTR_STAT register. </description>
	<bitRange>[9:9]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>M_ACTIVITY</name>
	<description>These bits mask their corresponding interrupt status bits in the I2C_INTR_STAT register. </description>
	<bitRange>[8:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>M_RX_DONE</name>
	<description>These bits mask their corresponding interrupt status bits in the I2C_INTR_STAT register. </description>
	<bitRange>[7:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>M_TX_ABRT</name>
	<description>These bits mask their corresponding interrupt status bits in the I2C_INTR_STAT register. </description>
	<bitRange>[6:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>M_RD_REQ</name>
	<description>These bits mask their corresponding interrupt status bits in the I2C_INTR_STAT register. </description>
	<bitRange>[5:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>M_TX_EMPTY</name>
	<description>These bits mask their corresponding interrupt status bits in the I2C_INTR_STAT register. </description>
	<bitRange>[4:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>M_TX_OVER</name>
	<description>These bits mask their corresponding interrupt status bits in the I2C_INTR_STAT register. </description>
	<bitRange>[3:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>M_RX_FULL</name>
	<description>These bits mask their corresponding interrupt status bits in the I2C_INTR_STAT register. </description>
	<bitRange>[2:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>M_RX_OVER</name>
	<description>These bits mask their corresponding interrupt status bits in the I2C_INTR_STAT register. </description>
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>M_RX_UNDER</name>
	<description>These bits mask their corresponding interrupt status bits in the I2C_INTR_STAT register. </description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>I2C_INTR_STAT_REG</name>
	<description>I2C Interrupt Status Register</description>
	<addressOffset>0x0000002c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0xffffffff</resetMask>
	<fields><field>
	<name>R_SCL_STUCK_AT_LOW</name>
	<description>1 = R_SCL_STUCK_AT_LOW interrupt is active
0 = R_SCL_STUCK_AT_LOW interrupt is inactive </description>
	<bitRange>[14:14]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>R_MASTER_ON_HOLD</name>
	<description>Indicates whether master is holding the bus and TX FIFO is empty. Enabled only when I2C_DYNAMIC_TAR_UPDATE = 1 and IC_EMPTYFIFO_HOLD_MASTER_EN = 1. </description>
	<bitRange>[13:13]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>R_RESTART_DET</name>
	<description>Indicates whether a RESTART condition has occurred on the I2C interface when DW_apb_i2c is operating in Slave mode and the slave is being addressed.
Enabled only when IC_SLV_RESTART_DET_EN = 1.
Note: However, in high-speed mode or during a START BYTE transfer, the RESTART comes before the address field as per the I2C protocol. In this case, the slave is not the addressed slave when the RESTART is issued, therefore DW_apb_i2c does not generate the RESTART_DET interrupt. </description>
	<bitRange>[12:12]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>R_GEN_CALL</name>
	<description>Set only when a General Call address is received and it is acknowledged. It stays set until it is cleared either by disabling controller or when the CPU reads bit 0 of the I2C_CLR_GEN_CALL register. The controller stores the received data in the Rx buffer. </description>
	<bitRange>[11:11]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>R_START_DET</name>
	<description>Indicates whether a START or RESTART condition has occurred on the I2C interface regardless of whether controller is operating in slave or master mode. </description>
	<bitRange>[10:10]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>R_STOP_DET</name>
	<description>Indicates whether a STOP condition has occurred on the I2C interface regardless of whether controller is operating in slave or master mode. </description>
	<bitRange>[9:9]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>R_ACTIVITY</name>
	<description>This bit captures I2C Ctrl activity and stays set until it is cleared. There are four ways to clear it:
- Disabling the I2C Ctrl
- Reading the IC_CLR_ACTIVITY register
- Reading the IC_CLR_INTR register
- System reset
Once this bit is set, it stays set unless one of the four methods is used to clear it. Even if the controller module is idle, this bit remains set until cleared, indicating that there was activity on the bus. </description>
	<bitRange>[8:8]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>R_RX_DONE</name>
	<description>When the controller is acting as a slave-transmitter, this bit is set to 1 if the master does not acknowledge a transmitted byte. This occurs on the last byte of the transmission, indicating that the transmission is done. </description>
	<bitRange>[7:7]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>R_TX_ABRT</name>
	<description>This bit indicates if the controller, as an I2C transmitter, is unable to complete the intended actions on the contents of the transmit FIFO. This situation can occur both as an I2C master or an I2C slave, and is referred to as a &quot;transmit abort&quot;.
When this bit is set to 1, the I2C_TX_ABRT_SOURCE register indicates the reason why the transmit abort takes places.
NOTE: The controller flushes/resets/empties the TX FIFO whenever this bit is set. The TX FIFO remains in this flushed state until the register I2C_CLR_TX_ABRT is read. Once this read is performed, the TX FIFO is then ready to accept more data bytes from the APB interface. </description>
	<bitRange>[6:6]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>R_RD_REQ</name>
	<description>This bit is set to 1 when the controller is acting as a slave and another I2C master is attempting to read data from the controller. The controller holds the I2C bus in a wait state (SCL = 0) until this interrupt is serviced, which means that the slave has been addressed by a remote master that is asking for data to be transferred. The processor must respond to this interrupt and then write the requested data to the I2C_DATA_CMD register. This bit is set to 0 just after the processor reads the I2C_CLR_RD_REQ register </description>
	<bitRange>[5:5]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>R_TX_EMPTY</name>
	<description>This bit is set to 1 when the transmit buffer is at or below the threshold value set in the I2C_TX_TL register. It is automatically cleared by hardware when the buffer level goes above the threshold. When the IC_ENABLE bit 0 is 0, the TX FIFO is flushed and held in reset. There the TX FIFO looks like it has no data within it, so this bit is set to 1, provided there is activity in the master or slave state machines. When there is no longer activity, then with ic_en = 0, this bit is set to 0. </description>
	<bitRange>[4:4]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>R_TX_OVER</name>
	<description>Set during transmit if the transmit buffer is filled to 32 and the processor attempts to issue another I2C command by writing to the IC_DATA_CMD register. When the module is disabled, this bit keeps its level until the master or slave state machines go into idle, and when ic_en goes to 0, this interrupt is cleared </description>
	<bitRange>[3:3]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>R_RX_FULL</name>
	<description>Set when the receive buffer reaches or goes above the RX_TL threshold in the I2C_RX_TL register. It is automatically cleared by hardware when buffer level goes below the threshold. If the module is disabled (I2C_ENABLE[0] = 0), the RX FIFO is flushed and held in reset; therefore the RX FIFO is not full. So this bit is cleared once the I2C_ENABLE bit 0 is programmed with a 0, regardless of the activity that continues. </description>
	<bitRange>[2:2]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>R_RX_OVER</name>
	<description>Set if the receive buffer is completely filled to 32 and an additional byte is received from an external I2C device. The controller acknowledges this, but any data bytes received after the FIFO is full are lost. If the module is disabled (I2C_ENABLE[0] = 0), this bit keeps its level until the master or slave state machines go into idle, and when ic_en goes to 0, this interrupt is cleared. </description>
	<bitRange>[1:1]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>R_RX_UNDER</name>
	<description>Set if the processor attempts to read the receive buffer when it is empty by reading from the IC_DATA_CMD register. If the module is disabled (I2C_ENABLE[0] = 0), this bit keeps its level until the master or slave state machines go into idle, and when ic_en goes to 0, this interrupt is cleared. </description>
	<bitRange>[0:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>I2C_RAW_INTR_STAT_REG</name>
	<description>I2C Raw Interrupt Status Register</description>
	<addressOffset>0x00000034</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0xffffffff</resetMask>
	<fields><field>
	<name>SCL_STUCK_AT_LOW</name>
	<description>CL_STUCK_AT_LOW Register field Reserved bits</description>
	<bitRange>[14:14]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>MASTER_ON_HOLD</name>
	<description>Indicates whether master is holding the bus and TX FIFO is empty. Enabled only when I2C_DYNAMIC_TAR_UPDATE = 1 and IC_EMPTYFIFO_HOLD_MASTER_EN = 1. </description>
	<bitRange>[13:13]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>RESTART_DET</name>
	<description>Indicates whether a RESTART condition has occurred on the I2C interface when DW_apb_i2c is operating in Slave mode and the slave is being addressed.
Enabled only when IC_SLV_RESTART_DET_EN=1.
Note: However, in high-speed mode or during a START BYTE transfer, the RESTART comes before the address field as per the I2C protocol. In this case, the slave is not the addressed slave when the RESTART is issued, therefore DW_apb_i2c does not generate the RESTART_DET interrupt. </description>
	<bitRange>[12:12]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>GEN_CALL</name>
	<description>Set only when a General Call address is received and it is acknowledged. It stays set until it is cleared either by disabling controller or when the CPU reads bit 0 of the I2C_CLR_GEN_CALL register. I2C Ctrl stores the received data in the Rx buffer. </description>
	<bitRange>[11:11]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>START_DET</name>
	<description>Indicates whether a START or RESTART condition has occurred on the I2C interface regardless of whether controller is operating in slave or master mode. </description>
	<bitRange>[10:10]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>STOP_DET</name>
	<description>Indicates whether a STOP condition has occurred on the I2C interface regardless of whether controller is operating in slave or master mode. </description>
	<bitRange>[9:9]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>ACTIVITY</name>
	<description>This bit captures I2C Ctrl activity and stays set until it is cleared. There are four ways to clear it:
- Disabling the I2C Ctrl
- Reading the IC_CLR_ACTIVITY register
- Reading the IC_CLR_INTR register
- System reset
Once this bit is set, it stays set unless one of the four methods is used to clear it. Even if the controller module is idle, this bit remains set until cleared, indicating that there was activity on the bus. </description>
	<bitRange>[8:8]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>RX_DONE</name>
	<description>When the controller is acting as a slave-transmitter, this bit is set to 1 if the master does not acknowledge a transmitted byte. This occurs on the last byte of the transmission, indicating that the transmission is done. </description>
	<bitRange>[7:7]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>TX_ABRT</name>
	<description>This bit indicates if the controller, as an I2C transmitter, is unable to complete the intended actions on the contents of the transmit FIFO. This situation can occur both as an I2C master or an I2C slave, and is referred to as a &quot;transmit abort&quot;.
When this bit is set to 1, the I2C_TX_ABRT_SOURCE register indicates the reason why the transmit abort takes places.
NOTE: The controller flushes/resets/empties the TX FIFO whenever this bit is set. The TX FIFO remains in this flushed state until the register I2C_CLR_TX_ABRT is read. Once this read is performed, the TX FIFO is then ready to accept more data bytes from the APB interface. </description>
	<bitRange>[6:6]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>RD_REQ</name>
	<description>This bit is set to 1 when I2C Ctrl is acting as a slave and another I2C master is attempting to read data from the controller. The controller holds the I2C bus in a wait state (SCL = 0) until this interrupt is serviced, which means that the slave has been addressed by a remote master that is asking for data to be transferred. The processor must respond to this interrupt and then write the requested data to the I2C_DATA_CMD register. This bit is set to 0 just after the processor reads the I2C_CLR_RD_REQ register </description>
	<bitRange>[5:5]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>TX_EMPTY</name>
	<description>This bit is set to 1 when the transmit buffer is at or below the threshold value set in the I2C_TX_TL register. It is automatically cleared by hardware when the buffer level goes above the threshold. When the IC_ENABLE bit 0 is 0, the TX FIFO is flushed and held in reset. There the TX FIFO looks like it has no data within it, so this bit is set to 1, provided there is activity in the master or slave state machines. When there is no longer activity, then with ic_en = 0, this bit is set to 0. </description>
	<bitRange>[4:4]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>TX_OVER</name>
	<description>Set during transmit if the transmit buffer is filled to 32 and the processor attempts to issue another I2C command by writing to the IC_DATA_CMD register. When the module is disabled, this bit keeps its level until the master or slave state machines go into idle, and when ic_en goes to 0, this interrupt is cleared </description>
	<bitRange>[3:3]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>RX_FULL</name>
	<description>Set when the receive buffer reaches or goes above the RX_TL threshold in the I2C_RX_TL register. It is automatically cleared by hardware when buffer level goes below the threshold. If the module is disabled (I2C_ENABLE[0] = 0), the RX FIFO is flushed and held in reset; therefore the RX FIFO is not full. So this bit is cleared once the I2C_ENABLE bit 0 is programmed with a 0, regardless of the activity that continues. </description>
	<bitRange>[2:2]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>RX_OVER</name>
	<description>Set if the receive buffer is completely filled to 32 and an additional byte is received from an external I2C device. The controller acknowledges this, but any data bytes received after the FIFO is full are lost. If the module is disabled (I2C_ENABLE[0] = 0), this bit keeps its level until the master or slave state machines go into idle, and when ic_en goes to 0, this interrupt is cleared. </description>
	<bitRange>[1:1]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>RX_UNDER</name>
	<description>Set if the processor attempts to read the receive buffer when it is empty by reading from the IC_DATA_CMD register. If the module is disabled (I2C_ENABLE[0] = 0), this bit keeps its level until the master or slave state machines go into idle, and when ic_en goes to 0, this interrupt is cleared. </description>
	<bitRange>[0:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>I2C_RXFLR_REG</name>
	<description>I2C Receive FIFO Level Register</description>
	<addressOffset>0x00000078</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0xffffffff</resetMask>
	<fields><field>
	<name>RXFLR</name>
	<description>Receive FIFO Level. Contains the number of valid data entries in the receive FIFO. Size is constrained by the RXFLR value </description>
	<bitRange>[5:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>I2C_RX_TL_REG</name>
	<description>I2C Receive FIFO Threshold Register</description>
	<addressOffset>0x00000038</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0xffffffff</resetMask>
	<fields><field>
	<name>RX_TL</name>
	<description>Receive FIFO Threshold Level Controls the level of entries (or above) that triggers the RX_FULL interrupt (bit 2 in I2C_RAW_INTR_STAT register). The valid range is 0-31, with the additional restriction that hardware does not allow this value to be set to a value larger than the depth of the buffer. If an attempt is made to do that, the actual value set will be the maximum depth of the buffer. A value of 0 sets the threshold for 1 entry, and a value of 31 sets the threshold for 32 entries. </description>
	<bitRange>[4:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>I2C_SAR_REG</name>
	<description>I2C Slave Address Register</description>
	<addressOffset>0x00000008</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000055</resetValue>
	<resetMask>0xffffffff</resetMask>
	<fields><field>
	<name>IC_SAR</name>
	<description>The IC_SAR holds the slave address when the I2C is operating as a slave. For 7-bit addressing, only IC_SAR[6:0] is used. This register can be written only when the I2C interface is disabled, which corresponds to the IC_ENABLE register being set to 0. Writes at other times have no effect.
Writes to this register succeed only when IC_ENABLE[0] is set to 0.</description>
	<bitRange>[9:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>I2C_SDA_HOLD_REG</name>
	<description>I2C SDA Hold Time Length Register</description>
	<addressOffset>0x0000007c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000001</resetValue>
	<resetMask>0x00ffffff</resetMask>
	<fields><field>
	<name>I2C_SDA_RX_HOLD</name>
	<description>Sets the required SDA hold time in units of ic_clk period, when receiver. </description>
	<bitRange>[23:16]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>I2C_SDA_TX_HOLD</name>
	<description>Sets the required SDA hold time in units of ic_clk period, when transmitter. </description>
	<bitRange>[15:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>I2C_SDA_SETUP_REG</name>
	<description>I2C SDA Setup Register</description>
	<addressOffset>0x00000094</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000064</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>SDA_SETUP</name>
	<description>SDA Setup.
This register controls the amount of time delay (number of I2C clock periods) between the rising edge of SCL and SDA changing by holding SCL low when I2C block services a read request while operating as a slave-transmitter. The relevant I2C requirement is tSU:DAT (note 4) as detailed in the I2C Bus Specification. This register must be programmed with a value equal to or greater than 2.
It is recommended that if the required delay is 1000ns, then for an I2C frequency of 10 MHz, IC_SDA_SETUP should be programmed to a value of 11.Writes to this register succeed only when IC_ENABLE[0] = 0.</description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>I2C_SS_SCL_HCNT_REG</name>
	<description>Standard Speed I2C Clock SCL High Count Register</description>
	<addressOffset>0x00000014</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000091</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>IC_SS_SCL_HCNT</name>
	<description>This register must be set before any I2C bus transaction can take place to ensure proper I/O timing. This register sets the SCL clock high-period count for standard speed. This register can be written only when the I2C interface is disabled which corresponds to the IC_ENABLE register being set to 0. Writes at other times have no effect.
The minimum valid value is 6; hardware prevents values less than this being written, and if attempted results in 6 being set.
NOTE: This register must not be programmed to a value higher than 65525, because the controller uses a 16-bit counter to flag an I2C bus idle condition when this counter reaches a value of IC_SS_SCL_HCNT + 10. </description>
	<bitRange>[15:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>I2C_SS_SCL_LCNT_REG</name>
	<description>Standard Speed I2C Clock SCL Low Count Register</description>
	<addressOffset>0x00000018</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x000000ab</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>IC_SS_SCL_LCNT</name>
	<description>This register must be set before any I2C bus transaction can take place to ensure proper I/O timing. This register sets the SCL clock low period count for standard speed.
This register can be written only when the I2C interface is disabled which corresponds to the I2C_ENABLE register being set to 0. Writes at other times have no effect.
The minimum valid value is 8; hardware prevents values less than this being written, and if attempted, results in 8 being set. </description>
	<bitRange>[15:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>I2C_STATUS_REG</name>
	<description>I2C Status Register</description>
	<addressOffset>0x00000070</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000006</resetValue>
	<resetMask>0xffffffff</resetMask>
	<fields><field>
	<name>LV_HOLD_RX_FIFO_FULL</name>
	<description>This bit indicates the BUS Hold in Slave mode due to Rx FIFO is Full and an additional byte has been received
1 = Slave holds the bus due to Rx FIFO is full
0 = Slave is not holding the bus or Bus hold is not due to Rx FIFO is full </description>
	<bitRange>[10:10]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>SLV_HOLD_TX_FIFO_EMPTY</name>
	<description>This bit indicates the BUS Hold in Slave mode for the Read request when the Tx FIFO is empty. The Bus is in hold until the Tx FIFO has data to Transmit for the read request.
1 = Slave holds the bus due to Tx FIFO is empty
0 = Slave is not holding the bus or Bus hold is not due to Tx FIFO is empty </description>
	<bitRange>[9:9]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>MST_HOLD_RX_FIFO_FULL</name>
	<description>This bit indicates the BUS Hold in Master mode due to Rx FIFO is Full and additional byte has been received
1 = Master holds the bus due to Rx FIFO is full
0 = Master is not holding the bus or Bus hold is not due to Rx FIFO is full </description>
	<bitRange>[8:8]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>MST_HOLD_TX_FIFO_EMPTY</name>
	<description>the DW_apb_i2c master stalls the write transfer when Tx FIFO is empty, and the the last byte does not have the Stop bit set. This bit indicates the BUS hold when the master holds the bus because of the Tx FIFO being empty, and the the previous transferred command does not have the Stop bit set.
1 =Master holds the bus due to Tx FIFO is empty
0 =Master is not holding the bus or Bus hold is not due to Tx FIFO is empty </description>
	<bitRange>[7:7]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>SLV_ACTIVITY</name>
	<description>Slave FSM Activity Status. When the Slave Finite State Machine (FSM) is not in the IDLE state, this bit is set.
0 = Slave FSM is in IDLE state so the Slave part of the controller is not Active
1 = Slave FSM is not in IDLE state so the Slave part of the controller is Active </description>
	<bitRange>[6:6]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>MST_ACTIVITY</name>
	<description>Master FSM Activity Status. When the Master Finite State Machine (FSM) is not in the IDLE state, this bit is set.
0 = Master FSM is in IDLE state so the Master part of the controller is not Active
1 = Master FSM is not in IDLE state so the Master part of the controller is Active </description>
	<bitRange>[5:5]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>RFF</name>
	<description>Receive FIFO Completely Full. When the receive FIFO is completely full, this bit is set. When the receive FIFO contains one or more empty location, this bit is cleared.
0 = Receive FIFO is not full
1 = Receive FIFO is full </description>
	<bitRange>[4:4]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>RFNE</name>
	<description>Receive FIFO Not Empty. This bit is set when the receive FIFO contains one or more entries; it is cleared when the receive FIFO is empty.
0 = Receive FIFO is empty
1 = Receive FIFO is not empty </description>
	<bitRange>[3:3]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>TFE</name>
	<description>Transmit FIFO Completely Empty. When the transmit FIFO is completely empty, this bit is set. When it contains one or more valid entries, this bit is cleared. This bit field does not request an interrupt.
0 = Transmit FIFO is not empty
1 = Transmit FIFO is empty </description>
	<bitRange>[2:2]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>TFNF</name>
	<description>Transmit FIFO Not Full. Set when the transmit FIFO contains one or more empty locations, and is cleared when the FIFO is full.
0 = Transmit FIFO is full
1 = Transmit FIFO is not full </description>
	<bitRange>[1:1]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>I2C_ACTIVITY</name>
	<description>I2C Activity Status. </description>
	<bitRange>[0:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>I2C_TAR_REG</name>
	<description>I2C Target Address Register</description>
	<addressOffset>0x00000004</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000055</resetValue>
	<resetMask>0xffffffff</resetMask>
	<fields><field>
	<name>SPECIAL</name>
	<description>On read
This bit indicates whether software performs a General Call or START BYTE command.
0 = Ignore bit 10 GC_OR_START and use IC_TAR normally
1 = Perform special I2C command as specified in GC_OR_START bit
On write
1 = Enables programming of GENERAL_CALL or START_BYTE transmission
0 = Disables programming of GENERAL_CALL or START_BYTE transmission
Writes to this register succeed only when IC_ENABLE[0] is set to 0.</description>
	<bitRange>[11:11]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>GC_OR_START</name>
	<description>On read
If bit 11 (SPECIAL) is set to 1, then this bit indicates whether a General Call or START byte command is to be performed by the controller.
0 = General Call Address - after issuing a General Call, only writes may be performed. Attempting to issue a read command results in setting bit 6 (TX_ABRT) of the IC_RAW_INTR_STAT register. The controller remains in General Call mode until the SPECIAL bit value (bit 11) is cleared.
1 = START BYTE
On write
1 = START byte transmission
0 = GENERAL_CALL byte transmission
Writes to this register succeed only when IC_ENABLE[0] is set to 0.</description>
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>IC_TAR</name>
	<description>This is the target address for any master transaction. When transmitting a General Call, these bits are ignored. To generate a START BYTE, the CPU needs to write only once into these bits.
Note: If the IC_TAR and IC_SAR are the same, loopback exists but the FIFOs are shared between master and slave, so full loopback is not feasible. Only one direction loopback mode is supported (simplex), not duplex. A master cannot transmit to itself; it can transmit to only a slave
Writes to this register succeed only when IC_ENABLE[0] is set to 0.</description>
	<bitRange>[9:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>I2C_TXFLR_REG</name>
	<description>I2C Transmit FIFO Level Register</description>
	<addressOffset>0x00000074</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0xffffffff</resetMask>
	<fields><field>
	<name>TXFLR</name>
	<description>Transmit FIFO Level. Contains the number of valid data entries in the transmit FIFO. Size is constrained by the TXFLR value </description>
	<bitRange>[5:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>I2C_TX_ABRT_SOURCE_REG</name>
	<description>I2C Transmit Abort Source Register</description>
	<addressOffset>0x00000080</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0001ffff</resetMask>
	<fields><field>
	<name>ABRT_USER_ABRT</name>
	<description>Master-Transmitter : This is a master-mode-only bit. Master has detected the transfer abort (IC_ENABLE[1]) </description>
	<bitRange>[16:16]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>ABRT_SLVRD_INTX</name>
	<description>Slave-Transmitter : When the processor side responds to a slave mode request for data to be transmitted to a remote master and user writes a 1 in CMD (bit 8) of 2IC_DATA_CMD register
1 = Slave trying to transmit to remote master in read mode
0 = Slave trying to transmit to remote master in read mode- scenario not present </description>
	<bitRange>[15:15]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>ABRT_SLV_ARBLOST</name>
	<description>Slave-Transmitter: Slave lost the bus while transmitting data to a remote master. I2C_TX_ABRT_SOURCE[12] is set at the same time. Note: Even though the slave never &quot;owns&quot; the bus, something could go wrong on the bus. This is a fail safe check. For instance, during a data transmission at the low-to-high transition of SCL, if what is on the data bus is not what is supposed to be transmitted, then the controller no longer own the bus.
1 = Slave lost arbitration to remote master
0 = Slave lost arbitration to remote master - scenario not present </description>
	<bitRange>[14:14]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>ABRT_SLVFLUSH_TXFIFO</name>
	<description>Slave-Transmitter: Slave has received a read command and some data exists in the TX FIFO so the slave issues a TX_ABRT interrupt to flush old data in TX FIFO.
1 = Slave flushes existing data in TX-FIFO upon getting read command
0 = Slave flushes existing data in TX-FIFO upon getting read command - scenario not present </description>
	<bitRange>[13:13]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>ARB_LOST</name>
	<description>Master-Transmitter or Slave-Transmitter: Master has lost arbitration, or if I2C_TX_ABRT_SOURCE[14] is also set, then the slave transmitter has lost arbitration. Note: I2C can be both master and slave at the same time.
1 = Master or Slave-Transmitter lost arbitration
0 = Master or Slave-Transmitter lost arbitration - scenario not present </description>
	<bitRange>[12:12]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>ABRT_MASTER_DIS</name>
	<description>Master-Transmitter or Master-Receiver: User tries to initiate a Master operation with the Master mode disabled.
1 = User intitating master operation when MASTER disabled
0 = User initiating master operation when MASTER disabled - scenario not present </description>
	<bitRange>[11:11]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>ABRT_10B_RD_NORSTRT</name>
	<description>Master-Receiver: The restart is disabled (IC_RESTART_EN bit (I2C_CON[5]) = 0) and the master sends a read command in 10-bit addressing mode.
1 =Master trying to read in 10Bit addressing mode when RESTART disabled
0 =Master not trying to read in 10Bit addressing mode when RESTART disabled </description>
	<bitRange>[10:10]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>ABRT_SBYTE_NORSTRT</name>
	<description>Master: To clear Bit 9, the source of the ABRT_SBYTE_NORSTRT must be fixed first; restart must be enabled (I2C_CON[5]=1), the SPECIAL bit must be cleared (I2C_TAR[11]), or the GC_OR_START bit must be cleared (I2C_TAR[10]). Once the source of the ABRT_SBYTE_NORSTRT is fixed, then this bit can be cleared in the same manner as other bits in this register. If the source of the ABRT_SBYTE_NORSTRT is not fixed before attempting to clear this bit, bit 9 clears for one cycle and then gets re-asserted. 1: The restart is disabled (IC_RESTART_EN bit (I2C_CON[5]) = 0) and the user is trying to send a START Byte.
1 = User trying to send START byte when RESTART disabled
0 = User trying to send START byte when RESTART disabled- scenario not present </description>
	<bitRange>[9:9]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>ABRT_HS_NORSTRT</name>
	<description>Master-Transmitter or Master-Receiver: The restart is disabled (IC_RESTART_EN bit (I2C_CON[5]) = 0) and the user is trying to use the master to transfer data in High Speed mode
1 = User trying to switch Master to HS mode when RESTART disabled
0 = User trying to switch Master to HS mode when RESTART disabled - scenario not present </description>
	<bitRange>[8:8]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>ABRT_SBYTE_ACKDET</name>
	<description>Master: Master has sent a START Byte and the START Byte was acknowledged (wrong behavior).
1 = ACK detected for START byte
0 = ACK detected for START byte - scenario not present </description>
	<bitRange>[7:7]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>ABRT_HS_ACKDET</name>
	<description>Master: Master is in High Speed mode and the High Speed Master code was acknowledged (wrong behavior).
1 = HS Master code ACKed in HS Mode
0 = HS Master code ACKed in HS Mode - scenario not present </description>
	<bitRange>[6:6]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>ABRT_GCALL_READ</name>
	<description>Master-Transmitter: The controller in master mode sent a General Call but the user programmed the byte following the General Call to be a read from the bus (IC_DATA_CMD[9] is set to 1).
1 = GCALL is followed by read from bus
0 = GCALL is followed by read from bus - scenario not present </description>
	<bitRange>[5:5]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>ABRT_GCALL_NOACK</name>
	<description>Master-Transmitter: The controller in master mode sent a General Call and no slave on the bus acknowledged the General Call.
1 = GCALL not ACKed by any slave
0 = GCALL not ACKed by any slave - scenario not present </description>
	<bitRange>[4:4]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>ABRT_TXDATA_NOACK</name>
	<description>Master-Transmitter: This is a master-mode only bit. Master has received an acknowledgement for the address, but when it sent data byte(s) following the address, it did not receive an acknowledge from the remote slave(s).
1 = Transmitted data not ACKed by addressed slave
0 = Transmitted data non-ACKed by addressed slave - scenario not present </description>
	<bitRange>[3:3]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>ABRT_10ADDR2_NOACK</name>
	<description>Master-Transmitter or Master-Receiver: Master is in 10-bit address mode and the second address byte of the 10-bit address was not acknowledged by any slave.
1 = Byte 2 of 10-bit Address not ACKed by any slave
0 = This abort is not generated </description>
	<bitRange>[2:2]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>ABRT_10ADDR1_NOACK</name>
	<description>Master-Transmitter or Master-Receiver: Master is in 10-bit address mode and the first 10-bit address byte was not acknowledged by any slave.
1 = Byte 1 of 10-bit Address not ACKed by any slave
0 =This abort is not generated </description>
	<bitRange>[1:1]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>ABRT_7B_ADDR_NOACK</name>
	<description>Master-Transmitter or Master-Receiver: Master is in 7-bit addressing mode and the address sent was not acknowledged by any slave.
1 = This abort is generated because of NOACK for 7-bit address
0 = This abort is not generated </description>
	<bitRange>[0:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>I2C_TX_TL_REG</name>
	<description>I2C Transmit FIFO Threshold Register</description>
	<addressOffset>0x0000003c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0xffffffff</resetMask>
	<fields><field>
	<name>TX_TL</name>
	<description>Transmit FIFO Threshold Level Controls the level of entries (or below) that trigger the TX_EMPTY interrupt (bit 4 in I2C_RAW_INTR_STAT register). The valid range is 0-31, with the additional restriction that it may not be set to value larger than the depth of the buffer. If an attempt is made to do that, the actual value set will be the maximum depth of the buffer. A value of 0 sets the threshold for 0 entries, and a value of 31 sets the threshold for 32 entries. </description>
	<bitRange>[4:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register></registers>
</peripheral><peripheral>
	<name>MDCT</name>
	<version>1.0</version>
	<description>MDCT registers</description>
	<groupName>Peripheral_Registers</groupName>
	<baseAddress>0x50030400</baseAddress>
	<size>0</size>
	<addressBlock>
	<offset>0</offset>
	<size>52</size>
	<usage>registers</usage>
</addressBlock>

	<registers>
	<register>
	<name>MDCT_CTRL_REG</name>
	<description>MDCT control register</description>
	<addressOffset>0x00000000</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x80000000</resetValue>
	<resetMask>0xbfffffff</resetMask>
	<fields><field>
	<name>DONE</name>
	<description>Done flag
0: Operation in progress
1: Operation complete</description>
	<bitRange>[31:31]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>USE_CORDIC</name>
	<description>Select source for twiddle factors
0: Use table stored in Y buffer
1: Generate using CORDIC block</description>
	<bitRange>[29:29]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>IRQ_CLR</name>
	<description>Clear IRQ on writing 1.</description>
	<bitRange>[28:28]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>CLK_DIV</name>
	<description>Division factor for MDCT core. The source for the division is always the DIV1 CLK.
0x0: Clock disabled
0x1: Divide by 1
0x2: Divide by 2
0x3: Divide by 4 </description>
	<bitRange>[27:26]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>XFORM_SIZE</name>
	<description>Transform size (XFORM_SIZE = transform size - 1)</description>
	<bitRange>[25:16]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>Y_STRIDE</name>
	<description>Y buffer data stride (Y_STRIDE = stride - 1)</description>
	<bitRange>[15:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>WORD_SIZE</name>
	<description>Data size
0: 16-bit
1: 32-bit</description>
	<bitRange>[7:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>INVERSE</name>
	<description>Transform direction
0: Forward
1: Reverse (inverse)</description>
	<bitRange>[6:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>N_STAGES</name>
	<description>Number of transform stages.</description>
	<bitRange>[5:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>IRQ_EN</name>
	<description>MDCT IRQ enable.</description>
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>EN</name>
	<description>MDCT enable.</description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>MDCT_PHASE_INC_REG</name>
	<description>MDCT phase increment register for CORDIC</description>
	<addressOffset>0x00000030</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0xffffffff</resetMask>
	<fields><field>
	<name>PHASE_INC</name>
	<description>Phase increment used by CORDIC generator in Q1.31 unsigned fixed-point representation.
PHASE_INC = 2^32/XFORM_SIZE</description>
	<bitRange>[31:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>MDCT_STAGE0_REG</name>
	<description>MDCT stage 0 settings register</description>
	<addressOffset>0x00000010</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0xfffff7f7</resetMask>
	<fields><field>
	<name>STRIDE</name>
	<description>Stride (STRIDE = stride-1)</description>
	<bitRange>[31:22]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>M</name>
	<description>Sub-transform size (M = sub-transform size-1)</description>
	<bitRange>[21:12]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RADIX</name>
	<description>Radix of butterflies
0: Radix-2
1: Radix-3
2: Radix-4
3: Radix-5</description>
	<bitRange>[10:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>IN_ADDR_MODE</name>
	<description>Input addressing mode
0: Linear
1: Bit/digit reversed</description>
	<bitRange>[6:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>OUT_BUFFER</name>
	<description>Output buffer
0: X buffer
1: Z buffer</description>
	<bitRange>[5:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>IN_BUFFER</name>
	<description>Input buffer
0: X buffer
1: Z buffer</description>
	<bitRange>[4:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>MODE</name>
	<description>Mode
0: Disabled
1: Complex FFT
2: Real FFT
3: DCT (Type IV)
4: Window function
5-7: reserved</description>
	<bitRange>[2:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>MDCT_STAGE1_REG</name>
	<description>MDCT stage 1 settings register</description>
	<addressOffset>0x00000014</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0xfffff7f7</resetMask>
	<fields><field>
	<name>STRIDE</name>
	<description>Stride (STRIDE = stride-1)</description>
	<bitRange>[31:22]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>M</name>
	<description>Sub-transform size (M = sub-transform size-1)</description>
	<bitRange>[21:12]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RADIX</name>
	<description>Radix of butterflies
0: Radix-2
1: Radix-3
2: Radix-4
3: Radix-5</description>
	<bitRange>[10:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>IN_ADDR_MODE</name>
	<description>Input addressing mode
0: linear
1: bit/digit reversed</description>
	<bitRange>[6:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>OUT_BUFFER</name>
	<description>Output buffer
0: X buffer
1: Z buffer</description>
	<bitRange>[5:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>IN_BUFFER</name>
	<description>Input buffer
0: X buffer
1: Z buffer</description>
	<bitRange>[4:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>MODE</name>
	<description>Mode
0: Disabled
1: Complex FFT
2: Real FFT
3: DCT (Type IV)
4: Window function
5-7: reserved</description>
	<bitRange>[2:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>MDCT_STAGE2_REG</name>
	<description>MDCT stage 2 settings register</description>
	<addressOffset>0x00000018</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0xfffff7f7</resetMask>
	<fields><field>
	<name>STRIDE</name>
	<description>Stride (STRIDE = stride-1)</description>
	<bitRange>[31:22]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>M</name>
	<description>Sub-transform size (M = sub-transform size-1)</description>
	<bitRange>[21:12]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RADIX</name>
	<description>Radix of butterflies
0: Radix-2
1: Radix-3
2: Radix-4
3: Radix-5</description>
	<bitRange>[10:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>IN_ADDR_MODE</name>
	<description>Input addressing mode
0: Linear
1: Bit/digit reversed</description>
	<bitRange>[6:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>OUT_BUFFER</name>
	<description>Output buffer
0: X buffer
1: Z buffer</description>
	<bitRange>[5:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>IN_BUFFER</name>
	<description>Input buffer
0: X buffer
1: Z buffer</description>
	<bitRange>[4:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>MODE</name>
	<description>Mode
0: Disabled
1: Complex FFT
2: Real FFT
3: DCT (Type IV)
4: Window function
5-7: reserved</description>
	<bitRange>[2:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>MDCT_STAGE3_REG</name>
	<description>MDCT stage 3 settings register</description>
	<addressOffset>0x0000001c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0xfffff7f7</resetMask>
	<fields><field>
	<name>STRIDE</name>
	<description>Stride (STRIDE = stride-1)</description>
	<bitRange>[31:22]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>M</name>
	<description>Sub-transform size (M = sub-transform size-1)</description>
	<bitRange>[21:12]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RADIX</name>
	<description>Radix of butterflies
0: Radix-2
1: Radix-3
2: Radix-4
3: Radix-5</description>
	<bitRange>[10:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>IN_ADDR_MODE</name>
	<description>Input addressing mode
0: Linear
1: Bit/digit reversed</description>
	<bitRange>[6:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>OUT_BUFFER</name>
	<description>Output buffer
0: X buffer
1: Z buffer</description>
	<bitRange>[5:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>IN_BUFFER</name>
	<description>Input buffer
0: X buffer
1: Z buffer</description>
	<bitRange>[4:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>MODE</name>
	<description>Mode
0: Disabled
1: Complex FFT
2: Real FFT
3: DCT (Type IV)
4: Window function
5-7: reserved</description>
	<bitRange>[2:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>MDCT_STAGE4_REG</name>
	<description>MDCT stage 4 settings register</description>
	<addressOffset>0x00000020</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0xfffff7f7</resetMask>
	<fields><field>
	<name>STRIDE</name>
	<description>Stride (STRIDE = stride-1)</description>
	<bitRange>[31:22]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>M</name>
	<description>Sub-transform size (M = sub-transform size-1)</description>
	<bitRange>[21:12]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RADIX</name>
	<description>Radix of butterflies
0: Radix-2
1: Radix-3
2: Radix-4
3: Radix-5</description>
	<bitRange>[10:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>IN_ADDR_MODE</name>
	<description>Input addressing mode
0: Linear
1: Bit/digit reversed</description>
	<bitRange>[6:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>OUT_BUFFER</name>
	<description>Output buffer
0: X buffer
1: Z buffer</description>
	<bitRange>[5:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>IN_BUFFER</name>
	<description>Input buffer
0: X buffer
1: Z buffer</description>
	<bitRange>[4:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>MODE</name>
	<description>Mode
0: Disabled
1: Complex FFT
2: Real FFT
3: DCT (Type IV)
4: Window function
5-7: reserved</description>
	<bitRange>[2:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>MDCT_STAGE5_REG</name>
	<description>MDCT stage 5 settings register</description>
	<addressOffset>0x00000024</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0xfffff7f7</resetMask>
	<fields><field>
	<name>STRIDE</name>
	<description>Stride (STRIDE = stride-1)</description>
	<bitRange>[31:22]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>M</name>
	<description>Sub-transform size (M = sub-transform size-1)</description>
	<bitRange>[21:12]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RADIX</name>
	<description>Radix of butterflies
0: Radix-2
1: Radix-3
2: Radix-4
3: Radix-5</description>
	<bitRange>[10:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>IN_ADDR_MODE</name>
	<description>Input addressing mode
0: Linear
1: Bit/digit reversed</description>
	<bitRange>[6:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>OUT_BUFFER</name>
	<description>Output buffer
0: X buffer
1: Z buffer</description>
	<bitRange>[5:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>IN_BUFFER</name>
	<description>Input buffer
0: X buffer
1: Z buffer</description>
	<bitRange>[4:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>MODE</name>
	<description>Mode
0: Disabled
1: Complex FFT
2: Real FFT
3: DCT (Type IV)
4: Window function
5-7: reserved</description>
	<bitRange>[2:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>MDCT_STAGE6_REG</name>
	<description>MDCT stage 6 settings register</description>
	<addressOffset>0x00000028</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0xfffff7f7</resetMask>
	<fields><field>
	<name>STRIDE</name>
	<description>Stride (STRIDE = stride-1)</description>
	<bitRange>[31:22]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>M</name>
	<description>Sub-transform size (M = sub-transform size-1)</description>
	<bitRange>[21:12]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RADIX</name>
	<description>Radix of butterflies
0: Radix-2
1: Radix-3
2: Radix-4
3: Radix-5</description>
	<bitRange>[10:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>IN_ADDR_MODE</name>
	<description>Input addressing mode
0: Linear
1: Bit/digit reversed</description>
	<bitRange>[6:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>OUT_BUFFER</name>
	<description>Output buffer
0: X buffer
1: Z buffer</description>
	<bitRange>[5:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>IN_BUFFER</name>
	<description>Input buffer
0: X buffer
1: Z buffer</description>
	<bitRange>[4:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>MODE</name>
	<description>Mode
0: Disabled
1: Complex FFT
2: Real FFT
3: DCT (Type IV)
4: Window function
5-7: reserved</description>
	<bitRange>[2:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>MDCT_STAGE7_REG</name>
	<description>MDCT stage 7 settings register</description>
	<addressOffset>0x0000002c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0xfffff7f7</resetMask>
	<fields><field>
	<name>STRIDE</name>
	<description>Stride (STRIDE = stride-1)</description>
	<bitRange>[31:22]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>M</name>
	<description>Sub-transform size (M = sub-transform size-1)</description>
	<bitRange>[21:12]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RADIX</name>
	<description>Radix of butterflies
0: Radix-2
1: Radix-3
2: Radix-4
3: Radix-5</description>
	<bitRange>[10:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>IN_ADDR_MODE</name>
	<description>Input addressing mode
0: Linear
1: Bit/digit reversed</description>
	<bitRange>[6:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>OUT_BUFFER</name>
	<description>Output buffer
0: X buffer
1: Z buffer</description>
	<bitRange>[5:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>IN_BUFFER</name>
	<description>Input buffer
0: X buffer
1: Z buffer</description>
	<bitRange>[4:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>MODE</name>
	<description>Mode
0: Disabled
1: Complex FFT
2: Real FFT
3: DCT (Type IV)
4: Window function
5-7: reserved</description>
	<bitRange>[2:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>MDCT_XBASE_ADDR_REG</name>
	<description>MDCT X data base address register</description>
	<addressOffset>0x00000004</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0xffffffff</resetMask>
	<fields><field>
	<name>XBASE_ADDR</name>
	<description>X data base address.</description>
	<bitRange>[31:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>MDCT_YBASE_ADDR_REG</name>
	<description>MDCT Y data base address register</description>
	<addressOffset>0x00000008</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0xffffffff</resetMask>
	<fields><field>
	<name>YBASE_ADDR</name>
	<description>Y data base address.</description>
	<bitRange>[31:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>MDCT_ZBASE_ADDR_REG</name>
	<description>MDCT Z data base address register</description>
	<addressOffset>0x0000000c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0xffffffff</resetMask>
	<fields><field>
	<name>ZBASE_ADDR</name>
	<description>Z data base address.</description>
	<bitRange>[31:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register></registers>
</peripheral><peripheral>
	<name>MEMCTRL</name>
	<version>1.0</version>
	<description>MEMCTRL registers</description>
	<groupName>Peripheral_Registers</groupName>
	<baseAddress>0x50060000</baseAddress>
	<size>0</size>
	<addressBlock>
	<offset>0</offset>
	<size>128</size>
	<usage>registers</usage>
</addressBlock>

	<registers>
	<register>
	<name>BUSY_RESET_REG</name>
	<description>BSR Reset Register</description>
	<addressOffset>0x00000078</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0xffffffff</resetMask>
	<fields><field>
	<name>BUSY_SPARE</name>
	<description>Clear the BUSY bitfield, by writing the master code which has claimed to this field
Reading returns 0 to allow read/modify/write to the register.</description>
	<bitRange>[31:30]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>BUSY_SPARE1</name>
	<description>Clear the BUSY bitfield, by writing the master code which has claimed to this field
Reading returns 0 to allow read/modify/write to the register.</description>
	<bitRange>[29:28]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>BUSY_TIMER4</name>
	<description>Clear the BUSY bitfield, by writing the master code which has claimed to this field
Reading returns 0 to allow read/modify/write to the register.</description>
	<bitRange>[27:26]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>BUSY_TIMER3</name>
	<description>Clear the BUSY bitfield, by writing the master code which has claimed to this field
Reading returns 0 to allow read/modify/write to the register.</description>
	<bitRange>[25:24]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>BUSY_TIMER2</name>
	<description>Clear the BUSY bitfield, by writing the master code which has claimed to this field
Reading returns 0 to allow read/modify/write to the register.</description>
	<bitRange>[23:22]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>BUSY_TIMER</name>
	<description>Clear the BUSY bitfield, by writing the master code which has claimed to this field
Reading returns 0 to allow read/modify/write to the register.</description>
	<bitRange>[21:20]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>BUSY_PDM</name>
	<description>Clear the BUSY bitfield, by writing the master code which has claimed to this field
Reading returns 0 to allow read/modify/write to the register.</description>
	<bitRange>[19:18]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>BUSY_PCM</name>
	<description>Clear the BUSY bitfield, by writing the master code which has claimed to this field
Reading returns 0 to allow read/modify/write to the register.</description>
	<bitRange>[17:16]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>BUSY_SRC2</name>
	<description>Clear the BUSY bitfield, by writing the master code which has claimed to this field
Reading returns 0 to allow read/modify/write to the register.</description>
	<bitRange>[15:14]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>BUSY_SRC</name>
	<description>Clear the BUSY bitfield, by writing the master code which has claimed to this field
Reading returns 0 to allow read/modify/write to the register.</description>
	<bitRange>[13:12]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>BUSY_SDADC</name>
	<description>Clear the BUSY bitfield, by writing the master code which has claimed to this field
Reading returns 0 to allow read/modify/write to the register.</description>
	<bitRange>[11:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>BUSY_GPADC</name>
	<description>Clear the BUSY bitfield, by writing the master code which has claimed to this field
Reading returns 0 to allow read/modify/write to the register.</description>
	<bitRange>[9:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>BUSY_I2C</name>
	<description>Clear the BUSY bitfield, by writing the master code which has claimed to this field
Reading returns 0 to allow read/modify/write to the register.</description>
	<bitRange>[7:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>BUSY_SPI</name>
	<description>Clear the BUSY bitfield, by writing the master code which has claimed to this field
Reading returns 0 to allow read/modify/write to the register.</description>
	<bitRange>[5:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>BUSY_UART2</name>
	<description>Clear the BUSY bitfield, by writing the master code which has claimed to this field
Reading returns 0 to allow read/modify/write to the register.</description>
	<bitRange>[3:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>BUSY_UART</name>
	<description>Clear the BUSY bitfield, by writing the master code which has claimed to this field
Reading returns 0 to allow read/modify/write to the register.</description>
	<bitRange>[1:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>BUSY_SET_REG</name>
	<description>BSR Set Register</description>
	<addressOffset>0x00000074</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0xffffffff</resetMask>
	<fields><field>
	<name>BUSY_SPARE</name>
	<description>Writing a non-zero value to this field sets the corresponding BUSY bit, but only if it was not claimed (BUSY=0).
Reading returns 0 to allow read/modify/write to the register.</description>
	<bitRange>[31:30]</bitRange>
	<access>writeOnce</access>
	</field><field>
	<name>BUSY_SPARE1</name>
	<description>Writing a non-zero value to this field sets the corresponding BUSY bit, but only if it was not claimed (BUSY=0).
Reading returns 0 to allow read/modify/write to the register.</description>
	<bitRange>[29:28]</bitRange>
	<access>writeOnce</access>
	</field><field>
	<name>BUSY_TIMER4</name>
	<description>Writing a non-zero value to this field sets the corresponding BUSY bit, but only if it was not claimed (BUSY=0).
Reading returns 0 to allow read/modify/write to the register.</description>
	<bitRange>[27:26]</bitRange>
	<access>writeOnce</access>
	</field><field>
	<name>BUSY_TIMER3</name>
	<description>Writing a non-zero value to this field sets the corresponding BUSY bit, but only if it was not claimed (BUSY=0).
Reading returns 0 to allow read/modify/write to the register.</description>
	<bitRange>[25:24]</bitRange>
	<access>writeOnce</access>
	</field><field>
	<name>BUSY_TIMER2</name>
	<description>Writing a non-zero value to this field sets the corresponding BUSY bit, but only if it was not claimed (BUSY=0).
Reading returns 0 to allow read/modify/write to the register.</description>
	<bitRange>[23:22]</bitRange>
	<access>writeOnce</access>
	</field><field>
	<name>BUSY_TIMER</name>
	<description>Writing a non-zero value to this field sets the corresponding BUSY bit, but only if it was not claimed (BUSY=0).
Reading returns 0 to allow read/modify/write to the register.</description>
	<bitRange>[21:20]</bitRange>
	<access>writeOnce</access>
	</field><field>
	<name>BUSY_PDM</name>
	<description>Writing a non-zero value to this field sets the corresponding BUSY bit, but only if it was not claimed (BUSY=0).
Reading returns 0 to allow read/modify/write to the register.</description>
	<bitRange>[19:18]</bitRange>
	<access>writeOnce</access>
	</field><field>
	<name>BUSY_PCM</name>
	<description>Writing a non-zero value to this field sets the corresponding BUSY bit, but only if it was not claimed (BUSY=0).
Reading returns 0 to allow read/modify/write to the register.</description>
	<bitRange>[17:16]</bitRange>
	<access>writeOnce</access>
	</field><field>
	<name>BUSY_SRC2</name>
	<description>Writing a non-zero value to this field sets the corresponding BUSY bit, but only if it was not claimed (BUSY=0).
Reading returns 0 to allow read/modify/write to the register.</description>
	<bitRange>[15:14]</bitRange>
	<access>writeOnce</access>
	</field><field>
	<name>BUSY_SRC</name>
	<description>Writing a non-zero value to this field sets the corresponding BUSY bit, but only if it was not claimed (BUSY=0).
Reading returns 0 to allow read/modify/write to the register.</description>
	<bitRange>[13:12]</bitRange>
	<access>writeOnce</access>
	</field><field>
	<name>BUSY_SDADC</name>
	<description>Writing a non-zero value to this field sets the corresponding BUSY bit, but only if it was not claimed (BUSY=0).
Reading returns 0 to allow read/modify/write to the register.</description>
	<bitRange>[11:10]</bitRange>
	<access>writeOnce</access>
	</field><field>
	<name>BUSY_GPADC</name>
	<description>Writing a non-zero value to this field sets the corresponding BUSY bit, but only if it was not claimed (BUSY=0).
Reading returns 0 to allow read/modify/write to the register.</description>
	<bitRange>[9:8]</bitRange>
	<access>writeOnce</access>
	</field><field>
	<name>BUSY_I2C</name>
	<description>Writing a non-zero value to this field sets the corresponding BUSY bit, but only if it was not claimed (BUSY=0).
Reading returns 0 to allow read/modify/write to the register.</description>
	<bitRange>[7:6]</bitRange>
	<access>writeOnce</access>
	</field><field>
	<name>BUSY_SPI</name>
	<description>Writing a non-zero value to this field sets the corresponding BUSY bit, but only if it was not claimed (BUSY=0).
Reading returns 0 to allow read/modify/write to the register.</description>
	<bitRange>[5:4]</bitRange>
	<access>writeOnce</access>
	</field><field>
	<name>BUSY_UART2</name>
	<description>Writing a non-zero value to this field sets the corresponding BUSY bit, but only if it was not claimed (BUSY=0).
Reading returns 0 to allow read/modify/write to the register.</description>
	<bitRange>[3:2]</bitRange>
	<access>writeOnce</access>
	</field><field>
	<name>BUSY_UART</name>
	<description>Writing a non-zero value to this field sets the corresponding BUSY bit, but only if it was not claimed (BUSY=0).
Reading returns 0 to allow read/modify/write to the register.</description>
	<bitRange>[1:0]</bitRange>
	<access>writeOnce</access>
	</field></fields>
</register><register>
	<name>BUSY_STAT_REG</name>
	<description>BSR Status Register</description>
	<addressOffset>0x0000007c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0xffffffff</resetMask>
	<fields><field>
	<name>BUSY_SPARE</name>
	<description>A non-zero value indicates the resource is busy. The value represents which master is using it.</description>
	<bitRange>[31:30]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>BUSY_SPARE1</name>
	<description>A non-zero value indicates the resource is busy. The value represents which master is using it.</description>
	<bitRange>[29:28]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>BUSY_TIMER4</name>
	<description>A non-zero value indicates the resource is busy. The value represents which master is using it.</description>
	<bitRange>[27:26]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>BUSY_TIMER3</name>
	<description>A non-zero value indicates the resource is busy. The value represents which master is using it.</description>
	<bitRange>[25:24]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>BUSY_TIMER2</name>
	<description>A non-zero value indicates the resource is busy. The value represents which master is using it.</description>
	<bitRange>[23:22]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>BUSY_TIMER</name>
	<description>A non-zero value indicates the resource is busy. The value represents which master is using it.</description>
	<bitRange>[21:20]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>BUSY_PDM</name>
	<description>A non-zero value indicates the resource is busy. The value represents which master is using it.</description>
	<bitRange>[19:18]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>BUSY_PCM</name>
	<description>A non-zero value indicates the resource is busy. The value represents which master is using it.</description>
	<bitRange>[17:16]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>BUSY_SRC2</name>
	<description>A non-zero value indicates the resource is busy. The value represents which master is using it.</description>
	<bitRange>[15:14]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>BUSY_SRC</name>
	<description>A non-zero value indicates the resource is busy. The value represents which master is using it.</description>
	<bitRange>[13:12]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>BUSY_SDADC</name>
	<description>A non-zero value indicates the resource is busy. The value represents which master is using it.</description>
	<bitRange>[11:10]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>BUSY_GPADC</name>
	<description>A non-zero value indicates the resource is busy. The value represents which master is using it.</description>
	<bitRange>[9:8]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>BUSY_I2C</name>
	<description>A non-zero value indicates the resource is busy. The value represents which master is using it.</description>
	<bitRange>[7:6]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>BUSY_SPI</name>
	<description>A non-zero value indicates the resource is busy. The value represents which master is using it.</description>
	<bitRange>[5:4]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>BUSY_UART2</name>
	<description>A non-zero value indicates the resource is busy. The value represents which master is using it.</description>
	<bitRange>[3:2]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>BUSY_UART</name>
	<description>A non-zero value indicates the resource is busy. The value represents which master is using it.</description>
	<bitRange>[1:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>CMI_CODE_BASE_REG</name>
	<description>CMAC code Base Address Register</description>
	<addressOffset>0x00000020</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0007ffff</resetMask>
	<fields><field>
	<name>CMI_CODE_BASE_ADDR</name>
	<description>The complete register value is a location to System RAM (limited to this area), where the CMAC code segment is remapped.</description>
	<bitRange>[18:8]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>CMI_DATA_BASE_REG</name>
	<description>CMAC data Base Address Register</description>
	<addressOffset>0x00000024</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0007ffff</resetMask>
	<fields><field>
	<name>CMI_DATA_BASE_ADDR</name>
	<description>The complete register value is a location to System RAM (limited to this area), where the CMAC data segment is remapped.
Typically this value is higher than CMI_CODE_BASE_REG.</description>
	<bitRange>[18:2]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>CMI_SHARED_BASE_REG</name>
	<description>CMAC shared data Base Address Register</description>
	<addressOffset>0x00000028</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0007ffff</resetMask>
	<fields><field>
	<name>CMI_SHARED_BASE_ADDR</name>
	<description>The complete register value is a location to System RAM (limited to this area), where the CMAC shared data segment is remapped.
Typically this value is higher than CMI_DATA_BASE_REG.</description>
	<bitRange>[18:2]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>MEM_PRIO_REG</name>
	<description>Priority Control Register</description>
	<addressOffset>0x00000004</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0003ffff</resetMask>
	<fields><field>
	<name>AHB3_PRIO</name>
	<description>Priority of the AHB3 interface for the arbitration that is performed per memory cell. Six priority classes are supported, from priority class 0 (lowest priority) to priority class 5 (highest priority).The AHB3 interface can participate in one of the priority classes by setting the corresponding value: from 0 up to 5. The values 6 and 7 are reserved.</description>
	<bitRange>[8:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>AHB2_PRIO</name>
	<description>Priority of the AHB2 interface for the arbitration that is performed per memory cell. Six priority classes are supported, from priority class 0 (lowest priority) to priority class 5 (highest priority).The AHB2 interface can participate in one of the priority classes by setting the corresponding value: from 0 up to 5. The values 6 and 7 are reserved.</description>
	<bitRange>[5:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>AHB_PRIO</name>
	<description>Priority of the AHB interface for the arbitration that is performed per memory cell. Six priority classes are supported, from priority class 0 (lowest priority) to priority class 5 (highest priority).The AHB interface can participate in one of the priority classes by setting the corresponding value: from 0 up to 5. The values 6 and 7 are reserved.</description>
	<bitRange>[2:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>MEM_STALL_REG</name>
	<description>Maximum Stall cycles Control Register</description>
	<addressOffset>0x00000008</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00ffffff</resetValue>
	<resetMask>0x00ffffff</resetMask>
	<fields><field>
	<name>AHB3_MAX_STALL</name>
	<description>Maximum allowed number of stall cycles for the AHB3 interface. If exceeded, the interface will get top priority (above high priority). Valid for a single access so the next access (of a burst) might end up in the queue for the same number of wait cycles.
0: do not use, not feasible and can block other interfaces
1: max 1 stall cycle
15: max 15 stall cycles</description>
	<bitRange>[11:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>AHB2_MAX_STALL</name>
	<description>Maximum allowed number of stall cycles for the AHB2 interface. If exceeded, the interface will get top priority (above high priority). Valid for a single access so the next access (of a burst) might end up in the queue for the same number of wait cycles.
0: do not use, not feasible and can block other interfaces
1: max 1 stall cycle
15: max 15 stall cycles</description>
	<bitRange>[7:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>AHB_MAX_STALL</name>
	<description>Maximum allowed number of stall cycles for the AHB interface. If exceeded, the interface will get top priority (above high priority). Valid for a single access so the next access (of a burst) might end up in the queue for the same number of wait cycles.
0: do not use, not feasible and can block other interfaces
1: max 1 stall cycle
15: max 15 stall cycles</description>
	<bitRange>[3:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>MEM_STATUS2_REG</name>
	<description>RAM cells Status Register</description>
	<addressOffset>0x00000010</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00000007</resetMask>
	<fields><field>
	<name>RAM3_OFF_BUT_ACCESS</name>
	<description>Reading 1 indicates RAM3 was off but still access was performed.
Writing 1 will clear the status back to 0.</description>
	<bitRange>[2:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RAM2_OFF_BUT_ACCESS</name>
	<description>Reading 1 indicates RAM2 was off but still access was performed.
Writing 1 will clear the status back to 0.</description>
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RAM1_OFF_BUT_ACCESS</name>
	<description>Reading 1 indicates RAM1 was off but still access was performed.
Writing 1 will clear the status back to 0.</description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>MEM_STATUS_REG</name>
	<description>Memory Arbiter Status Register</description>
	<addressOffset>0x0000000c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x003fff77</resetMask>
	<fields><field>
	<name>MTB_CLEAR_READY</name>
	<description>Writing 1 clears MTB_NOT_READY bit.</description>
	<bitRange>[21:21]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>MTB_NOT_READY</name>
	<description>0: Normal operation
1: MTB access performed which could not be handled right away (interface does not allow wait cycles)</description>
	<bitRange>[20:20]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>AHB3_WR_BUFF_CNT</name>
	<description>The maximum number of arbiter clock cycles that an AHB3 access has been buffered.</description>
	<bitRange>[19:16]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>AHB2_WR_BUFF_CNT</name>
	<description>The maximum number of arbiter clock cycles that an AHB2 access has been buffered.</description>
	<bitRange>[15:12]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>AHB_WR_BUFF_CNT</name>
	<description>The maximum number of arbiter clock cycles that an AHB access has been buffered.</description>
	<bitRange>[11:8]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>AHB3_CLR_WR_BUFF</name>
	<description>Writing 1 clears AHB3_WR_BUFF_CNT.</description>
	<bitRange>[6:6]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>AHB2_CLR_WR_BUFF</name>
	<description>Writing 1 clears AHB2_WR_BUFF_CNT.</description>
	<bitRange>[5:5]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>AHB_CLR_WR_BUFF</name>
	<description>Writing 1 clears AHB_WR_BUFF_CNT.</description>
	<bitRange>[4:4]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>AHB3_WRITE_BUFF</name>
	<description>0: No AHB3 write access is buffered.
1: Currently a single AHB3 write access is buffered in the arbiter.</description>
	<bitRange>[2:2]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>AHB2_WRITE_BUFF</name>
	<description>0: No AHB2 write access is buffered.
1: Currently a single AHB2 write access is buffered in the arbiter.</description>
	<bitRange>[1:1]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>AHB_WRITE_BUFF</name>
	<description>0: No AHB write access is buffered.
1: Currently a single AHB write access is buffered in the arbiter.</description>
	<bitRange>[0:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register></registers>
</peripheral><peripheral>
	<name>PCM1</name>
	<version>1.0</version>
	<description>PCM1 registers</description>
	<groupName>Peripheral_Registers</groupName>
	<baseAddress>0x50030300</baseAddress>
	<size>0</size>
	<addressBlock>
	<offset>0</offset>
	<size>20</size>
	<usage>registers</usage>
</addressBlock>

	<registers>
	<register>
	<name>PCM1_CTRL_REG</name>
	<description>PCM1 Control register</description>
	<addressOffset>0x00000000</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0xffffffff</resetMask>
	<fields><field>
	<name>PCM_FSC_DIV</name>
	<description>PCM Framesync divider, Values 7-0xFFF. To divide by N, write N-1. (Minimum value N-1=7 for 8 bits PCM_FSC)
Note if PCM_CLK_BIT = 1, N must always be even</description>
	<bitRange>[31:20]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PCM_FSC_EDGE</name>
	<description>0: Shift channels 1, 2, 3, 4, 5, 6, 7, 8 after PCM_FSC edge
1: Shift channels 1, 2, 3, 4 after PCM_FSC edge shift channels 5, 6, 7, 8 after opposite PCM_FSC edge </description>
	<bitRange>[16:16]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PCM_CH_DEL</name>
	<description>Channel delay in multiples of 8 bits </description>
	<bitRange>[15:11]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PCM_CLK_BIT</name>
	<description>0:One clock cycle per data bit
1:Two clock cycles per data bit</description>
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PCM_FSCINV</name>
	<description>0: PCM FSC
1: PCM FSC inverted</description>
	<bitRange>[9:9]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PCM_CLKINV</name>
	<description>0:PCM CLK
1:PCM CLK inverted</description>
	<bitRange>[8:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PCM_PPOD</name>
	<description>0:PCM DO push pull
1:PCM DO open drain</description>
	<bitRange>[7:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PCM_FSCDEL</name>
	<description>0:PCM FSC starts one cycle before MSB bit
1:PCM FSC starts at the same time as MSB bit</description>
	<bitRange>[6:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PCM_FSCLEN</name>
	<description>0:PCM FSC length equal to 1 data bit
N:PCM FSC length equal to N*8 </description>
	<bitRange>[5:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PCM_MASTER</name>
	<description>0:PCM interface in slave mode
1:PCM interface in master mode</description>
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PCM_EN</name>
	<description>0:PCM interface disabled
1:PCM interface enabled</description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>PCM1_IN1_REG</name>
	<description>PCM1 data in 1</description>
	<addressOffset>0x00000004</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0xffffffff</resetMask>
	<fields><field>
	<name>PCM_IN</name>
	<description>PCM1_IN1 bits 31-0 </description>
	<bitRange>[31:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>PCM1_IN2_REG</name>
	<description>PCM1 data in 2</description>
	<addressOffset>0x00000008</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0xffffffff</resetMask>
	<fields><field>
	<name>PCM_IN</name>
	<description>PCM1_IN2 bits 31-0 </description>
	<bitRange>[31:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>PCM1_OUT1_REG</name>
	<description>PCM1 data out 1</description>
	<addressOffset>0x0000000c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0xffffffff</resetValue>
	<resetMask>0xffffffff</resetMask>
	<fields><field>
	<name>PCM_OUT</name>
	<description>PCM1_OUT1 bits 31-0 </description>
	<bitRange>[31:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>PCM1_OUT2_REG</name>
	<description>PCM1 data out 2</description>
	<addressOffset>0x00000010</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0xffffffff</resetValue>
	<resetMask>0xffffffff</resetMask>
	<fields><field>
	<name>PCM_OUT</name>
	<description>PCM1_OUT2 bits 31-0 </description>
	<bitRange>[31:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register></registers>
</peripheral><peripheral>
	<name>PDC</name>
	<version>1.0</version>
	<description>PDC registers</description>
	<groupName>Peripheral_Registers</groupName>
	<baseAddress>0x50000200</baseAddress>
	<size>0</size>
	<addressBlock>
	<offset>0</offset>
	<size>156</size>
	<usage>registers</usage>
</addressBlock>

	<registers>
	<register>
	<name>PDC_ACKNOWLEDGE_REG</name>
	<description>Clear a pending PDC bit</description>
	<addressOffset>0x00000080</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000001f</resetMask>
	<fields><field>
	<name>PDC_ACKNOWLEDGE</name>
	<description>Writing to this field acknowledges the PDC IRQ request.
The data controls which request is acknowledged</description>
	<bitRange>[4:0]</bitRange>
	<access>write-only</access>
	</field></fields>
</register><register>
	<name>PDC_CONFIG_REG</name>
	<description>PDC configuration register</description>
	<addressOffset>0x00000098</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00000007</resetMask>
	<fields><field>
	<name>TRIG_SELECT_CONFIG</name>
	<description>0: All triggers to all PDCs are let through
1: All triggers apart from FCU (0xC) are masked until the FCU is ready or powered off</description>
	<bitRange>[2:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PD_RAD_WKUP_CONFIG</name>
	<description>0: PD_RAD is woken up without delay
1: PD_RAD is woken up only when the FCU is ready or powered off</description>
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PD_SYS_WKUP_CONFIG</name>
	<description>0: PD_SYS is woken up without delay
1: PD_SYS is woken up only when the FCU is ready or powered off</description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>PDC_CTRL0_REG</name>
	<description>PDC control register</description>
	<addressOffset>0x00000000</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00001fff</resetMask>
	<fields><field>
	<name>PDC_MASTER</name>
	<description>Chooses which master is triggered when waking up
0x0: entry is disabled.
0x1: PD_SYS is woken up and CM33 is triggered
0x2: PD_RAD is woken up and CMAC is triggered
0x3: Reserved</description>
	<bitRange>[12:11]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>EN_COM</name>
	<description>If set, enables PD_COM for GPIO access. </description>
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>EN_PER</name>
	<description>If set, enables PD_PER</description>
	<bitRange>[9:9]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>EN_TMR</name>
	<description>If set, enables PD_TMR</description>
	<bitRange>[8:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>EN_XTAL</name>
	<description>If set, the XTAL32M will be started</description>
	<bitRange>[7:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>TRIG_ID</name>
	<description>Selects which individual bit from the selected bank is used for wake-up.
For the peripheral banks, selected with TRIG_SELECT = 0x2 or 0x3, only the lower 4 bits are considered.</description>
	<bitRange>[6:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>TRIG_SELECT</name>
	<description>Selects which bank is used as wake-up trigger
When TRIG_SELECT is 0x0, selects GPIO port0 through the WAKEUP block.
When TRIG_SELECT is 0x1, selects GPIO port1 through the WAKEUP block.
When TRIG_SELECT is 0x2 or 0x3, selects the peripheral IRQ.
Peripheral IRQ table:
0x0: Timer
0x1: Timer2
0x2: Timer3
0x3: Timer4
0x4: RTC Alarm/Rollover
0x5: RTC Timer
0x6: CMAC Timer OR wake-up from CMAC debugger
0x7: Reserved
0x8: XTAL32MRDY_IRQ
0x9: RFDIAG_IRQ
0xA: CMAC2SYS_IRQ OR JTAG present OR Debounced IO
0xB: Reserved
0xC: FCU
0xD: Fast wake-up
0xE: Reserved
0xF: Software trigger only</description>
	<bitRange>[1:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>PDC_CTRL10_REG</name>
	<description>PDC control register</description>
	<addressOffset>0x00000028</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00001fff</resetMask>
	<fields><field>
	<name>PDC_MASTER</name>
	<description>Chooses which master is triggered when waking up
0x0: entry is disabled.
0x1: PD_SYS is woken up and CM33 is triggered
0x2: PD_RAD is woken up and CMAC is triggered
0x3: Reserved</description>
	<bitRange>[12:11]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>EN_COM</name>
	<description>If set, enables PD_COM for GPIO access.</description>
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>EN_PER</name>
	<description>If set, enables PD_PER</description>
	<bitRange>[9:9]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>EN_TMR</name>
	<description>If set, enables PD_TMR</description>
	<bitRange>[8:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>EN_XTAL</name>
	<description>If set, the XTAL32M will be started</description>
	<bitRange>[7:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>TRIG_ID</name>
	<description>For description, see PDC_CTRL0_REG.TRIG_ID</description>
	<bitRange>[6:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>TRIG_SELECT</name>
	<description>For description, see PDC_CTRL0_REG.TRIG_SELECT</description>
	<bitRange>[1:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>PDC_CTRL11_REG</name>
	<description>PDC control register</description>
	<addressOffset>0x0000002c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00001fff</resetMask>
	<fields><field>
	<name>PDC_MASTER</name>
	<description>Chooses which master is triggered when waking up
0x0: entry is disabled.
0x1: PD_SYS is woken up and CM33 is triggered
0x2: PD_RAD is woken up and CMAC is triggered
0x3: Reserved</description>
	<bitRange>[12:11]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>EN_COM</name>
	<description>If set, enables PD_COM for GPIO access.</description>
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>EN_PER</name>
	<description>If set, enables PD_PER</description>
	<bitRange>[9:9]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>EN_TMR</name>
	<description>If set, enables PD_TMR</description>
	<bitRange>[8:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>EN_XTAL</name>
	<description>If set, the XTAL32M will be started</description>
	<bitRange>[7:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>TRIG_ID</name>
	<description>For description, see PDC_CTRL0_REG.TRIG_ID</description>
	<bitRange>[6:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>TRIG_SELECT</name>
	<description>For description, see PDC_CTRL0_REG.TRIG_SELECT</description>
	<bitRange>[1:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>PDC_CTRL1_REG</name>
	<description>PDC control register</description>
	<addressOffset>0x00000004</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00001fff</resetMask>
	<fields><field>
	<name>PDC_MASTER</name>
	<description>Chooses which master is triggered when waking up
0x0: entry is disabled.
0x1: PD_SYS is woken up and CM33 is triggered
0x2: PD_RAD is woken up and CMAC is triggered
0x3: Reserved</description>
	<bitRange>[12:11]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>EN_COM</name>
	<description>If set, enables PD_COM for GPIO access. </description>
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>EN_PER</name>
	<description>If set, enables PD_PER</description>
	<bitRange>[9:9]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>EN_TMR</name>
	<description>If set, enables PD_TMR</description>
	<bitRange>[8:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>EN_XTAL</name>
	<description>If set, the XTAL32M will be started</description>
	<bitRange>[7:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>TRIG_ID</name>
	<description>For description, see PDC_CTRL0_REG.TRIG_ID</description>
	<bitRange>[6:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>TRIG_SELECT</name>
	<description>For description, see PDC_CTRL0_REG.TRIG_SELECT</description>
	<bitRange>[1:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>PDC_CTRL2_REG</name>
	<description>PDC control register</description>
	<addressOffset>0x00000008</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00001fff</resetMask>
	<fields><field>
	<name>PDC_MASTER</name>
	<description>Chooses which master is triggered when waking up
0x0: entry is disabled.
0x1: PD_SYS is woken up and CM33 is triggered
0x2: PD_RAD is woken up and CMAC is triggered
0x3: Reserved</description>
	<bitRange>[12:11]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>EN_COM</name>
	<description>IIf set, enables PD_COM for GPIO access. </description>
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>EN_PER</name>
	<description>If set, enables PD_PER</description>
	<bitRange>[9:9]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>EN_TMR</name>
	<description>If set, enables PD_TMR</description>
	<bitRange>[8:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>EN_XTAL</name>
	<description>If set, the XTAL32M will be started</description>
	<bitRange>[7:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>TRIG_ID</name>
	<description>For description, see PDC_CTRL0_REG.TRIG_ID</description>
	<bitRange>[6:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>TRIG_SELECT</name>
	<description>For description, see PDC_CTRL0_REG.TRIG_SELECT</description>
	<bitRange>[1:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>PDC_CTRL3_REG</name>
	<description>PDC control register</description>
	<addressOffset>0x0000000c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00001fff</resetMask>
	<fields><field>
	<name>PDC_MASTER</name>
	<description>Chooses which master is triggered when waking up
0x0: entry is disabled.
0x1: PD_SYS is woken up and CM33 is triggered
0x2: PD_RAD is woken up and CMAC is triggered
0x3: Reserved</description>
	<bitRange>[12:11]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>EN_COM</name>
	<description>If set, enables PD_COM for GPIO access. </description>
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>EN_PER</name>
	<description>If set, enables PD_PER</description>
	<bitRange>[9:9]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>EN_TMR</name>
	<description>If set, enables PD_TMR</description>
	<bitRange>[8:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>EN_XTAL</name>
	<description>If set, the XTAL32M will be started</description>
	<bitRange>[7:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>TRIG_ID</name>
	<description>For description, see PDC_CTRL0_REG.TRIG_ID</description>
	<bitRange>[6:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>TRIG_SELECT</name>
	<description>For description, see PDC_CTRL0_REG.TRIG_SELECT</description>
	<bitRange>[1:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>PDC_CTRL4_REG</name>
	<description>PDC control register</description>
	<addressOffset>0x00000010</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00001fff</resetMask>
	<fields><field>
	<name>PDC_MASTER</name>
	<description>Chooses which master is triggered when waking up
0x0: entry is disabled.
0x1: PD_SYS is woken up and CM33 is triggered
0x2: PD_RAD is woken up and CMAC is triggered
0x3: Reserved</description>
	<bitRange>[12:11]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>EN_COM</name>
	<description>If set, enables PD_COM for GPIO access. </description>
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>EN_PER</name>
	<description>If set, enables PD_PER</description>
	<bitRange>[9:9]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>EN_TMR</name>
	<description>If set, enables PD_TMR</description>
	<bitRange>[8:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>EN_XTAL</name>
	<description>If set, the XTAL32M will be started</description>
	<bitRange>[7:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>TRIG_ID</name>
	<description>For description, see PDC_CTRL0_REG.TRIG_ID</description>
	<bitRange>[6:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>TRIG_SELECT</name>
	<description>For description, see PDC_CTRL0_REG.TRIG_SELECT</description>
	<bitRange>[1:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>PDC_CTRL5_REG</name>
	<description>PDC control register</description>
	<addressOffset>0x00000014</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00001fff</resetMask>
	<fields><field>
	<name>PDC_MASTER</name>
	<description>Chooses which master is triggered when waking up
0x0: entry is disabled.
0x1: PD_SYS is woken up and CM33 is triggered
0x2: PD_RAD is woken up and CMAC is triggered
0x3: Reserved</description>
	<bitRange>[12:11]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>EN_COM</name>
	<description>If set, enables PD_COM for GPIO access. </description>
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>EN_PER</name>
	<description>If set, enables PD_PER</description>
	<bitRange>[9:9]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>EN_TMR</name>
	<description>If set, enables PD_TMR</description>
	<bitRange>[8:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>EN_XTAL</name>
	<description>If set, the XTAL32M will be started</description>
	<bitRange>[7:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>TRIG_ID</name>
	<description>For description, see PDC_CTRL0_REG.TRIG_ID</description>
	<bitRange>[6:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>TRIG_SELECT</name>
	<description>For description, see PDC_CTRL0_REG.TRIG_SELECT</description>
	<bitRange>[1:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>PDC_CTRL6_REG</name>
	<description>PDC control register</description>
	<addressOffset>0x00000018</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00001fff</resetMask>
	<fields><field>
	<name>PDC_MASTER</name>
	<description>Chooses which master is triggered when waking up
0x0: entry is disabled.
0x1: PD_SYS is woken up and CM33 is triggered
0x2: PD_RAD is woken up and CMAC is triggered
0x3: Reserved</description>
	<bitRange>[12:11]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>EN_COM</name>
	<description>If set, enables PD_COM for GPIO access. </description>
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>EN_PER</name>
	<description>If set, enables PD_PER</description>
	<bitRange>[9:9]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>EN_TMR</name>
	<description>If set, enables PD_TMR</description>
	<bitRange>[8:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>EN_XTAL</name>
	<description>If set, the XTAL32M will be started</description>
	<bitRange>[7:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>TRIG_ID</name>
	<description>For description, see PDC_CTRL0_REG.TRIG_ID</description>
	<bitRange>[6:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>TRIG_SELECT</name>
	<description>For description, see PDC_CTRL0_REG.TRIG_SELECT</description>
	<bitRange>[1:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>PDC_CTRL7_REG</name>
	<description>PDC control register</description>
	<addressOffset>0x0000001c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00001fff</resetMask>
	<fields><field>
	<name>PDC_MASTER</name>
	<description>Chooses which master is triggered when waking up
0x0: entry is disabled.
0x1: PD_SYS is woken up and CM33 is triggered
0x2: PD_RAD is woken up and CMAC is triggered
0x3: Reserved</description>
	<bitRange>[12:11]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>EN_COM</name>
	<description>If set, enables PD_COM for GPIO access. </description>
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>EN_PER</name>
	<description>If set, enables PD_PER</description>
	<bitRange>[9:9]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>EN_TMR</name>
	<description>If set, enables PD_TMR</description>
	<bitRange>[8:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>EN_XTAL</name>
	<description>If set, the XTAL32M will be started</description>
	<bitRange>[7:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>TRIG_ID</name>
	<description>For description, see PDC_CTRL0_REG.TRIG_ID</description>
	<bitRange>[6:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>TRIG_SELECT</name>
	<description>For description, see PDC_CTRL0_REG.TRIG_SELECT</description>
	<bitRange>[1:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>PDC_CTRL8_REG</name>
	<description>PDC control register</description>
	<addressOffset>0x00000020</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00001fff</resetMask>
	<fields><field>
	<name>PDC_MASTER</name>
	<description>Chooses which master is triggered when waking up
0x0: entry is disabled.
0x1: PD_SYS is woken up and CM33 is triggered
0x2: PD_RAD is woken up and CMAC is triggered
0x3: Reserved</description>
	<bitRange>[12:11]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>EN_COM</name>
	<description>If set, enables PD_COM for GPIO access.</description>
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>EN_PER</name>
	<description>If set, enables PD_PER</description>
	<bitRange>[9:9]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>EN_TMR</name>
	<description>If set, enables PD_TMR</description>
	<bitRange>[8:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>EN_XTAL</name>
	<description>If set, the XTAL32M will be started</description>
	<bitRange>[7:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>TRIG_ID</name>
	<description>For description, see PDC_CTRL0_REG.TRIG_ID</description>
	<bitRange>[6:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>TRIG_SELECT</name>
	<description>For description, see PDC_CTRL0_REG.TRIG_SELECT</description>
	<bitRange>[1:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>PDC_CTRL9_REG</name>
	<description>PDC control register</description>
	<addressOffset>0x00000024</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00001fff</resetMask>
	<fields><field>
	<name>PDC_MASTER</name>
	<description>Chooses which master is triggered when waking up
0x0: entry is disabled.
0x1: PD_SYS is woken up and CM33 is triggered
0x2: PD_RAD is woken up and CMAC is triggered
0x3: Reserved</description>
	<bitRange>[12:11]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>EN_COM</name>
	<description>If set, enables PD_COM for GPIO access. </description>
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>EN_PER</name>
	<description>If set, enables PD_PER</description>
	<bitRange>[9:9]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>EN_TMR</name>
	<description>If set, enables PD_TMR</description>
	<bitRange>[8:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>EN_XTAL</name>
	<description>If set, the XTAL32M will be started</description>
	<bitRange>[7:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>TRIG_ID</name>
	<description>For description, see PDC_CTRL0_REG.TRIG_ID</description>
	<bitRange>[6:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>TRIG_SELECT</name>
	<description>For description, see PDC_CTRL0_REG.TRIG_SELECT</description>
	<bitRange>[1:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>PDC_PENDING_CM33_REG</name>
	<description>Shows any pending IRQ to CM33</description>
	<addressOffset>0x0000008c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00000fff</resetMask>
	<fields><field>
	<name>PDC_PENDING</name>
	<description>Indicates which IRQ ids are pending towards the CM33</description>
	<bitRange>[11:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>PDC_PENDING_CMAC_REG</name>
	<description>Shows any pending IRQ to CMAC</description>
	<addressOffset>0x00000090</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00000fff</resetMask>
	<fields><field>
	<name>PDC_PENDING</name>
	<description>Indicates which IRQ ids are pending towards the CMAC</description>
	<bitRange>[11:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>PDC_PENDING_REG</name>
	<description>Shows any pending wake-up event</description>
	<addressOffset>0x00000084</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00000fff</resetMask>
	<fields><field>
	<name>PDC_PENDING</name>
	<description>Indicates which IRQ ids are pending</description>
	<bitRange>[11:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>PDC_SET_PENDING_REG</name>
	<description>Set a pending PDC bit</description>
	<addressOffset>0x00000094</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000001f</resetMask>
	<fields><field>
	<name>PDC_SET_PENDING</name>
	<description>Writing to this field sets the PDC wake-up request and IRQ.
The data controls which request is acknowledged</description>
	<bitRange>[4:0]</bitRange>
	<access>write-only</access>
	</field></fields>
</register></registers>
</peripheral><peripheral>
	<name>QSPIC</name>
	<version>1.0</version>
	<description>QSPIC registers</description>
	<groupName>Peripheral_Registers</groupName>
	<baseAddress>0x34000000</baseAddress>
	<size>0</size>
	<addressBlock>
	<offset>0</offset>
	<size>72</size>
	<usage>registers</usage>
</addressBlock>

	<registers>
	<register>
	<name>QSPIC_AWRITECMD_REG</name>
	<description>The way of writing in Auto mode when the external device is a serial SRAM</description>
	<addressOffset>0x00000040</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0xffffffff</resetMask>
	<fields><field>
	<name>QSPIC_WR_CS_HIGH_MIN</name>
	<description>After the execution of the write command, the QSPI_CS remains high for at least this number of QSPI_SCK clock cycles.</description>
	<bitRange>[18:14]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>QSPIC_WR_DAT_TX_MD</name>
	<description>The mode of the SPI Bus during the data phase of the write command.
0x0: Single SPI
0x1: Dual
0x2: Quad
0x3: Reserved</description>
	<bitRange>[13:12]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>QSPIC_WR_ADR_TX_MD</name>
	<description>The mode of the SPI Bus during the address phase of the write command.
0x0: Single SPI
0x1: Dual
0x2: Quad
0x3: Reserved</description>
	<bitRange>[11:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>QSPIC_WR_INST_TX_MD</name>
	<description>The mode of the SPI Bus during the instruction phase of the write command.
0x0: Single SPI
0x1: Dual
0x2: Quad
0x3: Reserved</description>
	<bitRange>[9:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>QSPIC_WR_INST</name>
	<description>This is the value of the instruction that is used, in order to be programmed the external SRAM device.</description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>QSPIC_BURSTBRK_REG</name>
	<description>Read break sequence in Auto mode</description>
	<addressOffset>0x00000030</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0xffffffff</resetMask>
	<fields><field>
	<name>QSPIC_SEC_HF_DS</name>
	<description>Disable output during the transmission of the second half (QSPIC_BRK_WRD[3:0]). Setting this bit is only useful if QSPIC_BRK_EN =1 and QSPIC_BRK_SZ= 1.
0: The controller drives the SPI bus during the transmission of the QSPIC_BRK_WRD[3:0].
1: The controller leaves the SPI bus in Hi-Z during the transmission of the QSPIC_BRK_WORD[3:0].</description>
	<bitRange>[20:20]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>QSPIC_BRK_TX_MD</name>
	<description>The mode of the SPI Bus during the transmission of the read break sequence.
0x0: Single SPI
0x1: Dual
0x2: Quad
0x3: Reserved</description>
	<bitRange>[19:18]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>QSPIC_BRK_SZ</name>
	<description>The size of the read break sequence.
0: One byte (Send QSPIC_BRK_WRD[15:8])
1: Two bytes (Send QSPIC_BRK_WRD[15:0])</description>
	<bitRange>[17:17]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>QSPIC_BRK_EN</name>
	<description>Controls the application of a special command (read break sequence) that is used in order to force the device to abandon the continuous read mode.
0: The special command is not applied
1: The special command is applied

This special command is applied by the controller to the external device under the following conditions:
- the controller is in Auto mode
- the QSPIC_INST_MD = 1
- the previous command that has been applied in the external device was read
- the controller want to apply to the external device a command different than the read.</description>
	<bitRange>[16:16]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>QSPIC_BRK_WRD</name>
	<description>This is the value of a special command (read break sequence) that is applied by the controller to the external memory device, in order to force the memory device to abandon the continuous read mode.</description>
	<bitRange>[15:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>QSPIC_BURSTCMDA_REG</name>
	<description>The way of reading in Auto mode (command register A)</description>
	<addressOffset>0x0000000c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0xffffffff</resetMask>
	<fields><field>
	<name>QSPIC_DMY_TX_MD</name>
	<description>It describes the mode of the SPI bus during the Dummy bytes phase.
0x0: Single SPI
0x1: Dual
0x2: Quad
0x3: Reserved</description>
	<bitRange>[31:30]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>QSPIC_EXT_TX_MD</name>
	<description>It describes the mode of the SPI bus during the Extra Byte phase.
0x0: Single SPI
0x1: Dual
0x2: Quad
0x3: Reserved</description>
	<bitRange>[29:28]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>QSPIC_ADR_TX_MD</name>
	<description>It describes the mode of the SPI bus during the address phase.
0x0: Single SPI
0x1: Dual
0x2: Quad
0x3: Reserved</description>
	<bitRange>[27:26]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>QSPIC_INST_TX_MD</name>
	<description>It describes the mode of the SPI bus during the instruction phase.
0x0: Single SPI
0x1: Dual
0x2: Quad
0x3: Reserved</description>
	<bitRange>[25:24]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>QSPIC_EXT_BYTE</name>
	<description>The value of an extra byte which will be transferred after address (only if QSPIC_EXT_BYTE_EN= 1). Usually this is the Mode Bits in Dual/Quad SPI I/O instructions.</description>
	<bitRange>[23:16]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>QSPIC_INST_WB</name>
	<description>Instruction Value for Wrapping Burst. This value is the selected instruction when QSPIC_WRAP_MD is equal to 1 and the access is a wrapping burst of length and size described by the bit fields QSPIC_WRAP_LEN and QSPIC_WRAP_SIZE respectively.</description>
	<bitRange>[15:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>QSPIC_INST</name>
	<description>Instruction Value for Incremental Burst or Single read access. This value is the selected instruction at the cases of incremental burst or single read access. Also this value is used when a wrapping burst is not supported (QSPIC_WRAP_MD)</description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>QSPIC_BURSTCMDB_REG</name>
	<description>The way of reading in Auto mode (command register B)</description>
	<addressOffset>0x00000010</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0xffffffff</resetMask>
	<fields><field>
	<name>QSPIC_DMY_FORCE</name>
	<description>By setting this bit, the number of dummy bytes is forced to be equal to 3. In this case the QSPIC_DMY_NUM field is overruled and has no function.
0: The number of dummy bytes is controlled by the QSPIC_DMY_NUM field
1: Three dummy bytes are used. The QSPIC_DMY_NUM is overruled.</description>
	<bitRange>[15:15]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>QSPIC_CS_HIGH_MIN</name>
	<description>Between the transmission of two different instructions to the flash memory, the qspi bus stays in idle state (QSPI_CS high) for at least this number of QSPI_SCK clock cycles. See the QSPIC_ERS_CS_HI and the QSPIC_WR_CS_HIGH_MIN registers for some exceptions.</description>
	<bitRange>[14:12]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>QSPIC_WRAP_SIZE</name>
	<description>It describes the selected data size of a wrapping burst (QSPIC_WRAP_MD).
0x0: Byte access (8-bits)
0x1: Half word access (16 bits)
0x2: Word access (32-bits)
0x3: Reserved</description>
	<bitRange>[11:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>QSPIC_WRAP_LEN</name>
	<description>It describes the selected length of a wrapping burst (QSPIC_WRAP_MD).
0x0: 4 beat wrapping burst
0x1: 8 beat wrapping burst
0x2: 16 beat wrapping burst
0x3: Reserved</description>
	<bitRange>[9:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>QSPIC_WRAP_MD</name>
	<description>Wrap mode
0: The QSPIC_INST is the selected instruction at any access.
1: The QSPIC_INST_WB is the selected instruction at any wrapping burst access of length and size described by the registers QSPIC_WRAP_LEN and QSPIC_WRAP_SIZE respectively. In all other cases the QSPIC_INST is the selected instruction. Use this feature only when the serial FLASH memory supports a special instruction for wrapping burst access.</description>
	<bitRange>[7:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>QSPIC_INST_MD</name>
	<description>Instruction mode
0: Transmit instruction at any burst access.
1: Transmit instruction only in the first access after the selection of Auto Mode.</description>
	<bitRange>[6:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>QSPIC_DMY_NUM</name>
	<description>Number of Dummy Bytes
0x0: Zero Dummy Bytes (Do not Send Dummy Bytes)
0x1: Send 1 Dummy Byte
0x2: Send 2 Dummy Bytes
0x3: Send 4 Dummy Bytes
When QSPIC_DMY_FORCE is enabled, the QSPIC_DMY_NUM is overruled. In this case the number of dummy bytes is defined by QSPIC_DMY_FORCE and is equal to 3, independent of the value of QSPIC_DMY_NUM.</description>
	<bitRange>[5:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>QSPIC_EXT_HF_DS</name>
	<description>Extra Half Disable Output
0: If QSPIC_EXT_BYTE_EN=1, then transmit the complete QSPIC_EXT_BYTE
1: If QSPIC_EXT_BYTE_EN=1, then disable (hi-z) output during the transmission of bits [3:0] of QSPIC_EXT_BYTE</description>
	<bitRange>[3:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>QSPIC_EXT_BYTE_EN</name>
	<description>Extra Byte Enable
0: Do not Send QSPIC_EXT_BYTE
1: Send QSPIC_EXT_BYTE</description>
	<bitRange>[2:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>QSPIC_DAT_RX_MD</name>
	<description>It describes the mode of the SPI bus during the data phase.
0x0: Single SPI
0x1: Dual
0x2: Quad
0x3: Reserved</description>
	<bitRange>[1:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>QSPIC_CHCKERASE_REG</name>
	<description>Check erase progress in Auto mode</description>
	<addressOffset>0x00000038</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0xffffffff</resetMask>
	<fields><field>
	<name>QSPIC_CHCKERASE</name>
	<description>Writing any value to this register during erasing, forces the controller to read the flash memory status register. Depending on the value of the Busy bit, it updates the QSPIC_ERASE_EN.
This register has meaning only when the controller is in Auto mode and there is an erase in progress (QSPIC_ERASE_EN =1). It has no meaning when the external device is a serial SRAM.</description>
	<bitRange>[31:0]</bitRange>
	<access>write-only</access>
	</field></fields>
</register><register>
	<name>QSPIC_CTRLBUS_REG</name>
	<description>SPI Bus control register for the Manual mode</description>
	<addressOffset>0x00000000</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0xffffffff</resetMask>
	<fields><field>
	<name>QSPIC_DIS_CS</name>
	<description>Write 1 to disable the chip select (active low) when the controller is in Manual mode.</description>
	<bitRange>[4:4]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>QSPIC_EN_CS</name>
	<description>Write 1 to enable the chip select (active low) when the controller is in Manual mode. </description>
	<bitRange>[3:3]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>QSPIC_SET_QUAD</name>
	<description>Write 1 to set the bus mode in Quad mode when the controller is in Manual mode.</description>
	<bitRange>[2:2]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>QSPIC_SET_DUAL</name>
	<description>Write 1 to set the bus mode in Dual mode when the controller is in Manual mode.</description>
	<bitRange>[1:1]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>QSPIC_SET_SINGLE</name>
	<description>Write 1 to set the bus mode in Single SPI mode when the controller is in Manual mode.</description>
	<bitRange>[0:0]</bitRange>
	<access>write-only</access>
	</field></fields>
</register><register>
	<name>QSPIC_CTRLMODE_REG</name>
	<description>Mode control register</description>
	<addressOffset>0x00000004</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0xffffffff</resetMask>
	<fields><field>
	<name>QSPIC_CLK_FREE_EN</name>
	<description>Controls the behavior of the QSPI_SCK when the QSPI_CS is high and the QSPIC_CS_MD = 1.
0: Is produced one QSPI_SCK clock pulse after each 0 to 1 transition in the QSPI_CS.
1: The QSPI_SCK clock remains always active, while the QSPI_CS is inactive.
This setting has meaning only when the QSPIC_CS_MD = 1.</description>
	<bitRange>[16:16]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>QSPIC_CS_MD</name>
	<description>Controls the clock edge with which is produced the QSPI_CS signal.
0: The QSPI_CS is produced with the rising edge of the QSPI_SCK. The QSPI_SCK is always inactive while the QSPI_CS is high.
1: The QSPI_CS is produced with the falling edge of the QSPI_SCK. The behavior of the QSPI_SCK while the QSPI_CS is high, is controlled by the QSPIC_CLK_FREE_EN.</description>
	<bitRange>[15:15]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>QSPIC_SRAM_EN</name>
	<description>Defines the type of the external device that is connected on the QSPIC controller
0: The external memory device is a serial Flash
1: The external memory device is a serial SRAM
When the external device is a serial SRAM, the erase suspend/ resume functionality of the controller is disabled. In this case the writing of the QSPIC_ERASECTRL_REG[QSPIC_ERASE_EN] bit has no effect. Also, the memory space where the external device is mapped, is considered as writable.</description>
	<bitRange>[14:14]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>QSPIC_USE_32BA</name>
	<description>Controls the length of the address that the external memory device uses.
0: The external memory device uses 24 bits address.
1: The external memory device uses 32 bits address.
The controller uses this bit in order to decide the number of the address bytes that has to transfer to the external device during Auto mode.</description>
	<bitRange>[13:13]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>QSPIC_FORCENSEQ_EN</name>
	<description>Controls the way in which a burst request from the AMBA bus is addressed by the QSPI controller.
0: The controller translates a burst access on the AMBA bus as a burst access on the QSPI bus. That results to the minimum number of command/address phases.
1: The controller will split a burst access on the AMBA bus into a number of single accesses on the QSPI bus. That results to a separate command for each beat of the burst. For example, a 4-beat word incremental AMBA read access will be split into four different sequences on the QSPI bus: command/address/extra clock/read data. The QSPI_CS will be low only for the time that is needed for each of these single access.
This configuration bit is useful when the clock frequency of the QSPI bus is much higher than the clock of the AMBA bus. In this case the interval for which the CS remains low is minimized, achieving lower power dissipation with respect of the case where the QSPIC_FORCENSEQ_EN = 0, at cost of performance.</description>
	<bitRange>[12:12]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>QSPIC_PCLK_MD</name>
	<description>Controls the read pipe clock delay relative to the falling edge of QSPI_SCK. Refer to QSPI Timing for timing parameters</description>
	<bitRange>[11:9]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>QSPIC_RPIPE_EN</name>
	<description>Controls the use of the data read pipe.
0: The read pipe is disabled, the sampling clock is defined according to the QSPIC_RXD_NEG setting.
1: The read pipe is enabled. The delay of the sampling clock is defined according to the QSPI_PCLK_MD setting. (Recommended)</description>
	<bitRange>[8:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>QSPIC_RXD_NEG</name>
	<description>Defines the clock edge that is used for the capturing of the received data, when the read pipe is not active (QSPIC_RPIPE_EN = 0).
0: Sampling of the received data with the positive edge of the QSPI_SCK
1: Sampling of the received data with the negative edge of the QSPI_SCK
The internal QSPI_SCK clock that is used by the controller for the capturing of the received data has a skew in respect of the QSPI_SCK that is received by the external memory device. To improve the timing requirements of the read path, the controller supports a read pipe register with programmable clock delay. See also the QSPIC_RPIPE_EN register.</description>
	<bitRange>[7:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>QSPIC_HRDY_MD</name>
	<description>This configuration bit is useful when the frequency of the QSPI clock is much lower than the clock of the AMBA bus, in order to not lock the AMBA bus for a long time.
0: Adds wait states via hready signal when an access is performed on QSPIC_WRITEDATA, QSPIC_READDATA and QSPIC_DUMMYDATA registers. It is not necessary to check the QSPIC_BUSY of the QSPIC_STATUS_REG.
1: The controller does not add wait states via the hready signal, when the access is performed on QSPIC_WRITEDATA, QSPIC_READDATA and QSPIC_DUMMYDATA registers. The QSPIC_BUSY bit of the QSPIC_STATUS_REG must be checked to be detected the completion of the requested access.

It is applicable only when the controller is in Manual mode. In the case of the Auto mode, the controller always adds wait states via the hready signal.</description>
	<bitRange>[6:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>QSPIC_IO3_DAT</name>
	<description>The value of QSPI_IO3 pad if QSPI_IO3_OEN is 1</description>
	<bitRange>[5:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>QSPIC_IO2_DAT</name>
	<description>The value of QSPI_IO2 pad if QSPI_IO2_OEN is 1</description>
	<bitRange>[4:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>QSPIC_IO3_OEN</name>
	<description>QSPI_IO3 output enable. Use this only in SPI or Dual SPI mode to control /HOLD signal. When the Auto Mode is selected (QSPIC_AUTO_MD = 1) and the QUAD SPI is used, set this bit to zero.
0: The QSPI_IO3 pad is input.
1: The QSPI_IO3 pad is output.</description>
	<bitRange>[3:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>QSPIC_IO2_OEN</name>
	<description>QSPI_IO2 output enable. Use this only in SPI or Dual SPI mode to control /WP signal. When the Auto Mode is selected (QSPIC_AUTO_MD = 1) and the QUAD SPI is used, set this bit to zero.
0: The QSPI_IO2 pad is input.
1: The QSPI_IO2 pad is output.</description>
	<bitRange>[2:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>QSPIC_CLK_MD</name>
	<description>Mode of the generated QSPI_SCK clock
0: Use Mode 0 for the QSPI_CLK. The QSPI_SCK is low when QSPI_CS is high.
1: Use Mode 3 for the QSPI_CLK. The QSPI_SCK is high when QSPI_CS is high.
See also the QSPIC_CS_MD register and the QSPIC_CLK_FREE_EN register.</description>
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>QSPIC_AUTO_MD</name>
	<description>Mode of operation
0: The Manual Mode is selected.
1: The Auto Mode is selected.
During an erasing the QSPIC_AUTO_MD goes in read only mode (see QSPIC_ERASE_EN)</description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>QSPIC_DUMMYDATA_REG</name>
	<description>Send dummy clocks to SPI Bus for the Manual mode</description>
	<addressOffset>0x00000020</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0xffffffff</resetMask>
	<fields><field>
	<name>QSPIC_DUMMYDATA</name>
	<description>Writing to this register generates a number of clock pulses to the SPI bus. During the last clock of this activity in the SPI bus, the QSPI_IOx data pads are in hi-z state. The data size of the access to this register can be 32-bits/16-bits/8-bits. The number of generated pulses is equal to: (size of AHB bus access)/(size of SPI bus). The size of SPI bus is equal to 1, 2, or 4 for Single, Dual, or Quad SPI mode respectively.
This register has meaning only when the controller is in Manual mode.</description>
	<bitRange>[31:0]</bitRange>
	<access>write-only</access>
	</field></fields>
</register><register>
	<name>QSPIC_ERASECMDA_REG</name>
	<description>The way of erasing in Auto mode (command register A)</description>
	<addressOffset>0x00000028</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0xffffffff</resetMask>
	<fields><field>
	<name>QSPIC_RES_INST</name>
	<description>The code value of the erase resume instruction</description>
	<bitRange>[31:24]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>QSPIC_SUS_INST</name>
	<description>The code value of the erase suspend instruction.</description>
	<bitRange>[23:16]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>QSPIC_WEN_INST</name>
	<description>The code value of the write enable instruction.</description>
	<bitRange>[15:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>QSPIC_ERS_INST</name>
	<description>The code value of the erase instruction.</description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>QSPIC_ERASECMDB_REG</name>
	<description>The way of erasing in Auto mode (command register B)</description>
	<addressOffset>0x0000002c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0xffffffff</resetMask>
	<fields><field>
	<name>QSPIC_RESSUS_DLY</name>
	<description>Defines a timer that counts the minimum allowed delay between an erase suspend command and the previous erase resume command (or the initial erase command).
0x00: Do not wait. The controller starts immediately to suspend the erase procedure.
0x01..0x3F: The controller waits for at least this number of 288 kHz clock cycles before the suspension of erasing. Time starts counting after the end of the previous erase resume command (or the initial erase command)</description>
	<bitRange>[29:24]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>QSPIC_ERSRES_HLD</name>
	<description>The controller must stay without flash memory reading requests for this number of AMBA hclk clock cycles, before to perform the command of erase or erase resume. Allowable range : 0xF - 0x0</description>
	<bitRange>[19:16]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>QSPIC_ERS_CS_HI</name>
	<description>After the execution of instructions: write enable, erase, erase suspend and erase resume, the QSPI_CS remains high for at least this number of QSPI_SCK clock cycles.</description>
	<bitRange>[14:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>QSPIC_EAD_TX_MD</name>
	<description>The mode of the SPI Bus during the address phase of the erase instruction
0x0: Single SPI
0x1: Dual
0x2: Quad
0x3: Reserved</description>
	<bitRange>[9:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>QSPIC_RES_TX_MD</name>
	<description>The mode of the SPI Bus during the transmission of the resume instruction
0x0: Single SPI
0x1: Dual
0x2: Quad
0x3: Reserved</description>
	<bitRange>[7:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>QSPIC_SUS_TX_MD</name>
	<description>The mode of the SPI Bus during the transmission of the suspend instruction.
0x0: Single SPI
0x1: Dual
0x2: Quad
0x3: Reserved</description>
	<bitRange>[5:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>QSPIC_WEN_TX_MD</name>
	<description>The mode of the SPI Bus during the transmission of the write enable instruction.
0x0: Single SPI
0x1: Dual
0x2: Quad
0x3: Reserved</description>
	<bitRange>[3:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>QSPIC_ERS_TX_MD</name>
	<description>The mode of the SPI Bus during the instruction phase of the erase instruction
0x0: Single SPI
0x1: Dual
0x2: Quad
0x3: Reserved</description>
	<bitRange>[1:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>QSPIC_ERASECTRL_REG</name>
	<description>Erase control register</description>
	<addressOffset>0x00000024</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0xffffffff</resetMask>
	<fields><field>
	<name>QSPIC_ERS_STATE</name>
	<description>It shows the progress of sector/block erasing (read only).
0x0: No Erase.
0x1: Pending erase request
0x2: Erase procedure is running
0x3: Suspended Erase procedure
0x4: Finishing the Erase procedure
0x5..0x7: Reserved</description>
	<bitRange>[27:25]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>QSPIC_ERASE_EN</name>
	<description>This bit has meaning only when the external device is a serial FLASH (QSPIC_SRAM_EN=0).
During Manual mode (QSPIC_AUTO_MD = 0): This bit is in read-only mode.
During Auto mode (QSPIC_AUTO_MD = 1). To request the erasing of the block/sector (QSPIC_ERS_ADDR, 12'b0) write 1 to this bit. This bit is cleared automatically with the end of erasing. Until the end of erasing the QSPIC_ERASE_EN remains in read-only mode. During the same period of time, the controller remains in Auto Mode (QSPIC_AUTO_MD goes in read-only mode).
In the case where the external device is a serial SRAM (QSPIC_SRAM_EN=1) this bit is in read-only mode.</description>
	<bitRange>[24:24]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>QSPIC_ERS_ADDR</name>
	<description>Defines the address of the block/sector that is requested to be erased.
If QSPIC_USE_32BA = 0 (24 bits addressing), bits QSPIC_ERASECTRL_REG[23-12] determine the block/ sector address bits [23-12].
QSPIC_ERASECTRL_REG[11-4] are ignored by the controller.
If QSPIC_USE_32BA = 1 (32 bits addressing) bits QSPIC_ERASECTRL_REG[23-4] determine the block / sectors address bits [31:12]</description>
	<bitRange>[23:4]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>QSPIC_GP_REG</name>
	<description>General purpose QSPIC register</description>
	<addressOffset>0x0000003c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000001f</resetMask>
	<fields><field>
	<name>QSPIC_PADS_SLEW</name>
	<description>QSPI pads slew rate control. Indicative values under certain conditions:
0x0: Rise = 1.7 V/ns, Fall = 1.9 V/ns (weak)
0x1: Rise = 2.0 V/ns, Fall = 2.3 V/ns
0x2: Rise = 2.3 V/ns, Fall = 2.6 V/ns
0x3: Rise = 2.4 V/ns, Fall = 2.7 V/ns (strong)
Conditions: FLASH pin capacitance 6 pF, Vcc = 1.8 V, T = 25 &#176;C and Idrive = 16 mA</description>
	<bitRange>[4:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>QSPIC_PADS_DRV</name>
	<description>QSPI pads drive current
0x0: 4 mA
0x1: 8 mA
0x2: 12 mA
0x3: 16 mA</description>
	<bitRange>[2:1]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>QSPIC_MEMBLEN_REG</name>
	<description>External memory burst length configuration</description>
	<addressOffset>0x00000044</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0xffffffff</resetMask>
	<fields><field>
	<name>QSPIC_T_CEM_CC</name>
	<description>Defines the maximum allowed time tCEM for which the QSPIC_CS can stay active (QSPI_CS = 0). It has meaning only when QSPIC_T_CEM_EN is equal to 1. See also the description of the QSPIC_T_CEM_EN for more details.
The tCEM is expressed in number of qspi clock cycles and can be calculated as follows:
tCEM / (qspi_clock_period)
If the result of the above equation is higher than 0x3FF, use the value 0x3FF.</description>
	<bitRange>[13:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>QSPIC_T_CEM_EN</name>
	<description>This bit enables the controlling of the maximum time tCEM for which the QSPI_CS remains active. It has meaning only when the Auto mode is active (QSPIC_AUTO_MD = 1) and the external device is a serial SRAM (QSPIC_SRAM_EN = 1). In the case where the external device is a serial Flash (QSPIC_SRAM_EN = 0) or the controller is in Manual mode (QSPIC_AUTO_MD = 0), this field has no any effect.
This feature is useful when the external serial device is a dynamic RAM that requires refresh. If the refresh is applied only when the device is in the idle state (QSPI_CS = 1), the time for which the device remains in the active state (QSPI_CS = 0) should be limited by a maximum threshold.
0:There is no any constraint regarding the maximum allowed time for which QSPI_CS can stay active. This is the case also when QSPIC_SRAM_EN = 0 or QSPIC_AUTO_MD = 0.
1:There is a maximum allowed time interval tCEM for which QSPI_CS can stay active during a burst access (for reading or writing of data). For the controller, this is considered as equal to QSPIC_T_CEM_CC x qspi_clock_period. In the case where the data transfer requires QSPI_CS to stays active for more than QSPIC_T_CEM_CC qspi clock cycles, the QSPI controller splits the access on the SPI bus in more than one bursts, by inserting inactive periods (QSPI_CS = 0) between them. This will cost extra clock cycles for the realization of the original access, due to the additional commands that are required in the SPI bus.
The value in QSPIC_T_CEM_CC should be updated every time where the frequency of the qspi clock is modified. The qspi clock frequency should not be decreased more than a lowest frequency. This is the lowest frequency that enables to be performed a 32-bit word read and write access, without violating the tCEM timing requirement (the QSPI controller allows to be performed at least the transferring of one beat of the requested burst, independent of the QSPIC_T_CEM_CC limit).</description>
	<bitRange>[3:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>QSPIC_MEMBLEN</name>
	<description>In this register, the expected behavior of the external memory device regarding the length of a burst operation is defined:
0x0: The external memory device is capable to implement incremental burst of unspecified length.
0x1: The external memory device implements a wrapping burst of length 4 bytes.
0x2: The external memory device implements a wrapping burst of length 8 bytes.
0x3: The external memory device implements a wrapping burst of length 16 bytes.
0x4: The external memory device implements a wrapping burst of length 32 bytes.
0x5: The external memory device implements a wrapping burst of length 64 bytes.
0x6 - 0x7 : Reserved
This setting is used by the QSPI controller when the Auto mode is enabled (QSPIC_AUTO_MD = 1) to handle the various burst requests of the AHB bus, in respect of the requirements of the external memory device.
The external memory device may need to be configured by applying special instruction to be defined the kind of the burst operation. This can be implemented by applying this special instruction with the QSPI controller in Manual mode (QSPIC_AUTO_MD = 1). Refer to the datasheet of the external device for more information.</description>
	<bitRange>[2:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>QSPIC_READDATA_REG</name>
	<description>Read data from SPI Bus for the Manual mode</description>
	<addressOffset>0x0000001c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0xffffffff</resetMask>
	<fields><field>
	<name>QSPIC_READDATA</name>
	<description>A read access at this register generates a data transfer from the external memory device to the QSPIC controller. The data is transferred using the selected mode of the SPI bus (SPI, Dual SPI, Quad SPI). The data size of the access to this register can be 32-bits/16-bits/8-bits and is equal to the number of the transferred bits.
This register has meaning only when the controller is in Manual mode.</description>
	<bitRange>[31:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>QSPIC_RECVDATA_REG</name>
	<description>Received data for the Manual mode</description>
	<addressOffset>0x00000008</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0xffffffff</resetMask>
	<fields><field>
	<name>QSPIC_RECVDATA</name>
	<description>This register contains the received data when the QSPIC_READDATA_REG register is used in Manual mode, to retrieve data from the external memory device and QSPIC_HRDY_MD=1 and QSPIC_BUSY=0.</description>
	<bitRange>[31:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>QSPIC_STATUSCMD_REG</name>
	<description>The way of reading the status of external device in Auto mode</description>
	<addressOffset>0x00000034</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0xffffffff</resetMask>
	<fields><field>
	<name>QSPIC_STSDLY_SEL</name>
	<description>Defines the timer which is used to count the delay that it has to wait before to read the FLASH Status Register, after an erase or an erase resume command.
0: The delay is controlled by the QSPIC_RESSTS_DLY which counts on the qspi clock.
1: The delay is controlled by the QSPIC_RESSUS_DLY which counts on the 288 kHz clock.</description>
	<bitRange>[22:22]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>QSPIC_RESSTS_DLY</name>
	<description>Defines a timer that counts the minimum required delay between the reading of the status register and of the previous erase or erase resume instruction.
0x00: Do not wait. The controller starts to reading the Flash memory status register immediately.
0x01..0x3F: The controller waits for at least this number of QSPI_CLK cycles and afterwards it starts to reading the Flash memory status register. The timer starts to count after the end of the previous erase or erase resume command.
The actual timer that will be used by the controller before the reading of the Flash memory status register is defined by the QSPIC_STSDLY_SEL.</description>
	<bitRange>[21:16]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>QSPIC_BUSY_VAL</name>
	<description>Defines the value of the Busy bit which means that the flash is busy.
0: The flash is busy when the Busy bit is equal to 0.
1: The flash is busy when the Busy bit is equal to 1.</description>
	<bitRange>[15:15]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>QSPIC_BUSY_POS</name>
	<description>Defines the bit of the Flash status register which represents the Busy bit (0x7 - 0x0).</description>
	<bitRange>[14:12]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>QSPIC_RSTAT_RX_MD</name>
	<description>The mode of the SPI Bus during the reception phase of the read status instruction, where the value of status register is retrieved.
0x0: Single SPI
0x1: Dual
0x2: Quad
0x3: Reserved</description>
	<bitRange>[11:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>QSPIC_RSTAT_TX_MD</name>
	<description>The mode of the SPI Bus during the instruction phase of the read status instruction.
0x0: Single SPI
0x1: Dual
0x2: Quad
0x3: Reserved</description>
	<bitRange>[9:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>QSPIC_RSTAT_INST</name>
	<description>The code value of the read status instruction.
It is transmitted during the instruction phase of the read status instruction.</description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>QSPIC_STATUS_REG</name>
	<description>The status register of the QSPI controller</description>
	<addressOffset>0x00000014</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0xffffffff</resetMask>
	<fields><field>
	<name>QSPIC_BUSY</name>
	<description>The status of the SPI Bus.
0: The SPI Bus is idle
1: The SPI Bus is active. Read data, write data or dummy data activity is in progress.
Has meaning only in Manual mode and only when QSPIC_HRDY_MD = 1.</description>
	<bitRange>[0:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>QSPIC_WRITEDATA_REG</name>
	<description>Write data to SPI Bus for the Manual mode</description>
	<addressOffset>0x00000018</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0xffffffff</resetMask>
	<fields><field>
	<name>QSPIC_WRITEDATA</name>
	<description>Writing to this register is generating a data transfer from the controller to the external memory device. The data written in this register, is then transferred to the memory using the selected mode of the SPI bus (SPI, Dual SPI, Quad SPI). The data size of the access to this register can be 32-bits/16-bits/8-bits and is equal to the number of the transferred bits.
This register has meaning only when the controller is in Manual mode.</description>
	<bitRange>[31:0]</bitRange>
	<access>write-only</access>
	</field></fields>
</register></registers>
</peripheral><peripheral>
	<name>QUADEC</name>
	<version>1.0</version>
	<description>QUADEC registers</description>
	<groupName>Peripheral_Registers</groupName>
	<baseAddress>0x50000500</baseAddress>
	<size>0</size>
	<addressBlock>
	<offset>0</offset>
	<size>28</size>
	<usage>registers</usage>
</addressBlock>

	<registers>
	<register>
	<name>QDEC_CLOCKDIV_REG</name>
	<description>Clock divider register</description>
	<addressOffset>0x0000000c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x000003e7</resetValue>
	<resetMask>0x000007ff</resetMask>
	<fields><field>
	<name>QDEC_PRESCALER_EN</name>
	<description>0 = no prescaler enabled
1 = in sleep and active mode, quadrature clock is divided by 2</description>
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>QDEC_CLOCKDIV</name>
	<description>Contains the number of the input clock cycles minus one, that are required to generate one logic clock cycle.
Clock divider is bypassed when system runs at LP_CLK</description>
	<bitRange>[9:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>QDEC_CTRL2_REG</name>
	<description>Quad Decoder port selection register</description>
	<addressOffset>0x00000010</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00007321</resetValue>
	<resetMask>0x00007fff</resetMask>
	<fields><field>
	<name>QDEC_CHZ_EVENT_MODE</name>
	<description>0 = Normal quadrature counting
1 = Counts rising and falling edge of both ports (if both ports change at the same time, counter increases by 1)</description>
	<bitRange>[14:14]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>QDEC_CHY_EVENT_MODE</name>
	<description>0 = Normal quadrature counting
1 = Counts rising and falling edge of both ports (if both ports change at the same time, counter increases by 1)</description>
	<bitRange>[13:13]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>QDEC_CHX_EVENT_MODE</name>
	<description>0 = Normal quadrature counting
1 = Counts rising and falling edge of both ports (if both ports change at the same time, counter increases by 1)</description>
	<bitRange>[12:12]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>QDEC_CHZ_PORT_SEL</name>
	<description>Defines which GPIOs are mapped on Channel Z
0: none
1: P0_00 -&gt; CHZ_A, P0_01 -&gt; CHZ_B
2: P0_02 -&gt; CHZ_A, P0_03 -&gt; CHZ_B
3: P0_04 -&gt; CHZ_A, P0_05 -&gt; CHZ_B
4: P0_08 -&gt; CHZ_A, P0_09 -&gt; CHZ_B
5: P0_10 -&gt; CHZ_A, P0_11 -&gt; CHZ_B
6: P1_00 -&gt; CHZ_A, P1_02 -&gt; CHZ_B
7: P1_03 -&gt; CHZ_A, P1_05 -&gt; CHZ_B
8: P1_06 -&gt; CHZ_A, P1_07 -&gt; CHZ_B
9: P1_08 -&gt; CHZ_A, P1_09 -&gt; CHZ_B
10: P1_10 -&gt; CHZ_A, P1_11 -&gt; CHZ_B
11: P1_12 -&gt; CHZ_A, P1_01 -&gt; CHZ_B
12: P1_04 -&gt; CHZ_A, P1_15 -&gt; CHZ_B
13-31: none</description>
	<bitRange>[11:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>QDEC_CHY_PORT_SEL</name>
	<description>Defines which GPIOs are mapped on Channel Y
0: none
1: P0_00 -&gt; CHY_A, P0_01 -&gt; CHY_B
2: P0_02 -&gt; CHY_A, P0_03 -&gt; CHY_B
3: P0_04 -&gt; CHY_A, P0_05 -&gt; CHY_B
4: P0_08 -&gt; CHY_A, P0_09 -&gt; CHY_B
5: P0_10 -&gt; CHY_A, P0_11 -&gt; CHY_B
6: P1_00 -&gt; CHY_A, P1_02 -&gt; CHY_B
7: P1_03 -&gt; CHY_A, P1_05 -&gt; CHY_B
8: P1_06 -&gt; CHY_A, P1_07 -&gt; CHY_B
9: P1_08 -&gt; CHY_A, P1_09 -&gt; CHY_B
10: P1_10 -&gt; CHY_A, P1_11 -&gt; CHY_B
11: P1_12 -&gt; CHY_A, P1_01 -&gt; CHY_B
12: P1_04 -&gt; CHY_A, P1_15 -&gt; CHY_B
13-31: none</description>
	<bitRange>[7:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>QDEC_CHX_PORT_SEL</name>
	<description>Defines which GPIOs are mapped on Channel X
0: none
1: P0_00 -&gt; CHX_A, P0_01 -&gt; CHX_B
2: P0_02 -&gt; CHX_A, P0_03 -&gt; CHX_B
3: P0_04 -&gt; CHX_A, P0_05 -&gt; CHX_B
4: P0_08 -&gt; CHX_A, P0_09 -&gt; CHX_B
5: P0_10 -&gt; CHX_A, P0_11 -&gt; CHX_B
6: P1_00 -&gt; CHX_A, P1_02 -&gt; CHX_B
7: P1_03 -&gt; CHX_A, P1_05 -&gt; CHX_B
8: P1_06 -&gt; CHX_A, P1_07 -&gt; CHX_B
9: P1_08 -&gt; CHX_A, P1_09 -&gt; CHX_B
10: P1_10 -&gt; CHX_A, P1_11 -&gt; CHX_B
11: P1_12 -&gt; CHX_A, P1_01 -&gt; CHX_B
12: P1_04 -&gt; CHX_A, P1_15 -&gt; CHX_B
13-31: none</description>
	<bitRange>[3:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>QDEC_CTRL_REG</name>
	<description>Quad Decoder control register</description>
	<addressOffset>0x00000000</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000010</resetValue>
	<resetMask>0x000007ff</resetMask>
	<fields><field>
	<name>QDEC_IRQ_THRES</name>
	<description>Defines the number of events on either counter (X or Y or Z) that need to be reached before an interrupt is generated. Events are equal to QDEC_IRQ_THRES+1.</description>
	<bitRange>[10:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>QDEC_IRQ_STATUS</name>
	<description>1 = Interrupt has occurred
0 = No interrupt pending
Writing 1 clears the pending interrupt </description>
	<bitRange>[2:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>QDEC_EVENT_CNT_CLR</name>
	<description>Writing 1 QDEC_EVENT_CNT_REG is cleared</description>
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>QDEC_IRQ_ENABLE</name>
	<description>0 = Interrupt is masked
1 = Interrupt is enabled </description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>QDEC_EVENT_CNT_REG</name>
	<description>Event counter register</description>
	<addressOffset>0x00000018</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x000000ff</resetMask>
	<fields><field>
	<name>QDEC_EVENT_CNT</name>
	<description>Gives the number of events at all channels.</description>
	<bitRange>[7:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>QDEC_XCNT_REG</name>
	<description>Counter value of the X Axis</description>
	<addressOffset>0x00000004</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>QDEC_X_CNT</name>
	<description>Contains a signed value of the events. Zero when channel is disabled </description>
	<bitRange>[15:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>QDEC_YCNT_REG</name>
	<description>Counter value of the Y Axis</description>
	<addressOffset>0x00000008</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>QDEC_Y_CNT</name>
	<description>Contains a signed value of the events. Zero when channel is disabled</description>
	<bitRange>[15:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>QDEC_ZCNT_REG</name>
	<description>Counter value of the Z Axis</description>
	<addressOffset>0x00000014</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>QDEC_Z_CNT</name>
	<description>Contains a signed value of the events. Zero when channel is disabled</description>
	<bitRange>[15:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register></registers>
</peripheral><peripheral>
	<name>RTC</name>
	<version>1.0</version>
	<description>RTC registers</description>
	<groupName>Peripheral_Registers</groupName>
	<baseAddress>0x50000400</baseAddress>
	<size>0</size>
	<addressBlock>
	<offset>0</offset>
	<size>152</size>
	<usage>registers</usage>
</addressBlock>

	<registers>
	<register>
	<name>RTC_ALARM_ENABLE_REG</name>
	<description>RTC Alarm Enable Register</description>
	<addressOffset>0x00000018</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000003f</resetMask>
	<fields><field>
	<name>RTC_ALARM_MNTH_EN</name>
	<description>Alarm on month enable. Enable to trigger alarm when data specified in Calendar Alarm Register (M_T and M_U) has been reached.</description>
	<bitRange>[5:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RTC_ALARM_DATE_EN</name>
	<description>Alarm on date enable. Enable to trigger alarm when data specified in Calendar Alarm Register (D_T and D_U) has been reached.</description>
	<bitRange>[4:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RTC_ALARM_HOUR_EN</name>
	<description>Alarm on hour enable. Enable to trigger alarm when data specified in Time Alarm Register (PM, HR_T and HR_U) has been reached.</description>
	<bitRange>[3:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RTC_ALARM_MIN_EN</name>
	<description>Alarm on minute enable. Enable to trigger alarm when data specified in Time Alarm Register (M_T and M_U) has been reached.</description>
	<bitRange>[2:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RTC_ALARM_SEC_EN</name>
	<description>Alarm on second enable. Enable to trigger alarm when data specified in Time Alarm Register (S_T and S_U) has been reached.</description>
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RTC_ALARM_HOS_EN</name>
	<description>Alarm on hundredths of a second enable. Enable to trigger alarm when data specified in Time Alarm Register (H_T and H_U) has been reached.</description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>RTC_CALENDAR_ALARM_REG</name>
	<description>RTC Calendar Alarm Register</description>
	<addressOffset>0x00000014</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0xffffffff</resetMask>
	<fields><field>
	<name>RTC_CAL_D_T</name>
	<description>Date tens. Represented in BCD digit (0-3).</description>
	<bitRange>[13:12]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RTC_CAL_D_U</name>
	<description>Date units. Represented in BCD digit (0-9).</description>
	<bitRange>[11:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RTC_CAL_M_T</name>
	<description>Month tens. Represented in BCD digit (0-1).</description>
	<bitRange>[7:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RTC_CAL_M_U</name>
	<description>Month units. Represented in BCD digit (0-9).</description>
	<bitRange>[6:3]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>RTC_CALENDAR_REG</name>
	<description>RTC Calendar Register</description>
	<addressOffset>0x0000000c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x2000010f</resetValue>
	<resetMask>0xffffffff</resetMask>
	<fields><field>
	<name>RTC_CAL_CH</name>
	<description>The value in this register has altered since last read. Read and clear</description>
	<bitRange>[31:31]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RTC_CAL_C_T</name>
	<description>Century tens. Represented in BCD digit (1-2).</description>
	<bitRange>[29:28]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RTC_CAL_C_U</name>
	<description>Century units. Represented in BCD digit (0-9).</description>
	<bitRange>[27:24]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RTC_CAL_Y_T</name>
	<description>Year tens. Represented in BCD digit (0-9).</description>
	<bitRange>[23:20]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RTC_CAL_Y_U</name>
	<description>Year units. Represented in BCD digit (0-9).</description>
	<bitRange>[19:16]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RTC_CAL_D_T</name>
	<description>Date tens. Represented in BCD digit (0-3).</description>
	<bitRange>[13:12]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RTC_CAL_D_U</name>
	<description>Date units. Represented in BCD digit (0-9).</description>
	<bitRange>[11:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RTC_CAL_M_T</name>
	<description>Month tens. Represented in BCD digit (0-1).</description>
	<bitRange>[7:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RTC_CAL_M_U</name>
	<description>Month units. Represented in BCD digit (0-9).</description>
	<bitRange>[6:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RTC_DAY</name>
	<description>Day of the week (arbitrary) units. Represented in BCD digit (0-7).</description>
	<bitRange>[2:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>RTC_CONTROL_REG</name>
	<description>RTC Control Register</description>
	<addressOffset>0x00000000</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000003</resetValue>
	<resetMask>0x00000003</resetMask>
	<fields><field>
	<name>RTC_CAL_DISABLE</name>
	<description>When this field is set high the RTC stops incrementing the calendar value.</description>
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RTC_TIME_DISABLE</name>
	<description>When this field is set high the RTC stops incrementing the time value.</description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>RTC_EVENT_CTRL_REG</name>
	<description>RTC Event Control Register</description>
	<addressOffset>0x00000080</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00000003</resetMask>
	<fields><field>
	<name>RTC_PDC_EVENT_EN</name>
	<description>0 = Event to PDC is disabled. No clear any pending event
1 = Even to PDC is enabled</description>
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>RTC_EVENT_FLAGS_REG</name>
	<description>RTC Event Flags Register</description>
	<addressOffset>0x0000001c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000007f</resetMask>
	<fields><field>
	<name>RTC_EVENT_ALRM</name>
	<description>Alarm event flag. Indicate that alarm event occurred since the last reset.</description>
	<bitRange>[6:6]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>RTC_EVENT_MNTH</name>
	<description>Month rolls over event flag. Indicate that month rolls over event occurred since the last reset.</description>
	<bitRange>[5:5]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>RTC_EVENT_DATE</name>
	<description>Date rolls over event flag. Indicate that date rolls over event occurred since the last reset.</description>
	<bitRange>[4:4]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>RTC_EVENT_HOUR</name>
	<description>Hour rolls over event flag. Indicate that hour rolls over event occurred since the last reset.</description>
	<bitRange>[3:3]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>RTC_EVENT_MIN</name>
	<description>Minute rolls over event flag. Indicate that minute rolls over event occurred since the last reset.</description>
	<bitRange>[2:2]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>RTC_EVENT_SEC</name>
	<description>Second rolls over event flag. Indicate that second rolls over event occurred since the last reset.</description>
	<bitRange>[1:1]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>RTC_EVENT_HOS</name>
	<description>Hundredths of a second event flag. Indicate that hundredths of a second rolls over event occurred since the last reset.</description>
	<bitRange>[0:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>RTC_HOUR_MODE_REG</name>
	<description>RTC Hour Mode Register</description>
	<addressOffset>0x00000004</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00000001</resetMask>
	<fields><field>
	<name>RTC_HMS</name>
	<description>When this field is set high the RTC operates in 12 hour clock mode; otherwise, times are in 24 hour clock format.</description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>RTC_INTERRUPT_DISABLE_REG</name>
	<description>RTC Interrupt Disable Register</description>
	<addressOffset>0x00000024</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000007f</resetMask>
	<fields><field>
	<name>RTC_ALRM_INT_DIS</name>
	<description>Interrupt on alarm disable. Disable to issue the interrupt when alarm event occurred.</description>
	<bitRange>[6:6]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>RTC_MNTH_INT_DIS</name>
	<description>Interrupt on month disable. Disable to issue the interrupt when month event occurred.</description>
	<bitRange>[5:5]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>RTC_DATE_INT_DIS</name>
	<description>Interrupt on date disable. Disable to issue the interrupt when date event occurred.</description>
	<bitRange>[4:4]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>RTC_HOUR_INT_DIS</name>
	<description>IInterrupt on hour disable. Disable to issue the interrupt when hour event occurred.</description>
	<bitRange>[3:3]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>RTC_MIN_INT_DIS</name>
	<description>Interrupt on minute disable. Disable to issue the interrupt when minute event occurred.</description>
	<bitRange>[2:2]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>RTC_SEC_INT_DIS</name>
	<description>Interrupt on second disable. Disable to issue the interrupt when second event occurred.</description>
	<bitRange>[1:1]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>RTC_HOS_INT_DIS</name>
	<description>Interrupt on hundredths of a second disable. Disable to issue the interrupt when hundredths of a second event occurred.</description>
	<bitRange>[0:0]</bitRange>
	<access>write-only</access>
	</field></fields>
</register><register>
	<name>RTC_INTERRUPT_ENABLE_REG</name>
	<description>RTC Interrupt Enable Register</description>
	<addressOffset>0x00000020</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000007f</resetMask>
	<fields><field>
	<name>RTC_ALRM_INT_EN</name>
	<description>Interrupt on alarm enable. Enable to issue the interrupt when alarm event occurred.</description>
	<bitRange>[6:6]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>RTC_MNTH_INT_EN</name>
	<description>Interrupt on month enable. Enable to issue the interrupt when month event occurred.</description>
	<bitRange>[5:5]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>RTC_DATE_INT_EN</name>
	<description>Interrupt on date enable. Enable to issue the interrupt when date event occurred.</description>
	<bitRange>[4:4]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>RTC_HOUR_INT_EN</name>
	<description>Interrupt on hour enable. Enable to issue the interrupt when hour event occurred.</description>
	<bitRange>[3:3]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>RTC_MIN_INT_EN</name>
	<description>Interrupt on minute enable. Enable to issue the interrupt when minute event occurred.</description>
	<bitRange>[2:2]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>RTC_SEC_INT_EN</name>
	<description>Interrupt on second enable. Enable to issue the interrupt when second event occurred.</description>
	<bitRange>[1:1]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>RTC_HOS_INT_EN</name>
	<description>Interrupt on hundredths of a second enable. Enable to issue the interrupt when hundredths of a second event occurred.</description>
	<bitRange>[0:0]</bitRange>
	<access>write-only</access>
	</field></fields>
</register><register>
	<name>RTC_INTERRUPT_MASK_REG</name>
	<description>RTC Interrupt Mask Register</description>
	<addressOffset>0x00000028</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x0000007f</resetValue>
	<resetMask>0x0000007f</resetMask>
	<fields><field>
	<name>RTC_ALRM_INT_MSK</name>
	<description>Mask alarm interrupt. It can be cleared (set) by setting corresponding bit (ALRM) in Interrupt Enable Register (Interrupt Disable Register).</description>
	<bitRange>[6:6]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>RTC_MNTH_INT_MSK</name>
	<description>Mask month interrupt. It can be cleared (set) by setting corresponding bit (MNTH) in Interrupt Enable Register (Interrupt Disable Register).</description>
	<bitRange>[5:5]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>RTC_DATE_INT_MSK</name>
	<description>Mask date interrupt. It can be cleared (set) by setting corresponding bit (DATE) in Interrupt Enable Register (Interrupt Disable Register).</description>
	<bitRange>[4:4]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>RTC_HOUR_INT_MSK</name>
	<description>Mask hour interrupt. It can be cleared (set) by setting corresponding bit (HOUR) in Interrupt Enable Register (Interrupt Disable Register).</description>
	<bitRange>[3:3]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>RTC_MIN_INT_MSK</name>
	<description>Mask minute interrupt. It can be cleared (set) by setting corresponding bit (MIN) in Interrupt Enable Register (Interrupt Disable Register).</description>
	<bitRange>[2:2]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>RTC_SEC_INT_MSK</name>
	<description>Mask second interrupt. It can be cleared (set) by setting corresponding bit (SEC) in Interrupt Enable Register (Interrupt Disable Register).</description>
	<bitRange>[1:1]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>RTC_HOS_INT_MSK</name>
	<description>Mask hundredths of a second interrupt. It can be cleared (set) by setting corresponding bit (HOS) in Interrupt Enable Register (Interrupt Disable Register).</description>
	<bitRange>[0:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>RTC_KEEP_RTC_REG</name>
	<description>RTC Keep RTC Register</description>
	<addressOffset>0x00000030</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000001</resetValue>
	<resetMask>0x00000001</resetMask>
	<fields><field>
	<name>RTC_KEEP</name>
	<description>Keep RTC. When high, the time and calendar registers and any other registers which directly affect or are affected by the time and calendar registers are NOT reset when software reset is applied. When low, the software reset will reset every register except the keep RTC and control registers.</description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>RTC_PDC_EVENT_CLEAR_REG</name>
	<description>RTC PDC Event Clear Register</description>
	<addressOffset>0x0000008c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00000001</resetMask>
	<fields><field>
	<name>PDC_EVENT_CLEAR</name>
	<description>On read, PDC event is cleared</description>
	<bitRange>[0:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>RTC_PDC_EVENT_CNT_REG</name>
	<description>RTC PDC Event Counter Register</description>
	<addressOffset>0x00000094</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00001fff</resetMask>
	<fields><field>
	<name>RTC_PDC_EVENT_CNT</name>
	<description>It gives the current value of the PDC event counter (0 to RTC_PDC_EVENT_PERIOD)</description>
	<bitRange>[12:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>RTC_PDC_EVENT_PERIOD_REG</name>
	<description>RTC PDC Event Period Register</description>
	<addressOffset>0x00000088</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00001fff</resetMask>
	<fields><field>
	<name>RTC_PDC_EVENT_PERIOD</name>
	<description>RTC wil send an event to PDC (if RTC_PDC_EVENT_EN = 1) every (RTC_PDC_EVENT_PERIOD + 1)*10 ms</description>
	<bitRange>[12:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>RTC_STATUS_REG</name>
	<description>RTC Status Register</description>
	<addressOffset>0x0000002c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x0000000f</resetValue>
	<resetMask>0x0000000f</resetMask>
	<fields><field>
	<name>RTC_VALID_CAL_ALM</name>
	<description>Valid Calendar Alarm. If cleared then indicates that invalid entry occurred when writing to Calendar Alarm Register.</description>
	<bitRange>[3:3]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>RTC_VALID_TIME_ALM</name>
	<description>Valid Time Alarm. If cleared then indicates that invalid entry occurred when writing to Time Alarm Register.</description>
	<bitRange>[2:2]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>RTC_VALID_CAL</name>
	<description>Valid Calendar. If cleared then indicates that invalid entry occurred when writing to Calendar Register.</description>
	<bitRange>[1:1]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>RTC_VALID_TIME</name>
	<description>Valid Time. If cleared then indicates that invalid entry occurred when writing to Time Register.</description>
	<bitRange>[0:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>RTC_TIME_ALARM_REG</name>
	<description>RTC Time Alarm Register</description>
	<addressOffset>0x00000010</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0xffffffff</resetMask>
	<fields><field>
	<name>RTC_TIME_PM</name>
	<description>In 12 hour clock mode, indicates PM when set.</description>
	<bitRange>[30:30]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RTC_TIME_HR_T</name>
	<description>Hours tens. Represented in BCD digit (0-2).</description>
	<bitRange>[29:28]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RTC_TIME_HR_U</name>
	<description>Hours units. Represented in BCD digit (0-9).</description>
	<bitRange>[27:24]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RTC_TIME_M_T</name>
	<description>Minutes tens. Represented in BCD digit (0-5).</description>
	<bitRange>[22:20]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RTC_TIME_M_U</name>
	<description>Minutes units. Represented in BCD digit (0-9).</description>
	<bitRange>[19:16]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RTC_TIME_S_T</name>
	<description>Seconds tens. Represented in BCD digit (0-9).</description>
	<bitRange>[14:12]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RTC_TIME_S_U</name>
	<description>Seconds units. Represented in BCD digit (0-9).</description>
	<bitRange>[11:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RTC_TIME_H_T</name>
	<description>Hundredths of a second tens. Represented in BCD digit (0-9).</description>
	<bitRange>[7:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RTC_TIME_H_U</name>
	<description>Hundredths of a second units. Represented in BCD digit (0-9).</description>
	<bitRange>[3:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>RTC_TIME_REG</name>
	<description>RTC Time Register</description>
	<addressOffset>0x00000008</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0xffffffff</resetMask>
	<fields><field>
	<name>RTC_TIME_CH</name>
	<description>The value in this register has altered since last read. Read and clear.</description>
	<bitRange>[31:31]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RTC_TIME_PM</name>
	<description>In 12 hour clock mode, indicates PM when set.</description>
	<bitRange>[30:30]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RTC_TIME_HR_T</name>
	<description>Hours tens. Represented in BCD digit (0-2).</description>
	<bitRange>[29:28]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RTC_TIME_HR_U</name>
	<description>Hours units. Represented in BCD digit (0-9).</description>
	<bitRange>[27:24]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RTC_TIME_M_T</name>
	<description>Minutes tens. Represented in BCD digit (0-5).</description>
	<bitRange>[22:20]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RTC_TIME_M_U</name>
	<description>Minutes units. Represented in BCD digit (0-9).</description>
	<bitRange>[19:16]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RTC_TIME_S_T</name>
	<description>Seconds tens. Represented in BCD digit (0-9).</description>
	<bitRange>[14:12]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RTC_TIME_S_U</name>
	<description>Seconds units. Represented in BCD digit (0-9).</description>
	<bitRange>[11:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RTC_TIME_H_T</name>
	<description>Hundredths of a second tens. Represented in BCD digit (0-9).</description>
	<bitRange>[7:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RTC_TIME_H_U</name>
	<description>Hundredths of a second units. Represented in BCD digit (0-9).</description>
	<bitRange>[3:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register></registers>
</peripheral><peripheral>
	<name>SDADC</name>
	<version>1.0</version>
	<description>SDADC registers</description>
	<groupName>Peripheral_Registers</groupName>
	<baseAddress>0x50020400</baseAddress>
	<size>0</size>
	<addressBlock>
	<offset>0</offset>
	<size>32</size>
	<usage>registers</usage>
</addressBlock>

	<registers>
	<register>
	<name>SDADC_AUDIO_FILT_REG</name>
	<description>Sigma Delta ADC Audio Filter Register</description>
	<addressOffset>0x0000001c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x001fffff</resetMask>
	<fields><field>
	<name>SDADC_CIC_OFFSET</name>
	<description>Constant CIC offset</description>
	<bitRange>[20:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>SDADC_CLEAR_INT_REG</name>
	<description>Sigma Delta ADC Clear Interrupt Register</description>
	<addressOffset>0x00000014</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0xffffffff</resetMask>
	<fields><field>
	<name>SDADC_CLR_INT</name>
	<description>Writing any value to this register will clear the ADC_INT interrupt. Reading returns 0. </description>
	<bitRange>[31:0]</bitRange>
	<access>write-only</access>
	</field></fields>
</register><register>
	<name>SDADC_CTRL_REG</name>
	<description>Sigma Delta ADC Control Register</description>
	<addressOffset>0x00000000</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x001fffff</resetMask>
	<fields><field>
	<name>SDADC_VREF_TO_PAD</name>
	<description>Connect internal SDADC reference voltage VREF (0.9 V) to P1[5]
0: Disconnected (default)
1: Connected</description>
	<bitRange>[20:20]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SDADC_MODE</name>
	<description>Select the mode of operation for the SDADC
0: Sensor mode
1: Audio mode</description>
	<bitRange>[19:19]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SDADC_DMA_EN</name>
	<description>0: DMA functionality disabled
1: DMA functionality enabled</description>
	<bitRange>[18:18]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SDADC_MINT</name>
	<description>0: Disable (mask) SDADC_ADC_INT.
1: Enable SDADC_ADC_INT to ICU.</description>
	<bitRange>[17:17]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SDADC_INT</name>
	<description>1: AD conversion ready and has generated an interrupt. Must be cleared by writing any value to SDADC_CLEAR_INT_REG.</description>
	<bitRange>[16:16]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>SDADC_LDO_OK</name>
	<description>1: Internal LDO is ready for use</description>
	<bitRange>[15:15]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>SDADC_VREF_SEL</name>
	<description>Select the reference input:
00: VREFN=internal VREFP=internal
01: VREFN=internal VREFP=external (pin P1[5])
10: VREFN=external (pin P1[6]) VREFP=internal
11: VREFN=external (pin P1[6]) VREFP=external(pin P1[5])</description>
	<bitRange>[14:13]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SDADC_CONT</name>
	<description>0: Manual ADC mode, a single result will be generated after setting the SDADC_START bit.
1: Continuous ADC mode, new ADC results will be constantly stored in SDADC_RESULT_REG. Still SDADC_START has to be set to start the execution. Wait for SDADC_START to become zero after clearing the SDADC_CONT bit to stop the continuous mode.</description>
	<bitRange>[12:12]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SDADC_OSR</name>
	<description>Oversample Rate in sensor mode. SDADC_MODE = 0x1
0: 256x
1: 512x
2: 1024x
3: 2048x
The OSR in audio mode is fixed: OSR = 62.5</description>
	<bitRange>[11:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SDADC_SE</name>
	<description>0: Differential mode
1: Single ended mode (Input selection negative side is ignored)</description>
	<bitRange>[9:9]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SDADC_INN_SEL</name>
	<description>Input selection of negative side.
0: ADC0/P1[00]
1: ADC1/P1[01]
2: ADC2/P1[02]
3: ADC3/P0[10]
4: ADC4/P1[05]
5: ADC5/P1[06]
6: ADC6/P1[09]
7: ADC7/P1[11]</description>
	<bitRange>[8:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SDADC_INP_SEL</name>
	<description>Input selection of positive side.
0: ADC0/P1[00]
1: ADC1/P1[01]
2: ADC2/P1[02]
3: ADC3/P0[10]
4: ADC4/P1[05]
5: ADC5/P1[06]
6: ADC6/P1[09]
7: ADC7/P1[11]
8: VBAT (via 4x attenuator, INN connected to ground)</description>
	<bitRange>[5:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SDADC_START</name>
	<description>0: ADC conversion ready.
1: If a 1 is written, the ADC starts a conversion. After the conversion this bit will be set to 0 and the SDADC_INT bit will be set. It is not allowed to write this bit while it is not (yet) zero.</description>
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SDADC_EN</name>
	<description>0: LDO is off and ADC is disabled.
1: LDO, bias currents and modulator are enabled.</description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>SDADC_GAIN_CORR_REG</name>
	<description>Sigma Delta ADC Gain Correction Register</description>
	<addressOffset>0x0000000c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x000003ff</resetMask>
	<fields><field>
	<name>SDADC_GAIN_CORR</name>
	<description>Gain adjust</description>
	<bitRange>[9:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>SDADC_OFFS_CORR_REG</name>
	<description>Sigma Delta ADC Offset Correction Register</description>
	<addressOffset>0x00000010</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>SDADC_OFFS_CORR</name>
	<description>Offset adjust</description>
	<bitRange>[9:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>SDADC_PGA_CTRL_REG</name>
	<description>Sigma Delta ADC PGA Control Registers</description>
	<addressOffset>0x00000004</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000020</resetValue>
	<resetMask>0x00000fff</resetMask>
	<fields><field>
	<name>PGA_GAIN</name>
	<description>Select the PGA gain select:
0: -12 dB
1: -6 dB
2: 0 dB
3: 6 dB
4: 12 dB
5: 18 dB
6: 24 dB
7: 30 dB</description>
	<bitRange>[11:9]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PGA_SINGLE</name>
	<description>Use PGA in single ended mode
0: Differential mode (default)
1: Use N-branch as single ended mode
2: Use P-branch as single ended mode
3: Reserved (do not use)</description>
	<bitRange>[8:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PGA_MUTE</name>
	<description>Mute the PGA output
0: Unmuted (default)
1: Mute</description>
	<bitRange>[6:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PGA_BIAS</name>
	<description>Configure the PGA bias control:
0: 0.40 x Ibias
1: 0.44 x Ibias
2: 0.50 x Ibias
3: 0.57 x Ibias
4: 0.66 x Ibias
5: 0.80 x Ibias
6: 1.00 x Ibias
7: 1.33 x Ibias</description>
	<bitRange>[5:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PGA_SHORTIN</name>
	<description>PGA input short
0: Normal mode (default)
1: Short PGA inputs</description>
	<bitRange>[2:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PGA_EN</name>
	<description>PGA enable:
00: both branches of PGA disabled
01: Positive branch of PGA enabled, Negative branch disabled
10: Positive branch of PGA disabled, Negative branch enabled
11: Both branches of PGA enabled</description>
	<bitRange>[1:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>SDADC_RESULT_REG</name>
	<description>Sigma Delta ADC Result Register</description>
	<addressOffset>0x00000018</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>SDADC_VAL</name>
	<description>Returns up to 16 bits linear value of the last AD conversion. The effective resolution depends on the OSR used.</description>
	<bitRange>[15:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register></registers>
</peripheral><peripheral>
	<name>SPI</name>
	<version>1.0</version>
	<description>SPI registers</description>
	<groupName>Peripheral_Registers</groupName>
	<baseAddress>0x50020200</baseAddress>
	<size>0</size>
	<addressBlock>
	<offset>0</offset>
	<size>48</size>
	<usage>registers</usage>
</addressBlock>

	<registers>
	<register>
	<name>SPI_CLOCK_REG</name>
	<description>Spi clock register</description>
	<addressOffset>0x00000008</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000007f</resetMask>
	<fields><field>
	<name>SPI_CLK_DIV</name>
	<description>Applicable only in master mode
Defines the spi clock frequency in master only mode
SPI_CLK = module_clk/2*(SPI_CLK_DIV+1) when SPI_CLK_DIV not 0x7F
if SPI_CLK_DIV = 0x7F then SPI_CLK = module_clk</description>
	<bitRange>[6:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>SPI_CONFIG_REG</name>
	<description>Spi control register</description>
	<addressOffset>0x00000004</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x000000ff</resetMask>
	<fields><field>
	<name>SPI_SLAVE_EN</name>
	<description>0 = SPI module master mode
1 = SPI module slave mode</description>
	<bitRange>[7:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SPI_WORD_LENGTH</name>
	<description>Define the spi word length = 1+ SPI_WORD_LENGTH (range 4 to 32)</description>
	<bitRange>[6:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SPI_MODE</name>
	<description>Define the spi mode (CPOL, CPHA)
0 = new data on falling, capture on rising, clk low in idle state
1 = new data on rising, capture on falling, Clk low in idle state
2 = new data on rising, capture on falling, Clk high in idle state
3 = new data on falling, capture on rising Clk high in idle state</description>
	<bitRange>[1:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>SPI_CS_CONFIG_REG</name>
	<description>Spi cs configuration register</description>
	<addressOffset>0x00000024</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00000007</resetMask>
	<fields><field>
	<name>SPI_CS_SELECT</name>
	<description>Control the cs output in master mode
0 = None slave device selected
1 = Selected slave device connected to GPIO with FUNC_MODE = SPI_EN
2 = Selected slave device connected to GPIO with FUNC_MODE = SPI_EN2
4 = Selected slave device connected to GPIO with FUNC_MODE = GPIO</description>
	<bitRange>[2:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>SPI_CTRL_REG</name>
	<description>Spi control register</description>
	<addressOffset>0x00000000</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x000000ff</resetMask>
	<fields><field>
	<name>SPI_SWAP_BYTES</name>
	<description>0 = Normal operation
1 = LSB and MSB are swapped in the APB interface
In case of 8-bit spi interface, DMA/SPI can be configured in 16-bit mode to off load the bus. Enabling SPI_SWAP_BYTES bytes will read/write correctly</description>
	<bitRange>[7:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SPI_CAPTURE_AT_NEXT_EDGE</name>
	<description>0 = SPI captures data at correct clock edge
1 = SPI captures data at next clock edge. (only for Master mode and high clock)</description>
	<bitRange>[6:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SPI_FIFO_RESET</name>
	<description>0 = Fifo normal operation
1 = Fifo in reset state</description>
	<bitRange>[5:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SPI_DMA_RX_EN</name>
	<description>Applicable only when SPI_RX_EN = 1
0 = No DMA request for RX
1 = DMA request when SPI_STATUS_RX_FULL = 1</description>
	<bitRange>[4:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SPI_DMA_TX_EN</name>
	<description>Applicable only when SPI_TX_EN = 1
0 = No DMA request for TX
1 = DMA request when SPI_STATUS_TX_EMPTY = 1</description>
	<bitRange>[3:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SPI_RX_EN</name>
	<description>0 = RX path is disabled
1 = RX path is enabled
Note: if spi mode = 1 or spi mode = 3 read-only is not supported</description>
	<bitRange>[2:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SPI_TX_EN</name>
	<description>0 = TX path is disabled
1 = TX path is enabled</description>
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SPI_EN</name>
	<description>0 = SPI module is disable
1 = SPI module is enable</description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>SPI_FIFO_CONFIG_REG</name>
	<description>Spi fifo configuration register</description>
	<addressOffset>0x0000000c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x000000ff</resetMask>
	<fields><field>
	<name>SPI_RX_TL</name>
	<description>Receive FIFO threshold level in bytes. Control the level of bytes in fifo that triggers the RX_FULL interrupt. IRQ has occurred when fifo level is more or equal to SPI_RX_TL+1. Fifo level is from 0 to 4</description>
	<bitRange>[7:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SPI_TX_TL</name>
	<description>Transmit FIFO threshold level in bytes. Control the level of bytes in fifo that triggers the TX_EMPTY interrupt. IRQ has occurred when fifo level is less or equal to SPI_TX_TL. Fifo level is from 0 to 4</description>
	<bitRange>[3:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>SPI_FIFO_READ_REG</name>
	<description>Spi RX fifo read register</description>
	<addressOffset>0x0000001c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0xffffffff</resetMask>
	<fields><field>
	<name>SPI_FIFO_READ</name>
	<description>Read from RX fifo. Read access is permit only if SPI_RX_FIFO_EMPTY = 0. </description>
	<bitRange>[31:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>SPI_FIFO_STATUS_REG</name>
	<description>SPI RX/TX fifo status register</description>
	<addressOffset>0x00000018</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00001000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>SPI_TRANSACTION_ACTIVE</name>
	<description>In master mode
0 = SPI transaction is inactive
1 = SPI transaction is active</description>
	<bitRange>[15:15]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>SPI_RX_FIFO_OVFL</name>
	<description>When 1, receive data is not written to fifo because fifo was full and interrupt is generated. It clears with SPI_CTRL_REG.SPI_FIFO_RESET
</description>
	<bitRange>[14:14]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>SPI_STATUS_TX_FULL</name>
	<description>0 = TX fifo is not full
1 = TX fifo is full</description>
	<bitRange>[13:13]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>SPI_STATUS_RX_EMPTY</name>
	<description>0 = RX fifo is not empty
1 = RX fifo is empty</description>
	<bitRange>[12:12]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>SPI_TX_FIFO_LEVEL</name>
	<description>Gives the number of bytes in TX fifo</description>
	<bitRange>[11:6]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>SPI_RX_FIFO_LEVEL</name>
	<description>Gives the number of bytes in RX fifo</description>
	<bitRange>[5:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>SPI_FIFO_WRITE_REG</name>
	<description>Spi TX fifo write register</description>
	<addressOffset>0x00000020</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0xffffffff</resetMask>
	<fields><field>
	<name>SPI_FIFO_WRITE</name>
	<description>Write to TX fifo. Write access is permit only if SPI_TX_FIFO_FULL is 0</description>
	<bitRange>[31:0]</bitRange>
	<access>write-only</access>
	</field></fields>
</register><register>
	<name>SPI_IRQ_MASK_REG</name>
	<description>Spi interrupt mask register</description>
	<addressOffset>0x00000010</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00000003</resetMask>
	<fields><field>
	<name>SPI_IRQ_MASK_RX_FULL</name>
	<description>0 = FIFO RX full irq is masked
1 = FIFO RX full irq is enabled</description>
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SPI_IRQ_MASK_TX_EMPTY</name>
	<description>0 = FIFO TX empty irq is masked
1 = FIFO TX empty irq is enabled</description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>SPI_STATUS_REG</name>
	<description>Spi status register</description>
	<addressOffset>0x00000014</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000001</resetValue>
	<resetMask>0x00000003</resetMask>
	<fields><field>
	<name>SPI_STATUS_RX_FULL</name>
	<description>Auto clear
0 = RX fifo level is less than SPI_RX_TL+1
1 = RX fifo level is more or equal to SPI_RX_TL+1</description>
	<bitRange>[1:1]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>SPI_STATUS_TX_EMPTY</name>
	<description>Auto clear
0 = TX fifo level is larger than SPI_TX_TL
1 = TX fifo level is less or equal to SPI_TX_TL</description>
	<bitRange>[0:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>SPI_TXBUFFER_FORCE_REG</name>
	<description>SPI TX buffer force low value</description>
	<addressOffset>0x0000002c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0xffffffff</resetMask>
	<fields><field>
	<name>SPI_TXBUFFER_FORCE</name>
	<description>Write directly the tx buffer. It must to be used only in slave mode</description>
	<bitRange>[31:0]</bitRange>
	<access>write-only</access>
	</field></fields>
</register></registers>
</peripheral><peripheral>
	<name>SRC1</name>
	<version>1.0</version>
	<description>SRC1 registers</description>
	<groupName>Peripheral_Registers</groupName>
	<baseAddress>0x50030100</baseAddress>
	<size>0</size>
	<addressBlock>
	<offset>0</offset>
	<size>56</size>
	<usage>registers</usage>
</addressBlock>

	<registers>
	<register>
	<name>SRC1_COEF0A_SET1_REG</name>
	<description>SRC coefficient 10 set 1</description>
	<addressOffset>0x00000034</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x0000497d</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>SRC_COEF10</name>
	<description>Coefficient 10</description>
	<bitRange>[15:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>SRC1_COEF10_SET1_REG</name>
	<description>SRC coefficient 1,0 set 1</description>
	<addressOffset>0x00000020</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x7a208ec4</resetValue>
	<resetMask>0xffffffff</resetMask>
	<fields><field>
	<name>SRC_COEF1</name>
	<description>Coefficient 1</description>
	<bitRange>[31:16]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SRC_COEF0</name>
	<description>Coefficient 0</description>
	<bitRange>[15:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>SRC1_COEF32_SET1_REG</name>
	<description>SRC coefficient 3,2 set 1</description>
	<addressOffset>0x00000024</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x70fd8936</resetValue>
	<resetMask>0xffffffff</resetMask>
	<fields><field>
	<name>SRC_COEF3</name>
	<description>Coefficient 3</description>
	<bitRange>[31:16]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SRC_COEF2</name>
	<description>Coefficient 2</description>
	<bitRange>[15:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>SRC1_COEF54_SET1_REG</name>
	<description>SRC coefficient 5,4 set 1</description>
	<addressOffset>0x00000028</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x9758b686</resetValue>
	<resetMask>0xffffffff</resetMask>
	<fields><field>
	<name>SRC_COEF5</name>
	<description>Coefficient 5</description>
	<bitRange>[31:16]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SRC_COEF4</name>
	<description>Coefficient 4 </description>
	<bitRange>[15:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>SRC1_COEF76_SET1_REG</name>
	<description>SRC coefficient 7,6 set 1</description>
	<addressOffset>0x0000002c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x89c47df5</resetValue>
	<resetMask>0xffffffff</resetMask>
	<fields><field>
	<name>SRC_COEF7</name>
	<description>Coefficient 7</description>
	<bitRange>[31:16]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SRC_COEF6</name>
	<description>Coefficient 6</description>
	<bitRange>[15:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>SRC1_COEF98_SET1_REG</name>
	<description>SRC coefficient 9,8 set 1</description>
	<addressOffset>0x00000030</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x8f187771</resetValue>
	<resetMask>0xffffffff</resetMask>
	<fields><field>
	<name>SRC_COEF9</name>
	<description>Coefficient 9</description>
	<bitRange>[31:16]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SRC_COEF8</name>
	<description>Coefficient 8</description>
	<bitRange>[15:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>SRC1_CTRL_REG</name>
	<description>SRC control register</description>
	<addressOffset>0x00000000</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0xffffffff</resetMask>
	<fields><field>
	<name>SRC_PDM_DO_DEL</name>
	<description>PDM_DO output delay line (typical)
0: No delay
1: 8 ns
2: 12 ns
3: 16 ns</description>
	<bitRange>[31:30]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SRC_PDM_MODE</name>
	<description>PDM Output mode selection on PDM_DO1
00: No output
01: Right channel (data from SRC1_IN_REG)
10: Left channel (data from SRC2_IN_REG)
11: Left and Right channel</description>
	<bitRange>[29:28]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SRC_PDM_DI_DEL</name>
	<description>PDM_DI input delay line (typical)
0: No delay
1: 4 ns
2: 8 ns
3: 12 ns</description>
	<bitRange>[27:26]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SRC_OUT_FLOWCLR</name>
	<description>Writing 1 clears the SRC1_OUT Overflow/underflow bits 23-22. No more over/underflow indications while bit is 1. Keep 1 until the over/underflow bit is cleared </description>
	<bitRange>[25:25]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>SRC_IN_FLOWCLR</name>
	<description>Writing 1 clears the SRC1_IN Overflow/underflow bits 21-20. No more over/underflow indications while bit is 1. Keep 1 until the over/underflow bit is cleared </description>
	<bitRange>[24:24]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>SRC_OUT_UNFLOW</name>
	<description>1 = SRC1_OUT Underflow occurred </description>
	<bitRange>[23:23]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>SRC_OUT_OVFLOW</name>
	<description>1 = SRC1_OUT Overflow occurred </description>
	<bitRange>[22:22]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>SRC_IN_UNFLOW</name>
	<description>1 = SRC1_IN Underflow occurred </description>
	<bitRange>[21:21]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>SRC_IN_OVFLOW</name>
	<description>1 = SRC1_IN Overflow occurred </description>
	<bitRange>[20:20]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>SRC_RESYNC</name>
	<description>1 = SRC will restart synchronization</description>
	<bitRange>[19:19]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>SRC_OUT_OK</name>
	<description>SRC1_OUT Status
0: Acquisition in progress
1: Acquisition ready (In manual mode this bit is always 1)</description>
	<bitRange>[18:18]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>SRC_OUT_US</name>
	<description>SRC1_OUT UpSampling IIR filters setting
00: For sample rates up to 48 kHz
01: For sample rates of 96 kHz
10: Reserved
11: For sample rates of 192 kHz</description>
	<bitRange>[17:16]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SRC_OUT_CAL_BYPASS</name>
	<description>SRC1_OUT1 upsampiling filter bypass
0:Do not bypass
1:Bypass filter</description>
	<bitRange>[14:14]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SRC_OUT_AMODE</name>
	<description>SRC1_OUT1 Automatic Conversion mode
0:Manual mode
1:Automatic mode</description>
	<bitRange>[13:13]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SRC_PDM_OUT_INV</name>
	<description>Swap the left and the right output PDM channel</description>
	<bitRange>[12:12]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SRC_FIFO_DIRECTION</name>
	<description>0 = SRC fifo is used to store samples from memory to SRC
1 = SRC fifo is used to store sample from SRC to memory</description>
	<bitRange>[11:11]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SRC_FIFO_ENABLE</name>
	<description>0 = FIFO disable. On each src request, one sample is serviced
1 = FIFO enable. FIFO is used to store samples from/to src
SRC supports only DMA burst size 4 when FIFO is enabled else no burst</description>
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SRC_OUT_DSD_MODE</name>
	<description>0 = SRC1 OUT PDM mode
1 = SRC1 OUT DSD mode</description>
	<bitRange>[9:9]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SRC_IN_DSD_MODE</name>
	<description>0: SRC1 IN PDM mode
1: SRC1 IN DSD mode </description>
	<bitRange>[8:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SRC_DITHER_DISABLE</name>
	<description>Dithering feature
0: Enable
1: Disable</description>
	<bitRange>[7:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SRC_IN_OK</name>
	<description>SRC1_IN status
0: Acquisition in progress
1: Acquisition ready</description>
	<bitRange>[6:6]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>SRC_IN_DS</name>
	<description>SRC1_IN UpSampling IIR filters setting
00: For sample rates up to 48 kHz
01: For sample rates of 96 kHz
10: Reserved
11: For sample rates of 192 kHz</description>
	<bitRange>[5:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SRC_PDM_IN_INV</name>
	<description>Swap the left and the right input PDM channel</description>
	<bitRange>[3:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SRC_IN_CAL_BYPASS</name>
	<description>SRC1_IN upsampeling filter bypass
0: Do not bypass
1: Bypass filter</description>
	<bitRange>[2:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SRC_IN_AMODE</name>
	<description>SRC1_IN Automatic conversion mode
0: Manual mode
1: Automatic mode</description>
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SRC_EN</name>
	<description>SRC1_IN and SRC1_OUT enable
0: Disabled
1: Enabled</description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>SRC1_IN1_REG</name>
	<description>SRC data in 1</description>
	<addressOffset>0x0000000c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0xffffffff</resetMask>
	<fields><field>
	<name>SRC_IN</name>
	<description>SRC1_IN1 </description>
	<bitRange>[31:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>SRC1_IN2_REG</name>
	<description>SRC data in 2</description>
	<addressOffset>0x00000010</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0xffffffff</resetMask>
	<fields><field>
	<name>SRC_IN</name>
	<description>SRC1_IN2 </description>
	<bitRange>[31:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>SRC1_IN_FS_REG</name>
	<description>SRC Sample input rate</description>
	<addressOffset>0x00000004</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0xffffffff</resetMask>
	<fields><field>
	<name>SRC_IN_FS</name>
	<description>SRC_IN Sample rate
SRC_IN_FS = SRC_DIV*4096*Sample_rate/100
Sample_rate upper limit is 192 kHz. For 96 kHz and 192 kHz SRC_CTRLx_REG[SRC_IN_DS] must be set as shown below:
(for SRC_DIV = 1)
Sample_rate SRC_IN_FS SRC_IN_DS Audio bandwidth
8000 Hz 0x050000 0 4000 Hz
11025 Hz 0x06E400 0 5512 Hz
16000 Hz 0x0A0000 0 8000 Hz
22050 Hz 0x0DC800 0 11025 Hz
32000 Hz 0x140000 0 16000 Hz
44100 Hz 0x1B9000 0 22050 Hz
48000 Hz 0x1E0000 0 24000 Hz
96000 Hz 0x1E0000 1 24000 Hz
192000 Hz 0x1E0000 3 24000 Hz

In manual SRC mode, SRC_IN_FS can be set and adjusted to the desired sample rate at any time.
In automatic mode the SRC returns the final sample rate as soon as SRC_IN_OK. Note that SRC_DS is not calculated in automatic mode and must be set manually automatic mode with Sample_rate of 96 and 192 kHz.</description>
	<bitRange>[23:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>SRC1_MUX_REG</name>
	<description>SRC mux register</description>
	<addressOffset>0x0000001c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000007f</resetMask>
	<fields><field>
	<name>PDM1_MUX_IN</name>
	<description>PDM1 input mux
0 = SRC1_MUX_IN
1 = PDM input</description>
	<bitRange>[6:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PCM1_MUX_IN</name>
	<description>PCM1 input mux
0 = off
1 = SRC1 output
2 = PCM output registers
3 = SRC2 output</description>
	<bitRange>[5:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SRC1_MUX_IN</name>
	<description>SRC1 input mux
0 = off
1 = PCM output
2 = SRC1 input registers
3 = SDADC output</description>
	<bitRange>[2:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>SRC1_OUT1_REG</name>
	<description>SRC data out 1</description>
	<addressOffset>0x00000014</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0xffffffff</resetMask>
	<fields><field>
	<name>SRC_OUT</name>
	<description>SRC1_OUT1 </description>
	<bitRange>[31:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>SRC1_OUT2_REG</name>
	<description>SRC data out 2</description>
	<addressOffset>0x00000018</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0xffffffff</resetMask>
	<fields><field>
	<name>SRC_OUT</name>
	<description>SRC1_OUT2 </description>
	<bitRange>[31:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>SRC1_OUT_FS_REG</name>
	<description>SRC Sample output rate</description>
	<addressOffset>0x00000008</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0xffffffff</resetMask>
	<fields><field>
	<name>SRC_OUT_FS</name>
	<description>SRC_OUT Sample rate
SRC_OUT_FS = SRC_DIV*4096*Sample_rate/100
Sample_rate upper limit is 192 kHz. For 96 kHz and 192 kHz SRC_CTRLx_REG[SRC_DS] must be set as shown below:
(for SRC_DIV = 1)
Sample_rate SRC_OUT_FS  SRC_OUT_DS Audio bandwidth
8000 Hz     0x050000    0          4000 Hz
11025 Hz    0x06E400    0          5512 Hz
16000 Hz    0x0A0000    0          8000 Hz
22050 Hz    0x0DC800    0          11025 Hz
32000 Hz    0x140000    0          16000 Hz
44100 Hz    0x1B9000    0          22050 Hz
48000 Hz    0x1E0000    0          24000 Hz
96000 Hz    0x1E0000    1          24000 Hz
192000 Hz   0x1E0000    3          24000 Hz

In manual SRC mode, SRC_OUT_FS can be set and adjusted to the desired sample rate at any time.
In automatic mode the SRC returns the final sample rate as soon as SRC_OUT_OK. Note that SRC_DS is not calculated in automatic mode and must be set manually automatic mode with Sample_rate of 96 and 192 kHz.</description>
	<bitRange>[23:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register></registers>
</peripheral><peripheral>
	<name>SRC2</name>
	<version>1.0</version>
	<description>SRC2 registers</description>
	<groupName>Peripheral_Registers</groupName>
	<baseAddress>0x50030200</baseAddress>
	<size>0</size>
	<addressBlock>
	<offset>0</offset>
	<size>56</size>
	<usage>registers</usage>
</addressBlock>

	<registers>
	<register>
	<name>SRC2_COEF0A_SET1_REG</name>
	<description>SRC coefficient 10 set 1</description>
	<addressOffset>0x00000034</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x0000497d</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>SRC_COEF10</name>
	<description>Coefficient 10</description>
	<bitRange>[15:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>SRC2_COEF10_SET1_REG</name>
	<description>SRC coefficient 1,0 set 1</description>
	<addressOffset>0x00000020</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x7a208ec4</resetValue>
	<resetMask>0xffffffff</resetMask>
	<fields><field>
	<name>SRC_COEF1</name>
	<description>Coefficient 1</description>
	<bitRange>[31:16]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SRC_COEF0</name>
	<description>Coefficient 0</description>
	<bitRange>[15:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>SRC2_COEF32_SET1_REG</name>
	<description>SRC coefficient 3,2 set 1</description>
	<addressOffset>0x00000024</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x70fd8936</resetValue>
	<resetMask>0xffffffff</resetMask>
	<fields><field>
	<name>SRC_COEF3</name>
	<description>Coefficient 3</description>
	<bitRange>[31:16]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SRC_COEF2</name>
	<description>Coefficient 2</description>
	<bitRange>[15:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>SRC2_COEF54_SET1_REG</name>
	<description>SRC coefficient 5,4 set 1</description>
	<addressOffset>0x00000028</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x9758b686</resetValue>
	<resetMask>0xffffffff</resetMask>
	<fields><field>
	<name>SRC_COEF5</name>
	<description>Coefficient 5</description>
	<bitRange>[31:16]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SRC_COEF4</name>
	<description>Coefficient 4 </description>
	<bitRange>[15:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>SRC2_COEF76_SET1_REG</name>
	<description>SRC coefficient 7,6 set 1</description>
	<addressOffset>0x0000002c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x89c47df5</resetValue>
	<resetMask>0xffffffff</resetMask>
	<fields><field>
	<name>SRC_COEF7</name>
	<description>Coefficient 7</description>
	<bitRange>[31:16]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SRC_COEF6</name>
	<description>Coefficient 6</description>
	<bitRange>[15:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>SRC2_COEF98_SET1_REG</name>
	<description>SRC coefficient 9,8 set 1</description>
	<addressOffset>0x00000030</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x8f187771</resetValue>
	<resetMask>0xffffffff</resetMask>
	<fields><field>
	<name>SRC_COEF9</name>
	<description>Coefficient 9</description>
	<bitRange>[31:16]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SRC_COEF8</name>
	<description>Coefficient 8</description>
	<bitRange>[15:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>SRC2_CTRL_REG</name>
	<description>SRC control register</description>
	<addressOffset>0x00000000</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0xffffffff</resetMask>
	<fields><field>
	<name>SRC_PDM_MODE</name>
	<description>PDM Output mode selection on PDM_DO1
00: No output
01: Right channel (data from SRC1_IN_REG)
10: Left channel (data from SRC2_IN_REG)
11: Left and Right channel</description>
	<bitRange>[29:28]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SRC_OUT_FLOWCLR</name>
	<description>Writing a 1 clears the SRC1_OUT Overflow/underflow bits 23-22. No more over/underflow indications while bit is 1. Keep 1 until the over/underflow bit is cleared </description>
	<bitRange>[25:25]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>SRC_IN_FLOWCLR</name>
	<description>Writing a 1 clears the SRC1_IN Overflow/underflow bits 21-20. No more over/underflow indications while bit is 1. Keep 1 until the over/underflow bit is cleared </description>
	<bitRange>[24:24]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>SRC_OUT_UNFLOW</name>
	<description>1 = SRC1_OUT Underflow occurred </description>
	<bitRange>[23:23]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>SRC_OUT_OVFLOW</name>
	<description>1 = SRC1_OUT Overflow occurred </description>
	<bitRange>[22:22]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>SRC_IN_UNFLOW</name>
	<description>1 = SRC1_IN Underflow occurred </description>
	<bitRange>[21:21]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>SRC_IN_OVFLOW</name>
	<description>1 = SRC1_IN Overflow occurred </description>
	<bitRange>[20:20]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>SRC_RESYNC</name>
	<description>1 = SRC will restart synchronization</description>
	<bitRange>[19:19]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>SRC_OUT_OK</name>
	<description>SRC1_OUT Status
0: Acquisition in progress
1: Acquisition ready (In manual mode this bit is always 1)</description>
	<bitRange>[18:18]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>SRC_OUT_US</name>
	<description>SRC1_OUT UpSampling IIR filters setting
00: For sample rates up to 48 kHz
01: For sample rates of 96 kHz
10: Reserved
11: For sample rates of 192 kHz</description>
	<bitRange>[17:16]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SRC_OUT_CAL_BYPASS</name>
	<description>SRC1_OUT1 upsampling filter bypass
0: Do not bypass
1: Bypass filter</description>
	<bitRange>[14:14]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SRC_OUT_AMODE</name>
	<description>SRC1_OUT1 Automatic Conversion mode
0:Manual mode
1:Automatic mode</description>
	<bitRange>[13:13]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SRC_PDM_OUT_INV</name>
	<description>Swap the left and the right output PDM channel</description>
	<bitRange>[12:12]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SRC_FIFO_DIRECTION</name>
	<description>0 = SRC fifo is used to store samples from memory to SRC
1 = SRC fifo is used to store sample from SRC to memory</description>
	<bitRange>[11:11]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SRC_FIFO_ENABLE</name>
	<description>0 = FIFO disable. On each src request, one sample is serviced
1 = FIFO enable. FIFO is used to store samples from/to src
SRC supports only DMA burst size 4 when FIFO is enabled, else no burst</description>
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SRC_OUT_DSD_MODE</name>
	<description>0 = SRC1 OUT PDM mode
1 = SRC1 OUT DSD mode</description>
	<bitRange>[9:9]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SRC_IN_DSD_MODE</name>
	<description>0: SRC1 IN PDM mode
1: SRC1 IN DSD mode </description>
	<bitRange>[8:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SRC_DITHER_DISABLE</name>
	<description>Dithering feature
0: Enable
1: Disable</description>
	<bitRange>[7:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SRC_IN_OK</name>
	<description>SRC1_IN status
0: Acquisition in progress
1: Acquisition ready</description>
	<bitRange>[6:6]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>SRC_IN_DS</name>
	<description>SRC1_IN UpSampling IIR filters setting
00: For sample rates up to 48 kHz
01: For sample rates of 96 kHz
10: Reserved
11: For sample rates of 192 kHz</description>
	<bitRange>[5:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SRC_PDM_IN_INV</name>
	<description>Swap the left and the right input PDM channel</description>
	<bitRange>[3:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SRC_IN_CAL_BYPASS</name>
	<description>SRC1_IN upsampling filter bypass
0: Do not bypass
1: Bypass filter</description>
	<bitRange>[2:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SRC_IN_AMODE</name>
	<description>SRC1_IN Automatic conversion mode
0: Manual mode
1: Automatic mode</description>
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SRC_EN</name>
	<description>SRC1_IN and SRC1_OUT enable
0: Disabled
1: Enabled</description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>SRC2_IN1_REG</name>
	<description>SRC data in 1</description>
	<addressOffset>0x0000000c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0xffffffff</resetMask>
	<fields><field>
	<name>SRC_IN</name>
	<description>SRC1_IN1 </description>
	<bitRange>[31:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>SRC2_IN2_REG</name>
	<description>SRC data in 2</description>
	<addressOffset>0x00000010</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0xffffffff</resetMask>
	<fields><field>
	<name>SRC_IN</name>
	<description>SRC1_IN2 </description>
	<bitRange>[31:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>SRC2_IN_FS_REG</name>
	<description>SRC Sample input rate</description>
	<addressOffset>0x00000004</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0xffffffff</resetMask>
	<fields><field>
	<name>SRC_IN_FS</name>
	<description>SRC_IN Sample rate
SRC_IN_FS = SRC_DIV*4096*Sample_rate/100
Sample_rate upper limit is 192 kHz. For 96 kHz and 192 kHz SRC_CTRLx_REG[SRC_IN_DS] must be set as shown below:
(for SRC_DIV = 1)
Sample_rate SRC_IN_FS SRC_IN_DS Audio bandwidth
8000 Hz 0x050000 0 4000 Hz
11025 Hz 0x06E400 0 5512 Hz
16000 Hz 0x0A0000 0 8000 Hz
22050 Hz 0x0DC800 0 11025 Hz
32000 Hz 0x140000 0 16000 Hz
44100 Hz 0x1B9000 0 22050 Hz
48000 Hz 0x1E0000 0 24000 Hz
96000 Hz 0x1E0000 1 24000 Hz
192000 Hz 0x1E0000 3 24000 Hz

In manual SRC mode, SRC_IN_FS can be set and adjusted to the desired sample rate at any time.
In automatic mode the SRC returns the final sample rate as soon as SRC_IN_OK. Note that SRC_DS is not calculated in automatic mode and must be set manually automatic mode with Sample_rate of 96 and 192 kHz.</description>
	<bitRange>[23:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>SRC2_MUX_REG</name>
	<description>SRC mux register</description>
	<addressOffset>0x0000001c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000007f</resetMask>
	<fields><field>
	<name>PDM1_MUX_IN</name>
	<description>PDM1 input mux
0 = SRC2_MUX_IN
1 = PDM input</description>
	<bitRange>[6:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>PDM_MUX_OUT</name>
	<description>PDM output mux
0 = SRC1 PDM output
1 = SRC2 PDM output
2..7 = Reserved</description>
	<bitRange>[5:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>SRC2_MUX_IN</name>
	<description>SRC1 input mux
0 = off
1 = PCM output
2 = SRC2 input registers
3 = SDADC output</description>
	<bitRange>[2:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>SRC2_OUT1_REG</name>
	<description>SRC data out 1</description>
	<addressOffset>0x00000014</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0xffffffff</resetMask>
	<fields><field>
	<name>SRC_OUT</name>
	<description>SRC1_OUT1 </description>
	<bitRange>[31:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>SRC2_OUT2_REG</name>
	<description>SRC data out 2</description>
	<addressOffset>0x00000018</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0xffffffff</resetMask>
	<fields><field>
	<name>SRC_OUT</name>
	<description>SRC1_OUT2 </description>
	<bitRange>[31:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>SRC2_OUT_FS_REG</name>
	<description>SRC Sample output rate</description>
	<addressOffset>0x00000008</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0xffffffff</resetMask>
	<fields><field>
	<name>SRC_OUT_FS</name>
	<description>SRC_OUT Sample rate
SRC_OUT_FS = SRC_DIV*4096*Sample_rate/100
Sample_rate upper limit is 192 kHz. For 96 kHz and 192 kHz SRC_CTRLx_REG[SRC_DS] must be set as shown below:
(for SRC_DIV = 1)
Sample_rate SRC_OUT_FS  SRC_OUT_DS Audio bandwidth
8000 Hz     0x050000    0          4000 Hz
11025 Hz    0x06E400    0          5512 Hz
16000 Hz    0x0A0000    0          8000 Hz
22050 Hz    0x0DC800    0          11025 Hz
32000 Hz    0x140000    0          16000 Hz
44100 Hz    0x1B9000    0          22050 Hz
48000 Hz    0x1E0000    0          24000 Hz
96000 Hz    0x1E0000    1          24000 Hz
192000 Hz   0x1E0000    3          24000 Hz

In manual SRC mode, SRC_OUT_FS can be set and adjusted to the desired sample rate at any time.
In automatic mode the SRC returns the final sample rate as soon as SRC_OUT_OK. Note that SRC_DS is not calculated in automatic mode and must be set manually automatic mode with Sample_rate of 96 and 192 kHz.</description>
	<bitRange>[23:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register></registers>
</peripheral><peripheral>
	<name>SYS_WDOG</name>
	<version>1.0</version>
	<description>SYS_WDOG registers</description>
	<groupName>Peripheral_Registers</groupName>
	<baseAddress>0x50000700</baseAddress>
	<size>0</size>
	<addressBlock>
	<offset>0</offset>
	<size>8</size>
	<usage>registers</usage>
</addressBlock>

	<registers>
	<register>
	<name>WATCHDOG_CTRL_REG</name>
	<description>Watchdog control register.</description>
	<addressOffset>0x00000004</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000006</resetValue>
	<resetMask>0xffffffff</resetMask>
	<fields><field>
	<name>WRITE_BUSY</name>
	<description>0 = A new WATCHDOG_REG[WDOG_VAL] can be written.
1 = No new WATCHDOG_REG[WDOG_VAL] can be written.
Note: It takes some time before the programmed WDOG_VAL is updated in the (independent) Watchdog timer. During this time it is not possible to write a new value to WATCHDOG_REG[WDOG_VAL].</description>
	<bitRange>[3:3]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>WDOG_FREEZE_EN</name>
	<description>0 = Watchdog timer can not be frozen when NMI_RST = 0.
1 = Watchdog timer can be frozen/resumed using
SET_FREEZE_REG[FRZ_WDOG]/
RESET_FREEZE_REG[FRZ_WDOG] when NMI_RST = 0.
Note: Although this bit is retained during sleep, the SET_FREEZE_REG[FRZ_SYS_WDOG] is not, so the watchdog cannot be frozen during CM33 sleep.</description>
	<bitRange>[2:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>NMI_RST</name>
	<description>0 = Watchdog timer generates NMI at value 0, and WDOG (SYS) reset at &lt;= -16. Timer can be frozen/resumed using
SET_FREEZE_REG[FRZ_WDOG]/
RESET_FREEZE_REG[FRZ_WDOG].
1 = Watchdog timer generates a WDOG (SYS) reset at value 0 and can not be frozen by software.
Note that this bit can only be set to 1 by software and only be reset with a WDOG (SYS) reset or software reset.
The watchdog is always frozen when the Cortex-M33 is halted in DEBUG State. </description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>WATCHDOG_REG</name>
	<description>Watchdog timer register.</description>
	<addressOffset>0x00000000</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00001fff</resetValue>
	<resetMask>0xffffffff</resetMask>
	<fields><field>
	<name>WDOG_WEN</name>
	<description>Bit [31:14] = 0 = Write enable for Watchdog timer
Else, Write disable. This filter prevents unintentional presetting the watchdog with a software run-away. </description>
	<bitRange>[31:14]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>WDOG_VAL_NEG</name>
	<description>0 = Watchdog timer value is positive.
1 = Watchdog timer value is negative. </description>
	<bitRange>[13:13]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>WDOG_VAL</name>
	<description>Write: Watchdog timer reload value. Note that all bits [31-14] must be 0 to reload this register.
Read: Actual Watchdog timer value. Decremented by 1 every ~10 ms (RCLP) or ~21 ms (RCX), that is the Watchdog timer clock tick.
Bit 13 indicates a negative counter value. 2, 1, 0, 3FFF16, 3FFE16 and so forth. An NMI or WDOG (SYS) reset is generated under the following conditions:
If WATCHDOG_CTRL_REG[NMI_RST] = 0 then
  If WDOG_VAL = 0 -&gt; NMI (Non Maskable Interrupt)
  if WDOG_VAL =3FF016 -&gt; WDOG reset -&gt; reload 1FFF16
If WATCHDOG_CTRL_REG[NMI_RST] = 1 then
  if WDOG_VAL &lt;= 0 -&gt; WDOG reset -&gt; reload 1FFF16
Note 1: The programmed value WDOG_VAL is updated in the (independent) Watchdog timer at the second next RCLP or RCX clock tick.
Note 2: Select RCLP (32 kHz) or RCX (15 kHz) with CLK_RCX_REG[RCX_ENABLE] for the Watchdog clock. The RCLP is selected by default. See for more info the description of CLK_RCX_REG[RCX_ENABLE].
Note 3: If WATCHDOG_CTRL_REG[NMI_RST] = 0, the time between the NMI generation and the WDOG reset generation is 15 Watchdog timer clock ticks.
Note 4: The internal Watchdog timer clock tick is the Watchdog clock divided by a fixed value of 320. </description>
	<bitRange>[12:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register></registers>
</peripheral><peripheral>
	<name>SYSB</name>
	<version>1.0</version>
	<description>SYSB registers</description>
	<groupName>Peripheral_Registers</groupName>
	<baseAddress>0x50060400</baseAddress>
	<size>0</size>
	<addressBlock>
	<offset>0</offset>
	<size>12</size>
	<usage>registers</usage>
</addressBlock>

	<registers>
	<register>
	<name>BRIDGE_REG</name>
	<description>H2H CMAC Synchronization Register </description>
	<addressOffset>0x00000004</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00000003</resetMask>
	<fields><field>
	<name>SYNC_BYPASS</name>
	<description>CMAC bridge, internal synchronization stages are bypassed.
0: Disabled
1: Enabled</description>
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>BRIDGE_BYPASS</name>
	<description>CMAC bridge is bypassed only allowed when cmac hclk equals system hclk
0: Disabled
1: Enabled</description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>FLASH_ARB_REG</name>
	<description>FPU/ICM_S2 Register</description>
	<addressOffset>0x00000008</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00000001</resetMask>
	<fields><field>
	<name>ENABLE_SEQ</name>
	<description>Arbitration flash memory
0: Arbitration is carried out on every transfer
1: Arbitration is carried out at the beginning of every burst transfer</description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>QSPI_ARB_REG</name>
	<description>ICM_S1 Priorities Register</description>
	<addressOffset>0x00000000</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x000000e4</resetValue>
	<resetMask>0x000000ff</resetMask>
	<fields><field>
	<name>AHB_DMA_PRIO</name>
	<description>Priority AHB_DMA layer system bus
0x0: Highest priority
0x1: Second priority
0x2: Third priority
0x3: Fourth priority</description>
	<bitRange>[7:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>AHB_CPUC_PRIO</name>
	<description>Priority AHB_CPUC layer system bus
0x0: Highest priority
0x1: Second priority
0x2: Third priority
0x3: Fourth priority</description>
	<bitRange>[5:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>AHB_CPUS_PRIO</name>
	<description>Priority AHB_CPUS layer system bus
0x0: Highest priority
0x1: Second priority
0x2: Third priority
0x3: Fourth priority</description>
	<bitRange>[3:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>AHB_CMAC_PRIO</name>
	<description>Priority AHB_CMAC layer system bus
0x0: Highest priority
0x1: Second priority
0x2: Third priority
0x3: Fourth priority</description>
	<bitRange>[1:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register></registers>
</peripheral><peripheral>
	<name>TIMER</name>
	<version>1.0</version>
	<description>TIMER registers</description>
	<groupName>Peripheral_Registers</groupName>
	<baseAddress>0x50010300</baseAddress>
	<size>0</size>
	<addressBlock>
	<offset>0</offset>
	<size>76</size>
	<usage>registers</usage>
</addressBlock>

	<registers>
	<register>
	<name>TIMER_CAPTURE_GPIO1_REG</name>
	<description>Timer value for event on GPIO1</description>
	<addressOffset>0x00000020</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0xffffffff</resetMask>
	<fields><field>
	<name>TIM_CAPTURE_GPIO1</name>
	<description>Gives the Capture time for event on GPIO1</description>
	<bitRange>[23:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>TIMER_CAPTURE_GPIO2_REG</name>
	<description>Timer value for event on GPIO2</description>
	<addressOffset>0x00000024</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0xffffffff</resetMask>
	<fields><field>
	<name>TIM_CAPTURE_GPIO2</name>
	<description>Gives the Capture time for event on GPIO2</description>
	<bitRange>[23:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>TIMER_CAPTURE_GPIO3_REG</name>
	<description>Timer value for event on GPIO1</description>
	<addressOffset>0x0000003c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0xffffffff</resetMask>
	<fields><field>
	<name>TIM_CAPTURE_GPIO3</name>
	<description>Gives the Capture time for event on GPIO3</description>
	<bitRange>[23:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>TIMER_CAPTURE_GPIO4_REG</name>
	<description>Timer value for event on GPIO1</description>
	<addressOffset>0x00000040</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0xffffffff</resetMask>
	<fields><field>
	<name>TIM_CAPTURE_GPIO4</name>
	<description>Gives the Capture time for event on GPIO4</description>
	<bitRange>[23:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>TIMER_CLEAR_GPIO_EVENT_REG</name>
	<description>Timer clear gpio event register</description>
	<addressOffset>0x00000044</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000000f</resetMask>
	<fields><field>
	<name>TIM_CLEAR_GPIO4_EVENT</name>
	<description>1 = Clear GPIO4 event. Return always 0</description>
	<bitRange>[3:3]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>TIM_CLEAR_GPIO3_EVENT</name>
	<description>1 = Clear GPIO3 event. Return always 0</description>
	<bitRange>[2:2]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>TIM_CLEAR_GPIO2_EVENT</name>
	<description>1 = Clear GPIO2 event. Return always 0</description>
	<bitRange>[1:1]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>TIM_CLEAR_GPIO1_EVENT</name>
	<description>1 = Clear GPIO1 event. Return always 0</description>
	<bitRange>[0:0]</bitRange>
	<access>write-only</access>
	</field></fields>
</register><register>
	<name>TIMER_CLEAR_IRQ_REG</name>
	<description>Timer clear interrupt</description>
	<addressOffset>0x00000048</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00000001</resetMask>
	<fields><field>
	<name>TIM_CLEAR_IRQ</name>
	<description>Write any value clear interrupt</description>
	<bitRange>[0:0]</bitRange>
	<access>write-only</access>
	</field></fields>
</register><register>
	<name>TIMER_CTRL_REG</name>
	<description>Timer control register</description>
	<addressOffset>0x00000000</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0xffffffff</resetMask>
	<fields><field>
	<name>TIM_CAP_GPIO4_IRQ_EN</name>
	<description>0 = Event on GPIO4 does not create a CAPTIM interrupt
1 = Event on GPIO4 creates a CAPTIM interrupt</description>
	<bitRange>[14:14]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>TIM_CAP_GPIO3_IRQ_EN</name>
	<description>0 = Event on GPIO3 does not create a CAPTIM interrupt
1 = Event on GPIO3 creates a CAPTIM interrupt</description>
	<bitRange>[13:13]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>TIM_CAP_GPIO2_IRQ_EN</name>
	<description>0 = Event on GPIO2 does not create a CAPTIM interrupt
1 = Event on GPIO2 creates a CAPTIM interrupt</description>
	<bitRange>[12:12]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>TIM_CAP_GPIO1_IRQ_EN</name>
	<description>0 = Event on GPIO1 does not create a CAPTIM interrupt
1 = Event on GPIO1 creates a CAPTIM interrupt</description>
	<bitRange>[11:11]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>TIM_IN4_EVENT_FALL_EN</name>
	<description>Event input 4 edge type
1 = Falling edge
0 = Rising edge</description>
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>TIM_IN3_EVENT_FALL_EN</name>
	<description>Event input 3 edge type
1 = Falling edge
0 = Rising edge</description>
	<bitRange>[9:9]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>TIM_CLK_EN</name>
	<description>Timer clock enable
1 = Clock enabled
0 = Clock disabled</description>
	<bitRange>[8:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>TIM_SYS_CLK_EN</name>
	<description>Select clock
1 = Timer uses the DIVN clock
0 = Timer uses the lp clock
Note: When switching clock, the timer clock should be disabled (TIM_CLK_EN, bit 8)</description>
	<bitRange>[7:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>TIM_FREE_RUN_MODE_EN</name>
	<description>Valid when timer counts up, if it is 1, timer does not zero when reaches to reload value. it becomes zero only when it reaches the max value.</description>
	<bitRange>[6:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>TIM_IRQ_EN</name>
	<description>Interrupt mask
1 = Timer IRQ is unmasked
0 = Timer IRQ is masked</description>
	<bitRange>[5:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>TIM_IN2_EVENT_FALL_EN</name>
	<description>Event input 2 edge type
1 = Falling edge
0 = Rising edge</description>
	<bitRange>[4:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>TIM_IN1_EVENT_FALL_EN</name>
	<description>Event input 1 edge type
1 = Falling edge
0 = Rising edge</description>
	<bitRange>[3:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>TIM_COUNT_DOWN_EN</name>
	<description>Timer count direction
1 = Down
0 = Up
Note: Only change counter direction when timer is not enabled</description>
	<bitRange>[2:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>TIM_ONESHOT_MODE_EN</name>
	<description>Timer mode
1 = One shot enabled
0 = Counter enabled</description>
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>TIM_EN</name>
	<description>Timer enable
1 = On
0 = Off</description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>TIMER_GPIO1_CONF_REG</name>
	<description>Timer gpio1 selection</description>
	<addressOffset>0x0000000c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0xffffffff</resetMask>
	<fields><field>
	<name>TIM_GPIO1_CONF</name>
	<description>Select one of the 32 GPIOs as IN1, Valid value 0-32. 1 for the first gpio, 32 for the last gpio. 0 Disable input</description>
	<bitRange>[5:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>TIMER_GPIO2_CONF_REG</name>
	<description>Timer gpio2 selection</description>
	<addressOffset>0x00000010</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0xffffffff</resetMask>
	<fields><field>
	<name>TIM_GPIO2_CONF</name>
	<description>Select one of the 32 GPIOs as IN2, Valid value 0-32. 1 for the first gpio, 32 for the last gpio. 0 Disable input</description>
	<bitRange>[5:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>TIMER_GPIO3_CONF_REG</name>
	<description>Timer gpio3 selection</description>
	<addressOffset>0x00000034</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0xffffffff</resetMask>
	<fields><field>
	<name>TIM_GPIO3_CONF</name>
	<description>Select one of the 32 GPIOs as IN3, Valid value 0-32. 1 for the first gpio, 32 for the last gpio. 0 Disable input</description>
	<bitRange>[5:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>TIMER_GPIO4_CONF_REG</name>
	<description>Timer gpio4 selection</description>
	<addressOffset>0x00000038</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0xffffffff</resetMask>
	<fields><field>
	<name>TIM_GPIO4_CONF</name>
	<description>Select one of the 32 GPIOs as IN4, Valid value 0-32. 1 for the first gpio, 32 for the last gpio. 0 Disable input</description>
	<bitRange>[5:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>TIMER_PRESCALER_VAL_REG</name>
	<description>Timer prescaler counter value</description>
	<addressOffset>0x00000028</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0xffffffff</resetMask>
	<fields><field>
	<name>TIM_PRESCALER_VAL</name>
	<description>Gives the current prescaler counter value</description>
	<bitRange>[4:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>TIMER_PWM_CTRL_REG</name>
	<description>Timer pwm frequency register</description>
	<addressOffset>0x0000002c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0xffffffff</resetMask>
	<fields><field>
	<name>TIM_PWM_DC</name>
	<description>Defines the PWM duty cycle. TIM_PWM_DC/( TIM_PWM_FREQ + 1)</description>
	<bitRange>[31:16]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>TIM_PWM_FREQ</name>
	<description>Defines the PWM frequency. Timer clock frequency/(TIM_PWM_FREQ + 1)
Timer clock is clock after prescaler</description>
	<bitRange>[15:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>TIMER_SETTINGS_REG</name>
	<description>Timer reload value and Delay in shot mode</description>
	<addressOffset>0x00000014</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0xffffffff</resetMask>
	<fields><field>
	<name>TIM_PRESCALER</name>
	<description>Defines the timer count frequency. CLOCK frequency/(TIM_PRESCALER + 1)</description>
	<bitRange>[28:24]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>TIM_RELOAD</name>
	<description>Reload or max value in timer mode, Delay phase duration in oneshot mode. Actual delay is the register value plus synchronization time (3 clock cycles)</description>
	<bitRange>[23:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>TIMER_SHOTWIDTH_REG</name>
	<description>Timer Shot duration in shot mode</description>
	<addressOffset>0x00000018</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0xffffffff</resetMask>
	<fields><field>
	<name>TIM_SHOTWIDTH</name>
	<description>Shot phase duration in oneshot mode</description>
	<bitRange>[23:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>TIMER_STATUS_REG</name>
	<description>Timer status register</description>
	<addressOffset>0x00000008</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00003fff</resetMask>
	<fields><field>
	<name>TIM_IN4_STATE</name>
	<description>Gives the logic level of the IN4</description>
	<bitRange>[13:13]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>TIM_IN3_STATE</name>
	<description>Gives the logic level of the IN3</description>
	<bitRange>[12:12]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>TIM_SWITCHED_TO_DIVN_CLK</name>
	<description>Indicates that timer clock has been switched to divn clock</description>
	<bitRange>[11:11]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>TIM_PWM_BUSY</name>
	<description>Busy with synchronizing PWM_FREQ_REG and PWM_DC_REG. Do not write a new value to these registers when this bit is high</description>
	<bitRange>[10:10]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>TIM_TIMER_BUSY</name>
	<description>Busy with synchronizing PRESCALER_REG, RELOAD_REG and SHOTWIDTH_REG. Do not write a new value to these registers when this bit is high</description>
	<bitRange>[9:9]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>TIM_IRQ_STATUS</name>
	<description>IRQ status bit. When an irq has occurred, this bit is 1.</description>
	<bitRange>[8:8]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>TIM_GPIO4_EVENT_PENDING</name>
	<description>When 1, GPIO4 event is pending.</description>
	<bitRange>[7:7]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>TIM_GPIO3_EVENT_PENDING</name>
	<description>When 1, GPIO3 event is pending.</description>
	<bitRange>[6:6]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>TIM_GPIO2_EVENT_PENDING</name>
	<description>When 1, GPIO2 event is pending.</description>
	<bitRange>[5:5]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>TIM_GPIO1_EVENT_PENDING</name>
	<description>When 1, GPIO1 event is pending. </description>
	<bitRange>[4:4]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>TIM_ONESHOT_PHASE</name>
	<description>OneShot phase
0 = Wait for event
1 = Delay phase
2 = Start Shot
3 = Shot phase</description>
	<bitRange>[3:2]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>TIM_IN2_STATE</name>
	<description>Gives the logic level of the IN1</description>
	<bitRange>[1:1]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>TIM_IN1_STATE</name>
	<description>Gives the logic level of the IN2</description>
	<bitRange>[0:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>TIMER_TIMER_VAL_REG</name>
	<description>Timer counter value</description>
	<addressOffset>0x00000004</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0xffffffff</resetMask>
	<fields><field>
	<name>TIM_TIMER_VALUE</name>
	<description>Gives the current timer value</description>
	<bitRange>[23:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register></registers>
</peripheral><peripheral>
	<name>TIMER2</name>
	<version>1.0</version>
	<description>TIMER2 registers</description>
	<groupName>Peripheral_Registers</groupName>
	<baseAddress>0x50010400</baseAddress>
	<size>0</size>
	<addressBlock>
	<offset>0</offset>
	<size>56</size>
	<usage>registers</usage>
</addressBlock>

	<registers>
	<register>
	<name>TIMER2_CAPTURE_GPIO1_REG</name>
	<description>Timer value for event on GPIO1</description>
	<addressOffset>0x00000020</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0xffffffff</resetMask>
	<fields><field>
	<name>TIM_CAPTURE_GPIO1</name>
	<description>Gives the Capture time for event on GPIO1</description>
	<bitRange>[23:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>TIMER2_CAPTURE_GPIO2_REG</name>
	<description>Timer value for event on GPIO2</description>
	<addressOffset>0x00000024</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0xffffffff</resetMask>
	<fields><field>
	<name>TIM_CAPTURE_GPIO2</name>
	<description>Gives the Capture time for event on GPIO2</description>
	<bitRange>[23:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>TIMER2_CLEAR_IRQ_REG</name>
	<description>Timer clear interrupt</description>
	<addressOffset>0x00000034</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00000001</resetMask>
	<fields><field>
	<name>TIM_CLEAR_IRQ</name>
	<description>Write any value clear interrupt</description>
	<bitRange>[0:0]</bitRange>
	<access>write-only</access>
	</field></fields>
</register><register>
	<name>TIMER2_CTRL_REG</name>
	<description>Timer control register</description>
	<addressOffset>0x00000000</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0xffffffff</resetMask>
	<fields><field>
	<name>TIM_CLK_EN</name>
	<description>Timer clock enable
1 = clock enabled
0 = clock disabled</description>
	<bitRange>[8:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>TIM_SYS_CLK_EN</name>
	<description>Select clock
1 = Timer uses the DIVN clock
0 = Timer uses the lp clock

NOTE: when switching clock, the timer clock should be disabled (TIM_CLK_EN, bit 8)</description>
	<bitRange>[7:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>TIM_FREE_RUN_MODE_EN</name>
	<description>Valid when timer counts up, if it is '1' timer does not zero when reaches to reload value. it becomes zero only when it reaches the max value.</description>
	<bitRange>[6:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>TIM_IRQ_EN</name>
	<description>Interrupt mask
1 = timer IRQ is unmasked
0 = timer IRQ is masked</description>
	<bitRange>[5:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>TIM_IN2_EVENT_FALL_EN</name>
	<description>Event input 2 edge type
1 = falling edge
0 = rising edge</description>
	<bitRange>[4:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>TIM_IN1_EVENT_FALL_EN</name>
	<description>Event input 1 edge type
1 = falling edge
0 = rising edge</description>
	<bitRange>[3:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>TIM_COUNT_DOWN_EN</name>
	<description>Timer count direction
1 = down
0 = up

NOTE: only change this bit when timer is disabled</description>
	<bitRange>[2:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>TIM_ONESHOT_MODE_EN</name>
	<description>Timer mode
1 = One shot enabled
0 = Counter enabled</description>
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>TIM_EN</name>
	<description>Timer enable
1 = On
0 = Off</description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>TIMER2_GPIO1_CONF_REG</name>
	<description>Timer gpio1 selection</description>
	<addressOffset>0x0000000c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0xffffffff</resetMask>
	<fields><field>
	<name>TIM_GPIO1_CONF</name>
	<description>Select one of the 32 GPIOs as IN1, Valid value 0-32. 1 for the first gpio, 32 for the last gpio. 0 Disable input</description>
	<bitRange>[5:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>TIMER2_GPIO2_CONF_REG</name>
	<description>Timer gpio2 selection</description>
	<addressOffset>0x00000010</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0xffffffff</resetMask>
	<fields><field>
	<name>TIM_GPIO2_CONF</name>
	<description>Select one of the 32 GPIOs as IN2, Valid value 0-32. 1 for the first gpio, 32 for the last gpio. 0 Disable input</description>
	<bitRange>[5:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>TIMER2_PRESCALER_VAL_REG</name>
	<description>Timer prescaler counter value</description>
	<addressOffset>0x00000028</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0xffffffff</resetMask>
	<fields><field>
	<name>TIM_PRESCALER_VAL</name>
	<description>Gives the current prescaler counter value</description>
	<bitRange>[4:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>TIMER2_PWM_CTRL_REG</name>
	<description>Timer pwm frequency register</description>
	<addressOffset>0x0000002c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0xffffffff</resetMask>
	<fields><field>
	<name>TIM_PWM_DC</name>
	<description>Defines the PWM duty cycle. TIM_PWM_DC/( TIM_PWM_FREQ + 1)</description>
	<bitRange>[31:16]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>TIM_PWM_FREQ</name>
	<description>Defines the PWM frequency. Timer clock frequency/(TIM_PWM_FREQ + 1)
Timer clock is clock after prescaler</description>
	<bitRange>[15:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>TIMER2_SETTINGS_REG</name>
	<description>Timer reload value and Delay in shot mode</description>
	<addressOffset>0x00000014</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0xffffffff</resetMask>
	<fields><field>
	<name>TIM_PRESCALER</name>
	<description>Defines the timer count frequency. CLOCK frequency / (TIM_PRESCALER+1)</description>
	<bitRange>[28:24]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>TIM_RELOAD</name>
	<description>Reload or max value in timer mode, Delay phase duration in oneshot mode. Actual delay is the register value plus synchronization time (3 clock cycles)</description>
	<bitRange>[23:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>TIMER2_SHOTWIDTH_REG</name>
	<description>Timer Shot duration in shot mode</description>
	<addressOffset>0x00000018</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0xffffffff</resetMask>
	<fields><field>
	<name>TIM_SHOTWIDTH</name>
	<description>Shot phase duration in oneshot mode</description>
	<bitRange>[23:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>TIMER2_STATUS_REG</name>
	<description>Timer status register</description>
	<addressOffset>0x00000008</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00000fff</resetMask>
	<fields><field>
	<name>TIM_SWITCHED_TO_DIVN_CLK</name>
	<description>Indicates that timer clock has been switched to divn clock</description>
	<bitRange>[11:11]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>TIM_PWM_BUSY</name>
	<description>Busy with synchronizing PWM_FREQ_REG and PWM_DC_REG. Do not write a new value to these registers when this bit is high.</description>
	<bitRange>[10:10]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>TIM_TIMER_BUSY</name>
	<description>Busy with synchronizing PRESCALER_REG, RELOAD_REG and SHOTWIDTH_REG. Do not write a new value to these registers when this bit is high.</description>
	<bitRange>[9:9]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>TIM_IRQ_STATUS</name>
	<description>IRQ status bit. When an irq has occurred, this bit is 1.</description>
	<bitRange>[8:8]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>TIM_ONESHOT_PHASE</name>
	<description>OneShot phase
0 = Wait for event
1 = Delay phase
2 = Start Shot
3 = Shot phase</description>
	<bitRange>[3:2]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>TIM_IN2_STATE</name>
	<description>Gives the logic level of the IN1</description>
	<bitRange>[1:1]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>TIM_IN1_STATE</name>
	<description>Gives the logic level of the IN2</description>
	<bitRange>[0:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>TIMER2_TIMER_VAL_REG</name>
	<description>Timer counter value</description>
	<addressOffset>0x00000004</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0xffffffff</resetMask>
	<fields><field>
	<name>TIM_TIMER_VALUE</name>
	<description>Gives the current timer value</description>
	<bitRange>[23:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register></registers>
</peripheral><peripheral>
	<name>TIMER3</name>
	<version>1.0</version>
	<description>TIMER3 registers</description>
	<groupName>Peripheral_Registers</groupName>
	<baseAddress>0x50010500</baseAddress>
	<size>0</size>
	<addressBlock>
	<offset>0</offset>
	<size>56</size>
	<usage>registers</usage>
</addressBlock>

	<registers>
	<register>
	<name>TIMER3_CAPTURE_GPIO1_REG</name>
	<description>Timer value for event on GPIO1</description>
	<addressOffset>0x00000020</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0xffffffff</resetMask>
	<fields><field>
	<name>TIM_CAPTURE_GPIO1</name>
	<description>Gives the Capture time for event on GPIO1</description>
	<bitRange>[23:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>TIMER3_CAPTURE_GPIO2_REG</name>
	<description>Timer value for event on GPIO2</description>
	<addressOffset>0x00000024</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0xffffffff</resetMask>
	<fields><field>
	<name>TIM_CAPTURE_GPIO2</name>
	<description>Gives the Capture time for event on GPIO2</description>
	<bitRange>[23:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>TIMER3_CLEAR_IRQ_REG</name>
	<description>Timer clear interrupt</description>
	<addressOffset>0x00000034</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00000001</resetMask>
	<fields><field>
	<name>TIM_CLEAR_IRQ</name>
	<description>Write any value clear interrupt</description>
	<bitRange>[0:0]</bitRange>
	<access>write-only</access>
	</field></fields>
</register><register>
	<name>TIMER3_CTRL_REG</name>
	<description>Timer control register</description>
	<addressOffset>0x00000000</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0xffffffff</resetMask>
	<fields><field>
	<name>TIM_CLK_EN</name>
	<description>Timer clock enable
1 = Clock enabled
0 = Clock disabled</description>
	<bitRange>[8:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>TIM_SYS_CLK_EN</name>
	<description>Select clock
1 = Timer uses the DIVN clock
0 = Timer uses the lp clock</description>
	<bitRange>[7:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>TIM_FREE_RUN_MODE_EN</name>
	<description>Valid when timer counts up, if it is 1, timer does not zero when reaches to reload value. It becomes zero only when it reaches the max value.</description>
	<bitRange>[6:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>TIM_IRQ_EN</name>
	<description>Interrupt mask
1 = Timer IRQ is unmasked
0 = Timer IRQ is masked</description>
	<bitRange>[5:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>TIM_IN2_EVENT_FALL_EN</name>
	<description>Event input 2 edge type
1 = Falling edge
0 = Rising edge</description>
	<bitRange>[4:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>TIM_IN1_EVENT_FALL_EN</name>
	<description>Event input 1 edge type
1 = Falling edge
0 = Rising edge</description>
	<bitRange>[3:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>TIM_COUNT_DOWN_EN</name>
	<description>Timer count direction
1 = Down
0 = Up</description>
	<bitRange>[2:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>TIM_EN</name>
	<description>Timer enable
1 = On
0 = Off</description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>TIMER3_GPIO1_CONF_REG</name>
	<description>Timer gpio1 selection</description>
	<addressOffset>0x0000000c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0xffffffff</resetMask>
	<fields><field>
	<name>TIM_GPIO1_CONF</name>
	<description>Select one of the 32 GPIOs as IN1, Valid value 0-32. 1 for the first gpio, 32 for the last gpio. 0 Disable input</description>
	<bitRange>[5:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>TIMER3_GPIO2_CONF_REG</name>
	<description>Timer gpio2 selection</description>
	<addressOffset>0x00000010</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0xffffffff</resetMask>
	<fields><field>
	<name>TIM_GPIO2_CONF</name>
	<description>Select one of the 32 GPIOs as IN2, Valid value 0-32. 1 for the first gpio, 32 for the last gpio. 0 Disable input</description>
	<bitRange>[5:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>TIMER3_PRESCALER_VAL_REG</name>
	<description>Timer prescaler counter value</description>
	<addressOffset>0x00000028</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0xffffffff</resetMask>
	<fields><field>
	<name>TIM_PRESCALER_VAL</name>
	<description>Gives the current prescaler counter value</description>
	<bitRange>[4:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>TIMER3_PWM_CTRL_REG</name>
	<description>Timer pwm frequency register</description>
	<addressOffset>0x0000002c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0xffffffff</resetMask>
	<fields><field>
	<name>TIM_PWM_DC</name>
	<description>Defines the PWM duty cycle. TIM_PWM_DC/( TIM_PWM_FREQ + 1)</description>
	<bitRange>[31:16]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>TIM_PWM_FREQ</name>
	<description>Defines the PWM frequency. Timer clock frequency/(TIM_PWM_FREQ + 1)
Timer clock is clock after prescaler</description>
	<bitRange>[15:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>TIMER3_SETTINGS_REG</name>
	<description>Timer reload value and Delay in shot mode</description>
	<addressOffset>0x00000014</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0xffffffff</resetMask>
	<fields><field>
	<name>TIM_PRESCALER</name>
	<description>Defines the timer count frequency. CLOCK frequency/(TIM_PRESCALER + 1)</description>
	<bitRange>[28:24]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>TIM_RELOAD</name>
	<description>Reload or max value in timer mode. Actual delay is the register value plus synchronization time (3 clock cycles)</description>
	<bitRange>[23:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>TIMER3_STATUS_REG</name>
	<description>Timer status register</description>
	<addressOffset>0x00000008</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00000fff</resetMask>
	<fields><field>
	<name>TIM_SWITCHED_TO_DIVN_CLK</name>
	<description>Indicates that timer clock has been switched to divn clock</description>
	<bitRange>[11:11]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>TIM_PWM_BUSY</name>
	<description>Busy with synchronizing PWM_FREQ_REG and PWM_DC_REG. Do not write a new value to these registers when this bit is high.</description>
	<bitRange>[10:10]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>TIM_TIMER_BUSY</name>
	<description>Busy with synchronizing PRESCALER_REG, RELOAD_REG and SHOTWIDTH_REG. Do not write a new value to these registers when this bit is high.</description>
	<bitRange>[9:9]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>TIM_IRQ_STATUS</name>
	<description>IRQ status bit. When an irq has occurred, this bit is 1.</description>
	<bitRange>[8:8]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>TIM_ONESHOT_PHASE</name>
	<description>OneShot phase
0 = Wait for event
1 = Delay phase
2 = Start Shot
3 = Shot phase</description>
	<bitRange>[3:2]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>TIM_IN2_STATE</name>
	<description>Gives the logic level of the IN1</description>
	<bitRange>[1:1]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>TIM_IN1_STATE</name>
	<description>Gives the logic level of the IN2</description>
	<bitRange>[0:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>TIMER3_TIMER_VAL_REG</name>
	<description>Timer counter value</description>
	<addressOffset>0x00000004</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0xffffffff</resetMask>
	<fields><field>
	<name>TIM_TIMER_VALUE</name>
	<description>Gives the current timer value</description>
	<bitRange>[23:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register></registers>
</peripheral><peripheral>
	<name>TIMER4</name>
	<version>1.0</version>
	<description>TIMER4 registers</description>
	<groupName>Peripheral_Registers</groupName>
	<baseAddress>0x50020a00</baseAddress>
	<size>0</size>
	<addressBlock>
	<offset>0</offset>
	<size>56</size>
	<usage>registers</usage>
</addressBlock>

	<registers>
	<register>
	<name>TIMER4_CAPTURE_GPIO1_REG</name>
	<description>Timer value for event on GPIO1</description>
	<addressOffset>0x00000020</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0xffffffff</resetMask>
	<fields><field>
	<name>TIM_CAPTURE_GPIO1</name>
	<description>Gives the Capture time for event on GPIO1</description>
	<bitRange>[23:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>TIMER4_CAPTURE_GPIO2_REG</name>
	<description>Timer value for event on GPIO2</description>
	<addressOffset>0x00000024</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0xffffffff</resetMask>
	<fields><field>
	<name>TIM_CAPTURE_GPIO2</name>
	<description>Gives the Capture time for event on GPIO2</description>
	<bitRange>[23:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>TIMER4_CLEAR_IRQ_REG</name>
	<description>Timer clear interrupt</description>
	<addressOffset>0x00000034</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00000001</resetMask>
	<fields><field>
	<name>TIM_CLEAR_IRQ</name>
	<description>Write any value clear interrupt</description>
	<bitRange>[0:0]</bitRange>
	<access>write-only</access>
	</field></fields>
</register><register>
	<name>TIMER4_CTRL_REG</name>
	<description>Timer control register</description>
	<addressOffset>0x00000000</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0xffffffff</resetMask>
	<fields><field>
	<name>TIM_CLK_EN</name>
	<description>Timer clock enable
1 = Clock enabled
0 = Clock disabled</description>
	<bitRange>[8:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>TIM_SYS_CLK_EN</name>
	<description>Select clock
1 = Timer uses the DIVN clock
0 = Timer uses the lp clock</description>
	<bitRange>[7:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>TIM_FREE_RUN_MODE_EN</name>
	<description>Valid when timer counts up, if it is 1, timer does not zero when reaches to reload value. it becomes zero only when it reaches the max value.</description>
	<bitRange>[6:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>TIM_IRQ_EN</name>
	<description>Interrupt mask
1 = Timer IRQ is unmasked
0 = Timer IRQ is masked</description>
	<bitRange>[5:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>TIM_IN2_EVENT_FALL_EN</name>
	<description>Event input 2 edge type
1 = Falling edge
0 = Rising edge</description>
	<bitRange>[4:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>TIM_IN1_EVENT_FALL_EN</name>
	<description>Event input 1 edge type
1 = Falling edge
0 = Rising edge</description>
	<bitRange>[3:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>TIM_COUNT_DOWN_EN</name>
	<description>Timer count direction
1 = Down
0 = Up</description>
	<bitRange>[2:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>TIM_EN</name>
	<description>Timer enable
1 = On
0 = Off</description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>TIMER4_GPIO1_CONF_REG</name>
	<description>Timer gpio1 selection</description>
	<addressOffset>0x0000000c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0xffffffff</resetMask>
	<fields><field>
	<name>TIM_GPIO1_CONF</name>
	<description>Select one of the 32 GPIOs as IN1, Valid value 0-32. 1 for the first gpio, 32 for the last gpio. 0 Disable input</description>
	<bitRange>[5:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>TIMER4_GPIO2_CONF_REG</name>
	<description>Timer gpio2 selection</description>
	<addressOffset>0x00000010</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0xffffffff</resetMask>
	<fields><field>
	<name>TIM_GPIO2_CONF</name>
	<description>Select one of the 32 GPIOs as IN2, Valid value 0-32. 1 for the first gpio, 32 for the last gpio. 0 Disable input</description>
	<bitRange>[5:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>TIMER4_PRESCALER_VAL_REG</name>
	<description>Timer prescaler counter value</description>
	<addressOffset>0x00000028</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0xffffffff</resetMask>
	<fields><field>
	<name>TIM_PRESCALER_VAL</name>
	<description>Gives the current prescaler counter value</description>
	<bitRange>[4:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>TIMER4_PWM_CTRL_REG</name>
	<description>Timer pwm frequency register</description>
	<addressOffset>0x0000002c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0xffffffff</resetMask>
	<fields><field>
	<name>TIM_PWM_DC</name>
	<description>Defines the PWM duty cycle. TIM_PWM_DC/( TIM_PWM_FREQ + 1)</description>
	<bitRange>[31:16]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>TIM_PWM_FREQ</name>
	<description>Defines the PWM frequency. Timer clock frequency/(TIM_PWM_FREQ + 1)
Timer clock is clock after prescaler</description>
	<bitRange>[15:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>TIMER4_SETTINGS_REG</name>
	<description>Timer reload value and Delay in shot mode</description>
	<addressOffset>0x00000014</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0xffffffff</resetMask>
	<fields><field>
	<name>TIM_PRESCALER</name>
	<description>Defines the timer count frequency. CLOCK frequency/(TIM_PRESCALER + 1)</description>
	<bitRange>[28:24]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>TIM_RELOAD</name>
	<description>Reload or max value in timer mode. Actual delay is the register value plus synchronization time (3 clock cycles)</description>
	<bitRange>[23:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>TIMER4_STATUS_REG</name>
	<description>Timer status register</description>
	<addressOffset>0x00000008</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x00000fff</resetMask>
	<fields><field>
	<name>TIM_SWITCHED_TO_DIVN_CLK</name>
	<description>Indicates that timer clock has been switched to divn clock</description>
	<bitRange>[11:11]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>TIM_PWM_BUSY</name>
	<description>Busy with synchronizing PWM_FREQ_REG and PWM_DC_REG. Do not write a new value to these registers when this bit is high.</description>
	<bitRange>[10:10]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>TIM_TIMER_BUSY</name>
	<description>Busy with synchronizing PRESCALER_REG, RELOAD_REG and SHOTWIDTH_REG. Do not write a new value to these registers when this bit is high.</description>
	<bitRange>[9:9]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>TIM_IRQ_STATUS</name>
	<description>IRQ status bit. When an irq has occurred, this bit is 1.</description>
	<bitRange>[8:8]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>TIM_ONESHOT_PHASE</name>
	<description>OneShot phase
0 = Wait for event
1 = Delay phase
2 = Start Shot
3 = Shot phase</description>
	<bitRange>[3:2]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>TIM_IN2_STATE</name>
	<description>Gives the logic level of the IN1</description>
	<bitRange>[1:1]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>TIM_IN1_STATE</name>
	<description>Gives the logic level of the IN2</description>
	<bitRange>[0:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>TIMER4_TIMER_VAL_REG</name>
	<description>Timer counter value</description>
	<addressOffset>0x00000004</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0xffffffff</resetMask>
	<fields><field>
	<name>TIM_TIMER_VALUE</name>
	<description>Gives the current timer value</description>
	<bitRange>[23:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register></registers>
</peripheral><peripheral>
	<name>UART</name>
	<version>1.0</version>
	<description>UART registers</description>
	<groupName>Peripheral_Registers</groupName>
	<baseAddress>0x50020000</baseAddress>
	<size>0</size>
	<addressBlock>
	<offset>0</offset>
	<size>256</size>
	<usage>registers</usage>
</addressBlock>

	<registers>
	<register>
	<name>UART_CTR_REG</name>
	<description>Component Type Register</description>
	<addressOffset>0x000000fc</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x44570110</resetValue>
	<resetMask>0xffffffff</resetMask>
	<fields><field>
	<name>UART_CTR</name>
	<description>Component Type Register </description>
	<bitRange>[31:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>UART_DLF_REG</name>
	<description>Divisor Latch Fraction Register</description>
	<addressOffset>0x000000c0</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000000f</resetMask>
	<fields><field>
	<name>UART_DLF</name>
	<description>The fractional value is added to integer value set by DLH, DLL. Fractional value is equal UART_DLF/16</description>
	<bitRange>[3:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART_DMASA_REG</name>
	<description>DMA Software Acknowledge</description>
	<addressOffset>0x000000a8</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0xffffffff</resetMask>
	<fields><field>
	<name>UART_DMASA</name>
	<description>This register is use to perform DMA software acknowledge if a transfer needs to be terminated due to an error condition. For example, if the DMA disables the channel, then the DW_apb_uart should clear its request. This will cause the TX request, TX single, RX request and RX single signals to de-assert. Note that this bit is 'self-clearing' and it is not necessary to clear this bit.</description>
	<bitRange>[0:0]</bitRange>
	<access>write-only</access>
	</field></fields>
</register><register>
	<name>UART_HTX_REG</name>
	<description>Halt TX</description>
	<addressOffset>0x000000a4</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0xffffffff</resetMask>
	<fields><field>
	<name>UART_HALT_TX</name>
	<description>This register is use to halt transmissions, so that the transmit FIFO can be filled by the master when FIFOs are implemented and enabled.
0 = Halt TX disabled
1 = Halt TX enabled
Note, if FIFOs are not enabled, the setting of the halt TX register has no effect on operation. </description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART_IER_DLH_REG</name>
	<description>Interrupt Enable Register</description>
	<addressOffset>0x00000004</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0xffffffff</resetMask>
	<fields><field>
	<name>PTIME_DLH7</name>
	<description>Interrupt Enable Register: PTIME, Programmable THRE Interrupt Mode Enable. This is used to enable/disable the generation of THRE Interrupt. 0 = disabled 1 = enabled
Divisor Latch (High): Bit[7] of the 8 bit DLH register. </description>
	<bitRange>[7:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DLH6_5</name>
	<description>Divisor Latch (High): Bit[6:5] of the 8 bit DLH register</description>
	<bitRange>[6:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>ELCOLR_DLH4</name>
	<description>Interrupt Enable Register: (read only) ELCOLR, this bit controls the method for clearing the status in the LSR register. This is applicable only for Overrun Error, Parity Error, Framing Error, and Break Interrupt status bits.
Always 0 = LSR status bits are cleared either on reading Rx FIFO (RBR Read) or On reading LSR register.
Divisor Latch (High): Bit[4] of the 8 bit DLH register</description>
	<bitRange>[4:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>EDSSI_DLH3</name>
	<description>Interrupt Enable Register: reserved
Divisor Latch (High): Bit[3] of the 8 bit DLH register </description>
	<bitRange>[3:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>ELSI_DLH2</name>
	<description>Interrupt Enable Register: ELSI, Enable Receiver Line Status Interrupt. This is used to enable/disable the generation of Receiver Line Status Interrupt. This is the highest priority interrupt. 0 = disabled 1 = enabled
Divisor Latch (High): Bit[2] of the 8 bit DLH register. </description>
	<bitRange>[2:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>ETBEI_DLH1</name>
	<description>Interrupt Enable Register: ETBEI, Enable Transmit Holding Register Empty Interrupt. This is used to enable/disable the generation of Transmitter Holding Register Empty Interrupt. This is the third highest priority interrupt. 0 = disabled 1 = enabled
Divisor Latch (High): Bit[1] of the 8 bit DLH register. </description>
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>ERBFI_DLH0</name>
	<description>Interrupt Enable Register: ERBFI, Enable Received Data Available Interrupt. This is used to enable/disable the generation of Received Data Available Interrupt and the Character Timeout Interrupt (if in FIFO mode and FIFO's enabled). These are the second highest priority interrupts. 0 = disabled 1 = enabled
Divisor Latch (High): Bit[0] of the 8 bit DLH register. </description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART_IIR_FCR_REG</name>
	<description>Interrupt Identification Register/FIFO Control Register</description>
	<addressOffset>0x00000008</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000001</resetValue>
	<resetMask>0xffffffff</resetMask>
	<fields><field>
	<name>IIR_FCR</name>
	<description>On Read Interrupt Identification Register :
Bits[7:6], FIFO's Enabled (or FIFOSE): This is used to indicate whether the FIFO's are enabled or disabled.
00 = disabled.
11 = enabled.
Bits[5:4],Reserved
Bits[3:0], Interrupt ID (or IID): This indicates the highest priority pending interrupt which can be one of the following types:
0001 = no interrupt pending.
0010 = THR empty.
0100 = received data available.
0110 = receiver line status.
0111 = busy detect.
1100 = character timeout.
On Write FIFO Control Register
Bits[7:6], RCVR Trigger (or RT):. This is used to select the trigger level in the receiver FIFO at which the Received Data Available Interrupt will be generated. In auto flow control mode it is used to determine when the rts_n signal will be de-asserted. It also determines when the dma_rx_req_n signal will be asserted when in certain modes of operation. The following trigger levels are supported: 00 = 1 character in the FIFO 01 = FIFO 1/4 full 10 = FIFO 1/2 full 11 = FIFO 2 less than full
Bits[5:4], TX Empty Trigger (or TET): This is used to select the empty threshold level at which the THRE Interrupts will be generated when the mode is active. It also determines when the dma_tx_req_n signal will be asserted when in certain modes of operation. The following trigger levels are supported: 00 = FIFO empty 01 = 2 characters in the FIFO 10 = FIFO 1/4 full 11 = FIFO 1/2 full
Bit[3], DMA Mode (or DMAM): This determines the DMA signalling mode used for the dma_tx_req_n and dma_rx_req_n output signals. 0 = mode 0 1 = mode 1
Bit[2], XMIT FIFO Reset (or XFIFOR): This resets the control portion of the transmit FIFO and treats the FIFO as empty. Note that this bit is 'self-clearing' and it is not necessary to clear this bit.
Bit[1], RCVR FIFO Reset (or RFIFOR): This resets the control portion of the receive FIFO and treats the FIFO as empty. Note that this bit is 'self-clearing' and it is not necessary to clear this bit.
Bit[0], FIFO Enable (or FIFOE): This enables/disables the transmit (XMIT) and receive (RCVR) FIFO's. Whenever the value of this bit is changed both the XMIT and RCVR controller portion of FIFO's will be reset. </description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART_LCR_REG</name>
	<description>Line Control Register</description>
	<addressOffset>0x0000000c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0xffffffff</resetMask>
	<fields><field>
	<name>UART_DLAB</name>
	<description>Divisor Latch Access Bit.
This bit is used to enable reading and writing of the Divisor Latch register (DLL and DLH) to set the baud rate of the UART.
This bit must be cleared after initial baud rate setup in order to access other registers. </description>
	<bitRange>[7:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>UART_BC</name>
	<description>Break Control Bit.
This is used to cause a break condition to be transmitted to the receiving device. If set to one the serial output is forced to the spacing (logic 0) state. When not in Loopback Mode, as determined by MCR[4], the sout line is forced low until the Break bit is cleared. </description>
	<bitRange>[6:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>UART_EPS</name>
	<description>Even Parity Select. Writeable only when UART is not busy (USR[0] is zero).
This is used to select between even and odd parity, when parity is enabled (PEN set to one). If set to one, an even number of logic 1s is transmitted or checked. If set to zero, an odd number of logic 1s is transmitted or checked. </description>
	<bitRange>[4:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>UART_PEN</name>
	<description>Parity Enable. Writeable only when UART is not busy (USR[0] is zero)
This bit is used to enable and disable parity generation and detection in transmitted and received serial character respectively.
0 = parity disabled
1 = parity enabled </description>
	<bitRange>[3:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>UART_STOP</name>
	<description>Number of stop bits.
This is used to select the number of stop bits per character that the peripheral transmits and receives. If set to zero, one stop bit is transmitted in the serial data.
If set to one and the data bits are set to 5 (LCR[1:0] set to zero) one and a half stop bits is transmitted. Otherwise, two stop bits are transmitted. Note that regardless of the number of stop bits selected, the receiver checks only the first stop bit.
0 = 1 stop bit
1 = 1.5 stop bits when DLS (LCR[1:0]) is zero, else 2 stop bit </description>
	<bitRange>[2:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>UART_DLS</name>
	<description>Data Length Select.
This is used to select the number of data bits per character that the peripheral transmits and receives. The number of bit that may be selected areas follows:
00 = 5 bits
01 = 6 bits
10 = 7 bits
11 = 8 bits </description>
	<bitRange>[1:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART_LSR_REG</name>
	<description>Line Status Register</description>
	<addressOffset>0x00000014</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000060</resetValue>
	<resetMask>0xffffffff</resetMask>
	<fields><field>
	<name>UART_RFE</name>
	<description>Receiver FIFO Error bit.
This bit is only relevant when FIFOs are enabled (FCR[0] set to one). This is used to indicate if there is at least one parity error, framing error, or break indication in the FIFO.
0 = no error in RX FIFO
1 = error in RX FIFO
This bit is cleared when the LSR is read and the character with the error is at the top of the receiver FIFO and there are no subsequent errors in the FIFO. </description>
	<bitRange>[7:7]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>UART_TEMT</name>
	<description>Transmitter Empty bit.
If FIFOs enabled (FCR[0] set to one), this bit is set whenever the Transmitter Shift Register and the FIFO are both empty. If FIFOs are disabled, this bit is set whenever the Transmitter Holding Register and the Transmitter Shift Register are both empty. </description>
	<bitRange>[6:6]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>UART_THRE</name>
	<description>Transmit Holding Register Empty bit.
If THRE mode is disabled (IER[7] set to zero) and regardless of FIFO's being implemented/enabled or not, this bit indicates that the THR or TX FIFO is empty.
This bit is set whenever data is transferred from the THR or TX FIFO to the transmitter shift register and no new data has been written to the THR or TX FIFO. This also causes a THRE Interrupt to occur, if the THRE Interrupt is enabled. If both modes are active (IER[7] set to one and FCR[0] set to one respectively), the functionality is switched to indicate the transmitter FIFO is full, and no longer controls THRE interrupts, which are then controlled by the FCR[5:4] threshold setting. </description>
	<bitRange>[5:5]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>UART_BI</name>
	<description>Break Interrupt bit.
This is used to indicate the detection of a break sequence on the serial input data.
It is set whenever the serial input, sin, is held in a logic '0' state for longer than the sum of start time + data bits + parity + stop bits.
In the FIFO mode, the character associated with the break condition is carried through the FIFO and is revealed when the character is at the top of the FIFO.
Reading the LSR clears the BI bit. In the non-FIFO mode, the BI indication occurs immediately and persists until the LSR is read. </description>
	<bitRange>[4:4]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>UART_FE</name>
	<description>Framing Error bit.
This is used to indicate the occurrence of a framing error in the receiver. A framing error occurs when the receiver does not detect a valid STOP bit in the received data.
In the FIFO mode, since the framing error is associated with a character received, it is revealed when the character with the framing error is at the top of the FIFO.
When a framing error occurs, the UART tries to resynchronize. It does this by assuming that the error was due to the start bit of the next character and then continues receiving the other bit i.e. data, and/or parity and stop. It should be noted that the Framing Error (FE) bit (LSR[3]) is set if a break interrupt has occurred, as indicated by Break Interrupt (BI) bit (LSR[4]).
0 = no framing error
1 = framing error
Reading the LSR clears the FE bit. </description>
	<bitRange>[3:3]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>UART_PE</name>
	<description>Parity Error bit.
This is used to indicate the occurrence of a parity error in the receiver if the Parity Enable (PEN) bit (LCR[3]) is set.
In the FIFO mode, since the parity error is associated with a character received, it is revealed when the character with the parity error arrives at the top of the FIFO.
It should be noted that the Parity Error (PE) bit (LSR[2]) is set if a break interrupt has occurred, as indicated by Break Interrupt (BI) bit (LSR[4]).
0 = no parity error
1 = parity error
Reading the LSR clears the PE bit. </description>
	<bitRange>[2:2]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>UART_OE</name>
	<description>Overrun error bit.
This is used to indicate the occurrence of an overrun error.
This occurs if a new data character was received before the previous data was read.
In the non-FIFO mode, the OE bit is set when a new character arrives in the receiver before the previous character was read from the RBR. When this happens, the data in the RBR is overwritten. In the FIFO mode, an overrun error occurs when the FIFO is full and a new character arrives at the receiver. The data in the FIFO is retained and the data in the receive shift register is lost.
0 = no overrun error
1 = overrun error
Reading the LSR clears the OE bit. </description>
	<bitRange>[1:1]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>UART_DR</name>
	<description>Data Ready bit.
This is used to indicate that the receiver contains at least one character in the RBR or the receiver FIFO.
0 = no data ready
1 = data ready
This bit is cleared when the RBR is read in non-FIFO mode, or when the receiver FIFO is empty, in FIFO mode. </description>
	<bitRange>[0:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>UART_MCR_REG</name>
	<description>Modem Control Register</description>
	<addressOffset>0x00000010</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0xffffffff</resetMask>
	<fields><field>
	<name>UART_LB</name>
	<description>LoopBack Bit.
This is used to put the UART into a diagnostic mode for test purposes.
If operating in UART mode (SIR_MODE not active, MCR[6] set to zero), data on the sout line is held high, while serial data output is looped back to the sin line, internally. In this mode all the interrupts are fully functional. Also, in loopback mode, the modem control inputs (dsr_n, cts_n, ri_n, dcd_n) are disconnected and the modem control outputs (dtr_n, rts_n, out1_n, out2_n) are looped back to the inputs, internally.
If operating in infrared mode (SIR_MODE active, MCR[6] set to one), data on the sir_out_n line is held low, while serial data output is inverted and looped back to the sir_in line. </description>
	<bitRange>[4:4]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART_RBR_THR_DLL_REG</name>
	<description>Receive Buffer Register</description>
	<addressOffset>0x00000000</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0xffffffff</resetMask>
	<fields><field>
	<name>RBR_THR_DLL</name>
	<description>Receive Buffer Register: (RBR).
This register contains the data byte received on the serial input port (sin) in UART mode or the serial infrared input (sir_in) in infrared mode. The data in this register is valid only if the Data Ready (DR) bit in the Line status Register (LSR) is set. If FIFOs are disabled (FCR[0] set to zero), the data in the RBR must be read before the next data arrives, otherwise it will be overwritten, resulting in an overrun error. If FIFOs are enabled (FCR[0] set to one), this register accesses the head of the receive FIFO. If the receive FIFO is full and this register is not read before the next data character arrives, then the data already in the FIFO will be preserved but any incoming data will be lost. An overrun error will also occur.
Transmit Holding Register: (THR)
This register contains data to be transmitted on the serial output port (sout) in UART mode or the serial infrared output (sir_out_n) in infrared mode. Data should only be written to the THR when the THR Empty (THRE) bit (LSR[5]) is set. If FIFO's are disabled (FCR[0] set to zero) and THRE is set, writing a single character to the THR clears the THRE. Any additional writes to the THR before the THRE is set again causes the THR data to be overwritten. If FIFO's are enabled (FCR[0] set to one) and THRE is set, x number of characters of data may be written to the THR before the FIFO is full. The number x (default=16) is determined by the value of FIFO Depth that you set during configuration. Any attempt to write data when the FIFO is full results in the write data being lost.
Divisor Latch (Low): (DLL)
This register makes up the lower 8-bits of a 16-bit, read/write, Divisor Latch register that contains the baud rate divisor for the UART. This register may only be accessed when the DLAB bit (LCR[7]) is set. The output baud rate is equal to the serial clock (sclk) frequency divided by sixteen times the value of the baud rate divisor, as follows:
baud rate = (serial clock freq) / (16 * divisor)
Note that with the Divisor Latch Registers (DLL and DLH) set to zero, the baud clock is disabled and no serial communications will occur. Also, once the DLL is set, at least 8 clock cycles of the slowest DW_apb_uart clock should be allowed to pass before transmitting or receiving data.
Divisor Latch (High): (DLH) (Note: This register is placed in UART_IER_DLH_REG with offset 0x4)
Upper 8-bits of a 16-bit, read/write, Divisor Latch register that contains the baud rate divisor for the UART. This register may be accessed only when the DLAB bit (LCR[7]) is set. The output baud rate is equal to the serial clock frequency divided by sixteen times the value of the baud rate divisor, as follows:
baud rate = (serial clock freq)/(16 * divisor).
Note that with the Divisor Latch Registers (DLL and DLH) set to zero, the baud clock is disabled and no serial communications occur. Also, once the DLH is set, at least 8 clock cycles of the slowest DW_apb_uart clock should be allowed to pass before transmitting or receiving data.</description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART_RFL_REG</name>
	<description>Receive FIFO Level.</description>
	<addressOffset>0x00000084</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000001f</resetMask>
	<fields><field>
	<name>UART_RECEIVE_FIFO_LEVEL</name>
	<description>Receive FIFO Level.
This is indicates the number of data entries in the receive FIFO. </description>
	<bitRange>[4:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>UART_SBCR_REG</name>
	<description>Shadow Break Control Register</description>
	<addressOffset>0x00000090</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0xffffffff</resetMask>
	<fields><field>
	<name>UART_SHADOW_BREAK_CONTROL</name>
	<description>Shadow Break Control Bit.
This is a shadow register for the Break bit (LCR[6]), this can be used to remove the burden of having to performing a read modify write on the LCR. This is used to cause a break condition to be transmitted to the receiving device.
If set to one the serial output is forced to the spacing (logic 0) state. When not in Loopback Mode, as determined by MCR[4], the sout line is forced low until the Break bit is cleared.</description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART_SCR_REG</name>
	<description>Scratchpad Register</description>
	<addressOffset>0x0000001c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0xffffffff</resetMask>
	<fields><field>
	<name>UART_SCRATCH_PAD</name>
	<description>This register is for programmers to use as a temporary storage space. It has no defined purpose in the UART Ctrl. </description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART_SDMAM_REG</name>
	<description>Shadow DMA Mode</description>
	<addressOffset>0x00000094</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0xffffffff</resetMask>
	<fields><field>
	<name>UART_SHADOW_DMA_MODE</name>
	<description>Shadow DMA Mode.
This is a shadow register for the DMA mode bit (FCR[3]). This can be used to remove the burden of having to store the previously written value to the FCR in memory and having to mask this value so that only the DMA Mode bit gets updated. This determines the DMA signalling mode used for the dma_tx_req_n and dma_rx_req_n output signals.
0 = mode 0
1 = mode 1 </description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART_SFE_REG</name>
	<description>Shadow FIFO Enable</description>
	<addressOffset>0x00000098</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0xffffffff</resetMask>
	<fields><field>
	<name>UART_SHADOW_FIFO_ENABLE</name>
	<description>Shadow FIFO Enable.
This is a shadow register for the FIFO enable bit (FCR[0]). This can be used to remove the burden of having to store the previously written value to the FCR in memory and having to mask this value so that only the FIFO enable bit gets updated.This enables/disables the transmit (XMIT) and receive (RCVR) FIFOs. If this bit is set to zero (disabled) after being enabled then both the XMIT and RCVR controller portion of FIFOs are reset. </description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART_SRBR_STHR0_REG</name>
	<description>Shadow Receive/Transmit Buffer Register</description>
	<addressOffset>0x00000030</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0xffffffff</resetMask>
	<fields><field>
	<name>SRBR_STHRx</name>
	<description>Shadow Receive Buffer Register x: This is a shadow register for the RBR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains the data byte received on the serial input port (sin) in UART mode or the serial infrared input (sir_in) in infrared mode. The data in this register is valid only if the Data Ready (DR) bit in the Line status Register (LSR) is set. If FIFOs are disabled (FCR[0] set to zero), the data in the RBR must be read before the next data arrives, otherwise it will be overwritten, resulting in an overrun error. If FIFOs are enabled (FCR[0] set to one), this register accesses the head of the receive FIFO. If the receive FIFO is full and this register is not read before the next data character arrives, then the data already in the FIFO will be preserved but any incoming data will be lost. An overrun error will also occur. Shadow Transmit Holding Register 0: This is a shadow register for the THR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains data to be transmitted on the serial output port (sout) in UART mode or the serial infrared output (sir_out_n) in infrared mode. Data should only be written to the THR when the THR Empty (THRE) bit (LSR[5]) is set. If FIFO's are disabled (FCR[0] set to zero) and THRE is set, writing a single character to the THR clears the THRE. Any additional writes to the THR before the THRE is set again causes the THR data to be overwritten. If FIFO's are enabled (FCR[0] set to one) and THRE is set, x number of characters of data may be written to the THR before the FIFO is full. The number x (default=16) is determined by the value of FIFO Depth that you set during configuration. Any attempt to write data when the FIFO is full results in the write data being lost. </description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART_SRBR_STHR10_REG</name>
	<description>Shadow Receive/Transmit Buffer Register</description>
	<addressOffset>0x00000058</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0xffffffff</resetMask>
	<fields><field>
	<name>SRBR_STHRx</name>
	<description>Shadow Receive Buffer Register x: This is a shadow register for the RBR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains the data byte received on the serial input port (sin) in UART mode or the serial infrared input (sir_in) in infrared mode. The data in this register is valid only if the Data Ready (DR) bit in the Line status Register (LSR) is set. If FIFOs are disabled (FCR[0] set to zero), the data in the RBR must be read before the next data arrives, otherwise it will be overwritten, resulting in an overrun error. If FIFOs are enabled (FCR[0] set to one), this register accesses the head of the receive FIFO. If the receive FIFO is full and this register is not read before the next data character arrives, then the data already in the FIFO will be preserved but any incoming data will be lost. An overrun error will also occur. Shadow Transmit Holding Register 0: This is a shadow register for the THR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains data to be transmitted on the serial output port (sout) in UART mode or the serial infrared output (sir_out_n) in infrared mode. Data should only be written to the THR when the THR Empty (THRE) bit (LSR[5]) is set. If FIFO's are disabled (FCR[0] set to zero) and THRE is set, writing a single character to the THR clears the THRE. Any additional writes to the THR before the THRE is set again causes the THR data to be overwritten. If FIFO's are enabled (FCR[0] set to one) and THRE is set, x number of characters of data may be written to the THR before the FIFO is full. The number x (default=16) is determined by the value of FIFO Depth that you set during configuration. Any attempt to write data when the FIFO is full results in the write data being lost. </description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART_SRBR_STHR11_REG</name>
	<description>Shadow Receive/Transmit Buffer Register</description>
	<addressOffset>0x0000005c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0xffffffff</resetMask>
	<fields><field>
	<name>SRBR_STHRx</name>
	<description>Shadow Receive Buffer Register x: This is a shadow register for the RBR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains the data byte received on the serial input port (sin) in UART mode or the serial infrared input (sir_in) in infrared mode. The data in this register is valid only if the Data Ready (DR) bit in the Line status Register (LSR) is set. If FIFOs are disabled (FCR[0] set to zero), the data in the RBR must be read before the next data arrives, otherwise it will be overwritten, resulting in an overrun error. If FIFOs are enabled (FCR[0] set to one), this register accesses the head of the receive FIFO. If the receive FIFO is full and this register is not read before the next data character arrives, then the data already in the FIFO will be preserved but any incoming data will be lost. An overrun error will also occur. Shadow Transmit Holding Register 0: This is a shadow register for the THR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains data to be transmitted on the serial output port (sout) in UART mode or the serial infrared output (sir_out_n) in infrared mode. Data should only be written to the THR when the THR Empty (THRE) bit (LSR[5]) is set. If FIFO's are disabled (FCR[0] set to zero) and THRE is set, writing a single character to the THR clears the THRE. Any additional writes to the THR before the THRE is set again causes the THR data to be overwritten. If FIFO's are enabled (FCR[0] set to one) and THRE is set, x number of characters of data may be written to the THR before the FIFO is full. The number x (default=16) is determined by the value of FIFO Depth that you set during configuration. Any attempt to write data when the FIFO is full results in the write data being lost. </description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART_SRBR_STHR12_REG</name>
	<description>Shadow Receive/Transmit Buffer Register</description>
	<addressOffset>0x00000060</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0xffffffff</resetMask>
	<fields><field>
	<name>SRBR_STHRx</name>
	<description>Shadow Receive Buffer Register x: This is a shadow register for the RBR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains the data byte received on the serial input port (sin) in UART mode or the serial infrared input (sir_in) in infrared mode. The data in this register is valid only if the Data Ready (DR) bit in the Line status Register (LSR) is set. If FIFOs are disabled (FCR[0] set to zero), the data in the RBR must be read before the next data arrives, otherwise it will be overwritten, resulting in an overrun error. If FIFOs are enabled (FCR[0] set to one), this register accesses the head of the receive FIFO. If the receive FIFO is full and this register is not read before the next data character arrives, then the data already in the FIFO will be preserved but any incoming data will be lost. An overrun error will also occur. Shadow Transmit Holding Register 0: This is a shadow register for the THR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains data to be transmitted on the serial output port (sout) in UART mode or the serial infrared output (sir_out_n) in infrared mode. Data should only be written to the THR when the THR Empty (THRE) bit (LSR[5]) is set. If FIFO's are disabled (FCR[0] set to zero) and THRE is set, writing a single character to the THR clears the THRE. Any additional writes to the THR before the THRE is set again causes the THR data to be overwritten. If FIFO's are enabled (FCR[0] set to one) and THRE is set, x number of characters of data may be written to the THR before the FIFO is full. The number x (default=16) is determined by the value of FIFO Depth that you set during configuration. Any attempt to write data when the FIFO is full results in the write data being lost. </description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART_SRBR_STHR13_REG</name>
	<description>Shadow Receive/Transmit Buffer Register</description>
	<addressOffset>0x00000064</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0xffffffff</resetMask>
	<fields><field>
	<name>SRBR_STHRx</name>
	<description>Shadow Receive Buffer Register x: This is a shadow register for the RBR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains the data byte received on the serial input port (sin) in UART mode or the serial infrared input (sir_in) in infrared mode. The data in this register is valid only if the Data Ready (DR) bit in the Line status Register (LSR) is set. If FIFOs are disabled (FCR[0] set to zero), the data in the RBR must be read before the next data arrives, otherwise it will be overwritten, resulting in an overrun error. If FIFOs are enabled (FCR[0] set to one), this register accesses the head of the receive FIFO. If the receive FIFO is full and this register is not read before the next data character arrives, then the data already in the FIFO will be preserved but any incoming data will be lost. An overrun error will also occur. Shadow Transmit Holding Register 0: This is a shadow register for the THR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains data to be transmitted on the serial output port (sout) in UART mode or the serial infrared output (sir_out_n) in infrared mode. Data should only be written to the THR when the THR Empty (THRE) bit (LSR[5]) is set. If FIFO's are disabled (FCR[0] set to zero) and THRE is set, writing a single character to the THR clears the THRE. Any additional writes to the THR before the THRE is set again causes the THR data to be overwritten. If FIFO's are enabled (FCR[0] set to one) and THRE is set, x number of characters of data may be written to the THR before the FIFO is full. The number x (default=16) is determined by the value of FIFO Depth that you set during configuration. Any attempt to write data when the FIFO is full results in the write data being lost. </description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART_SRBR_STHR14_REG</name>
	<description>Shadow Receive/Transmit Buffer Register</description>
	<addressOffset>0x00000068</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0xffffffff</resetMask>
	<fields><field>
	<name>SRBR_STHRx</name>
	<description>Shadow Receive Buffer Register x: This is a shadow register for the RBR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains the data byte received on the serial input port (sin) in UART mode or the serial infrared input (sir_in) in infrared mode. The data in this register is valid only if the Data Ready (DR) bit in the Line status Register (LSR) is set. If FIFOs are disabled (FCR[0] set to zero), the data in the RBR must be read before the next data arrives, otherwise it will be overwritten, resulting in an overrun error. If FIFOs are enabled (FCR[0] set to one), this register accesses the head of the receive FIFO. If the receive FIFO is full and this register is not read before the next data character arrives, then the data already in the FIFO will be preserved but any incoming data will be lost. An overrun error will also occur. Shadow Transmit Holding Register 0: This is a shadow register for the THR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains data to be transmitted on the serial output port (sout) in UART mode or the serial infrared output (sir_out_n) in infrared mode. Data should only be written to the THR when the THR Empty (THRE) bit (LSR[5]) is set. If FIFO's are disabled (FCR[0] set to zero) and THRE is set, writing a single character to the THR clears the THRE. Any additional writes to the THR before the THRE is set again causes the THR data to be overwritten. If FIFO's are enabled (FCR[0] set to one) and THRE is set, x number of characters of data may be written to the THR before the FIFO is full. The number x (default=16) is determined by the value of FIFO Depth that you set during configuration. Any attempt to write data when the FIFO is full results in the write data being lost. </description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART_SRBR_STHR15_REG</name>
	<description>Shadow Receive/Transmit Buffer Register</description>
	<addressOffset>0x0000006c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0xffffffff</resetMask>
	<fields><field>
	<name>SRBR_STHRx</name>
	<description>Shadow Receive Buffer Register x: This is a shadow register for the RBR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains the data byte received on the serial input port (sin) in UART mode or the serial infrared input (sir_in) in infrared mode. The data in this register is valid only if the Data Ready (DR) bit in the Line status Register (LSR) is set. If FIFOs are disabled (FCR[0] set to zero), the data in the RBR must be read before the next data arrives, otherwise it will be overwritten, resulting in an overrun error. If FIFOs are enabled (FCR[0] set to one), this register accesses the head of the receive FIFO. If the receive FIFO is full and this register is not read before the next data character arrives, then the data already in the FIFO will be preserved but any incoming data will be lost. An overrun error will also occur. Shadow Transmit Holding Register 0: This is a shadow register for the THR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains data to be transmitted on the serial output port (sout) in UART mode or the serial infrared output (sir_out_n) in infrared mode. Data should only be written to the THR when the THR Empty (THRE) bit (LSR[5]) is set. If FIFO's are disabled (FCR[0] set to zero) and THRE is set, writing a single character to the THR clears the THRE. Any additional writes to the THR before the THRE is set again causes the THR data to be overwritten. If FIFO's are enabled (FCR[0] set to one) and THRE is set, x number of characters of data may be written to the THR before the FIFO is full. The number x (default=16) is determined by the value of FIFO Depth that you set during configuration. Any attempt to write data when the FIFO is full results in the write data being lost. </description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART_SRBR_STHR1_REG</name>
	<description>Shadow Receive/Transmit Buffer Register</description>
	<addressOffset>0x00000034</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0xffffffff</resetMask>
	<fields><field>
	<name>SRBR_STHRx</name>
	<description>Shadow Receive Buffer Register x: This is a shadow register for the RBR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains the data byte received on the serial input port (sin) in UART mode or the serial infrared input (sir_in) in infrared mode. The data in this register is valid only if the Data Ready (DR) bit in the Line status Register (LSR) is set. If FIFOs are disabled (FCR[0] set to zero), the data in the RBR must be read before the next data arrives, otherwise it will be overwritten, resulting in an overrun error. If FIFOs are enabled (FCR[0] set to one), this register accesses the head of the receive FIFO. If the receive FIFO is full and this register is not read before the next data character arrives, then the data already in the FIFO will be preserved but any incoming data will be lost. An overrun error will also occur. Shadow Transmit Holding Register 0: This is a shadow register for the THR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains data to be transmitted on the serial output port (sout) in UART mode or the serial infrared output (sir_out_n) in infrared mode. Data should only be written to the THR when the THR Empty (THRE) bit (LSR[5]) is set. If FIFO's are disabled (FCR[0] set to zero) and THRE is set, writing a single character to the THR clears the THRE. Any additional writes to the THR before the THRE is set again causes the THR data to be overwritten. If FIFO's are enabled (FCR[0] set to one) and THRE is set, x number of characters of data may be written to the THR before the FIFO is full. The number x (default=16) is determined by the value of FIFO Depth that you set during configuration. Any attempt to write data when the FIFO is full results in the write data being lost. </description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART_SRBR_STHR2_REG</name>
	<description>Shadow Receive/Transmit Buffer Register</description>
	<addressOffset>0x00000038</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0xffffffff</resetMask>
	<fields><field>
	<name>SRBR_STHRx</name>
	<description>Shadow Receive Buffer Register x: This is a shadow register for the RBR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains the data byte received on the serial input port (sin) in UART mode or the serial infrared input (sir_in) in infrared mode. The data in this register is valid only if the Data Ready (DR) bit in the Line status Register (LSR) is set. If FIFOs are disabled (FCR[0] set to zero), the data in the RBR must be read before the next data arrives, otherwise it will be overwritten, resulting in an overrun error. If FIFOs are enabled (FCR[0] set to one), this register accesses the head of the receive FIFO. If the receive FIFO is full and this register is not read before the next data character arrives, then the data already in the FIFO will be preserved but any incoming data will be lost. An overrun error will also occur. Shadow Transmit Holding Register 0: This is a shadow register for the THR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains data to be transmitted on the serial output port (sout) in UART mode or the serial infrared output (sir_out_n) in infrared mode. Data should only be written to the THR when the THR Empty (THRE) bit (LSR[5]) is set. If FIFO's are disabled (FCR[0] set to zero) and THRE is set, writing a single character to the THR clears the THRE. Any additional writes to the THR before the THRE is set again causes the THR data to be overwritten. If FIFO's are enabled (FCR[0] set to one) and THRE is set, x number of characters of data may be written to the THR before the FIFO is full. The number x (default=16) is determined by the value of FIFO Depth that you set during configuration. Any attempt to write data when the FIFO is full results in the write data being lost. </description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART_SRBR_STHR3_REG</name>
	<description>Shadow Receive/Transmit Buffer Register</description>
	<addressOffset>0x0000003c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0xffffffff</resetMask>
	<fields><field>
	<name>SRBR_STHRx</name>
	<description>Shadow Receive Buffer Register x: This is a shadow register for the RBR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains the data byte received on the serial input port (sin) in UART mode or the serial infrared input (sir_in) in infrared mode. The data in this register is valid only if the Data Ready (DR) bit in the Line status Register (LSR) is set. If FIFOs are disabled (FCR[0] set to zero), the data in the RBR must be read before the next data arrives, otherwise it will be overwritten, resulting in an overrun error. If FIFOs are enabled (FCR[0] set to one), this register accesses the head of the receive FIFO. If the receive FIFO is full and this register is not read before the next data character arrives, then the data already in the FIFO will be preserved but any incoming data will be lost. An overrun error will also occur. Shadow Transmit Holding Register 0: This is a shadow register for the THR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains data to be transmitted on the serial output port (sout) in UART mode or the serial infrared output (sir_out_n) in infrared mode. Data should only be written to the THR when the THR Empty (THRE) bit (LSR[5]) is set. If FIFO's are disabled (FCR[0] set to zero) and THRE is set, writing a single character to the THR clears the THRE. Any additional writes to the THR before the THRE is set again causes the THR data to be overwritten. If FIFO's are enabled (FCR[0] set to one) and THRE is set, x number of characters of data may be written to the THR before the FIFO is full. The number x (default=16) is determined by the value of FIFO Depth that you set during configuration. Any attempt to write data when the FIFO is full results in the write data being lost. </description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART_SRBR_STHR4_REG</name>
	<description>Shadow Receive/Transmit Buffer Register</description>
	<addressOffset>0x00000040</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0xffffffff</resetMask>
	<fields><field>
	<name>SRBR_STHRx</name>
	<description>Shadow Receive Buffer Register x: This is a shadow register for the RBR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains the data byte received on the serial input port (sin) in UART mode or the serial infrared input (sir_in) in infrared mode. The data in this register is valid only if the Data Ready (DR) bit in the Line status Register (LSR) is set. If FIFOs are disabled (FCR[0] set to zero), the data in the RBR must be read before the next data arrives, otherwise it will be overwritten, resulting in an overrun error. If FIFOs are enabled (FCR[0] set to one), this register accesses the head of the receive FIFO. If the receive FIFO is full and this register is not read before the next data character arrives, then the data already in the FIFO will be preserved but any incoming data will be lost. An overrun error will also occur. Shadow Transmit Holding Register 0: This is a shadow register for the THR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains data to be transmitted on the serial output port (sout) in UART mode or the serial infrared output (sir_out_n) in infrared mode. Data should only be written to the THR when the THR Empty (THRE) bit (LSR[5]) is set. If FIFO's are disabled (FCR[0] set to zero) and THRE is set, writing a single character to the THR clears the THRE. Any additional writes to the THR before the THRE is set again causes the THR data to be overwritten. If FIFO's are enabled (FCR[0] set to one) and THRE is set, x number of characters of data may be written to the THR before the FIFO is full. The number x (default=16) is determined by the value of FIFO Depth that you set during configuration. Any attempt to write data when the FIFO is full results in the write data being lost. </description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART_SRBR_STHR5_REG</name>
	<description>Shadow Receive/Transmit Buffer Register</description>
	<addressOffset>0x00000044</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0xffffffff</resetMask>
	<fields><field>
	<name>SRBR_STHRx</name>
	<description>Shadow Receive Buffer Register x: This is a shadow register for the RBR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains the data byte received on the serial input port (sin) in UART mode or the serial infrared input (sir_in) in infrared mode. The data in this register is valid only if the Data Ready (DR) bit in the Line status Register (LSR) is set. If FIFOs are disabled (FCR[0] set to zero), the data in the RBR must be read before the next data arrives, otherwise it will be overwritten, resulting in an overrun error. If FIFOs are enabled (FCR[0] set to one), this register accesses the head of the receive FIFO. If the receive FIFO is full and this register is not read before the next data character arrives, then the data already in the FIFO will be preserved but any incoming data will be lost. An overrun error will also occur. Shadow Transmit Holding Register 0: This is a shadow register for the THR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains data to be transmitted on the serial output port (sout) in UART mode or the serial infrared output (sir_out_n) in infrared mode. Data should only be written to the THR when the THR Empty (THRE) bit (LSR[5]) is set. If FIFO's are disabled (FCR[0] set to zero) and THRE is set, writing a single character to the THR clears the THRE. Any additional writes to the THR before the THRE is set again causes the THR data to be overwritten. If FIFO's are enabled (FCR[0] set to one) and THRE is set, x number of characters of data may be written to the THR before the FIFO is full. The number x (default=16) is determined by the value of FIFO Depth that you set during configuration. Any attempt to write data when the FIFO is full results in the write data being lost. </description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART_SRBR_STHR6_REG</name>
	<description>Shadow Receive/Transmit Buffer Register</description>
	<addressOffset>0x00000048</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0xffffffff</resetMask>
	<fields><field>
	<name>SRBR_STHRx</name>
	<description>Shadow Receive Buffer Register x: This is a shadow register for the RBR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains the data byte received on the serial input port (sin) in UART mode or the serial infrared input (sir_in) in infrared mode. The data in this register is valid only if the Data Ready (DR) bit in the Line status Register (LSR) is set. If FIFOs are disabled (FCR[0] set to zero), the data in the RBR must be read before the next data arrives, otherwise it will be overwritten, resulting in an overrun error. If FIFOs are enabled (FCR[0] set to one), this register accesses the head of the receive FIFO. If the receive FIFO is full and this register is not read before the next data character arrives, then the data already in the FIFO will be preserved but any incoming data will be lost. An overrun error will also occur. Shadow Transmit Holding Register 0: This is a shadow register for the THR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains data to be transmitted on the serial output port (sout) in UART mode or the serial infrared output (sir_out_n) in infrared mode. Data should only be written to the THR when the THR Empty (THRE) bit (LSR[5]) is set. If FIFO's are disabled (FCR[0] set to zero) and THRE is set, writing a single character to the THR clears the THRE. Any additional writes to the THR before the THRE is set again causes the THR data to be overwritten. If FIFO's are enabled (FCR[0] set to one) and THRE is set, x number of characters of data may be written to the THR before the FIFO is full. The number x (default=16) is determined by the value of FIFO Depth that you set during configuration. Any attempt to write data when the FIFO is full results in the write data being lost. </description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART_SRBR_STHR7_REG</name>
	<description>Shadow Receive/Transmit Buffer Register</description>
	<addressOffset>0x0000004c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0xffffffff</resetMask>
	<fields><field>
	<name>SRBR_STHRx</name>
	<description>Shadow Receive Buffer Register x: This is a shadow register for the RBR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains the data byte received on the serial input port (sin) in UART mode or the serial infrared input (sir_in) in infrared mode. The data in this register is valid only if the Data Ready (DR) bit in the Line status Register (LSR) is set. If FIFOs are disabled (FCR[0] set to zero), the data in the RBR must be read before the next data arrives, otherwise it will be overwritten, resulting in an overrun error. If FIFOs are enabled (FCR[0] set to one), this register accesses the head of the receive FIFO. If the receive FIFO is full and this register is not read before the next data character arrives, then the data already in the FIFO will be preserved but any incoming data will be lost. An overrun error will also occur. Shadow Transmit Holding Register 0: This is a shadow register for the THR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains data to be transmitted on the serial output port (sout) in UART mode or the serial infrared output (sir_out_n) in infrared mode. Data should only be written to the THR when the THR Empty (THRE) bit (LSR[5]) is set. If FIFO's are disabled (FCR[0] set to zero) and THRE is set, writing a single character to the THR clears the THRE. Any additional writes to the THR before the THRE is set again causes the THR data to be overwritten. If FIFO's are enabled (FCR[0] set to one) and THRE is set, x number of characters of data may be written to the THR before the FIFO is full. The number x (default=16) is determined by the value of FIFO Depth that you set during configuration. Any attempt to write data when the FIFO is full results in the write data being lost. </description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART_SRBR_STHR8_REG</name>
	<description>Shadow Receive/Transmit Buffer Register</description>
	<addressOffset>0x00000050</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0xffffffff</resetMask>
	<fields><field>
	<name>SRBR_STHRx</name>
	<description>Shadow Receive Buffer Register x: This is a shadow register for the RBR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains the data byte received on the serial input port (sin) in UART mode or the serial infrared input (sir_in) in infrared mode. The data in this register is valid only if the Data Ready (DR) bit in the Line status Register (LSR) is set. If FIFOs are disabled (FCR[0] set to zero), the data in the RBR must be read before the next data arrives, otherwise it will be overwritten, resulting in an overrun error. If FIFOs are enabled (FCR[0] set to one), this register accesses the head of the receive FIFO. If the receive FIFO is full and this register is not read before the next data character arrives, then the data already in the FIFO will be preserved but any incoming data will be lost. An overrun error will also occur. Shadow Transmit Holding Register 0: This is a shadow register for the THR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains data to be transmitted on the serial output port (sout) in UART mode or the serial infrared output (sir_out_n) in infrared mode. Data should only be written to the THR when the THR Empty (THRE) bit (LSR[5]) is set. If FIFO's are disabled (FCR[0] set to zero) and THRE is set, writing a single character to the THR clears the THRE. Any additional writes to the THR before the THRE is set again causes the THR data to be overwritten. If FIFO's are enabled (FCR[0] set to one) and THRE is set, x number of characters of data may be written to the THR before the FIFO is full. The number x (default=16) is determined by the value of FIFO Depth that you set during configuration. Any attempt to write data when the FIFO is full results in the write data being lost. </description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART_SRBR_STHR9_REG</name>
	<description>Shadow Receive/Transmit Buffer Register</description>
	<addressOffset>0x00000054</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0xffffffff</resetMask>
	<fields><field>
	<name>SRBR_STHRx</name>
	<description>Shadow Receive Buffer Register x: This is a shadow register for the RBR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains the data byte received on the serial input port (sin) in UART mode or the serial infrared input (sir_in) in infrared mode. The data in this register is valid only if the Data Ready (DR) bit in the Line status Register (LSR) is set. If FIFOs are disabled (FCR[0] set to zero), the data in the RBR must be read before the next data arrives, otherwise it will be overwritten, resulting in an overrun error. If FIFOs are enabled (FCR[0] set to one), this register accesses the head of the receive FIFO. If the receive FIFO is full and this register is not read before the next data character arrives, then the data already in the FIFO will be preserved but any incoming data will be lost. An overrun error will also occur. Shadow Transmit Holding Register 0: This is a shadow register for the THR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains data to be transmitted on the serial output port (sout) in UART mode or the serial infrared output (sir_out_n) in infrared mode. Data should only be written to the THR when the THR Empty (THRE) bit (LSR[5]) is set. If FIFO's are disabled (FCR[0] set to zero) and THRE is set, writing a single character to the THR clears the THRE. Any additional writes to the THR before the THRE is set again causes the THR data to be overwritten. If FIFO's are enabled (FCR[0] set to one) and THRE is set, x number of characters of data may be written to the THR before the FIFO is full. The number x (default=16) is determined by the value of FIFO Depth that you set during configuration. Any attempt to write data when the FIFO is full results in the write data being lost. </description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART_SRR_REG</name>
	<description>Software Reset Register.</description>
	<addressOffset>0x00000088</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0xffffffff</resetMask>
	<fields><field>
	<name>UART_XFR</name>
	<description>XMIT FIFO Reset.
This is a shadow register for the XMIT FIFO Reset bit (FCR[2]). This can be used to remove the burden on software having to store previously written FCR values (which are pretty static) just to reset the transmit FIFO. This resets the control portion of the transmit FIFO and treats the FIFO as empty. Note that this bit is 'self-clearing'. It is not necessary to clear this bit. </description>
	<bitRange>[2:2]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>UART_RFR</name>
	<description>RCVR FIFO Reset.
This is a shadow register for the RCVR FIFO Reset bit (FCR[1]). This can be used to remove the burden on software having to store previously written FCR values (which are pretty static) just to reset the receive FIFO This resets the control portion of the receive FIFO and treats the FIFO as empty.
Note that this bit is 'self-clearing'. It is not necessary to clear this bit. </description>
	<bitRange>[1:1]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>UART_UR</name>
	<description>UART Reset. This asynchronously resets the UART Ctrl and synchronously removes the reset assertion. For a two clock implementation both pclk and sclk domains are reset. </description>
	<bitRange>[0:0]</bitRange>
	<access>write-only</access>
	</field></fields>
</register><register>
	<name>UART_SRT_REG</name>
	<description>Shadow RCVR Trigger</description>
	<addressOffset>0x0000009c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0xffffffff</resetMask>
	<fields><field>
	<name>UART_SHADOW_RCVR_TRIGGER</name>
	<description>Shadow RCVR Trigger.
This is a shadow register for the RCVR trigger bits (FCR[7:6]). This can be used to remove the burden of having to store the previously written value to the FCR in memory and having to mask this value so that only the RCVR trigger bit gets updated.
This is used to select the trigger level in the receiver FIFO at which the Received Data Available Interrupt is generated. It also determines when the dma_rx_req_n signal is asserted when DMA Mode (FCR[3]) = 1. The following trigger levels are supported:
00 = 1 character in the FIFO
01 = FIFO &#188; full
10 = FIFO &#189; full
11 = FIFO 2 less than full </description>
	<bitRange>[1:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART_STET_REG</name>
	<description>Shadow TX Empty Trigger</description>
	<addressOffset>0x000000a0</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0xffffffff</resetMask>
	<fields><field>
	<name>UART_SHADOW_TX_EMPTY_TRIGGER</name>
	<description>Shadow TX Empty Trigger.
This is a shadow register for the TX empty trigger bits (FCR[5:4]). This can be used to remove the burden of having to store the previously written value to the FCR in memory and having to mask this value so that only the TX empty trigger bit gets updated.
This is used to select the empty threshold level at which the THRE Interrupts are generated when the mode is active. The following trigger levels are supported:
00 = FIFO empty
01 = 2 characters in the FIFO
10 = FIFO &#188; full
11 = FIFO &#189; full </description>
	<bitRange>[1:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART_TFL_REG</name>
	<description>Transmit FIFO Level</description>
	<addressOffset>0x00000080</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000001f</resetMask>
	<fields><field>
	<name>UART_TRANSMIT_FIFO_LEVEL</name>
	<description>Transmit FIFO Level.
This is indicates the number of data entries in the transmit FIFO. </description>
	<bitRange>[4:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>UART_UCV_REG</name>
	<description>Component Version</description>
	<addressOffset>0x000000f8</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x3430312a</resetValue>
	<resetMask>0xffffffff</resetMask>
	<fields><field>
	<name>UART_UCV</name>
	<description>Component Version </description>
	<bitRange>[31:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>UART_USR_REG</name>
	<description>UART Status register.</description>
	<addressOffset>0x0000007c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000006</resetValue>
	<resetMask>0xffffffff</resetMask>
	<fields><field>
	<name>UART_RFF</name>
	<description>Receive FIFO Full.
This is used to indicate that the receive FIFO is completely full.
0 = Receive FIFO not full
1 = Receive FIFO Full
This bit is cleared when the RX FIFO is no longer full. </description>
	<bitRange>[4:4]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>UART_RFNE</name>
	<description>Receive FIFO Not Empty.
This is used to indicate that the receive FIFO contains one or more entries.
0 = Receive FIFO is empty
1 = Receive FIFO is not empty
This bit is cleared when the RX FIFO is empty. </description>
	<bitRange>[3:3]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>UART_TFE</name>
	<description>Transmit FIFO Empty.
This is used to indicate that the transmit FIFO is completely empty.
0 = Transmit FIFO is not empty
1 = Transmit FIFO is empty
This bit is cleared when the TX FIFO is no longer empty. </description>
	<bitRange>[2:2]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>UART_TFNF</name>
	<description>Transmit FIFO Not Full.
This is used to indicate that the transmit FIFO in not full.
0 = Transmit FIFO is full
1 = Transmit FIFO is not full
This bit is cleared when the TX FIFO is full. </description>
	<bitRange>[1:1]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>UART_BUSY</name>
	<description>UART Busy. This indicates that a serial transfer is in progress, when cleared indicates that the uart is idle or inactive.
0 = uart is idle or inactive
1 =uart is busy (actively transferring data)
Note that it is possible for the UART Busy bit to be cleared even though a new character may have been sent from another device. That is, if the uart has no data in the THR and RBR and there is no transmission in progress and a start bit of a new character has just reached the uart. This is due to the fact that a valid start is not seen until the middle of the bit period and this duration is dependent on the baud divisor that has been programmed. If a second system clock has been implemented (CLOCK_MODE == Enabled) the assertion of this bit will also be delayed by several cycles of the slower clock.</description>
	<bitRange>[0:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register></registers>
</peripheral><peripheral>
	<name>UART2</name>
	<version>1.0</version>
	<description>UART2 registers</description>
	<groupName>Peripheral_Registers</groupName>
	<baseAddress>0x50020100</baseAddress>
	<size>0</size>
	<addressBlock>
	<offset>0</offset>
	<size>256</size>
	<usage>registers</usage>
</addressBlock>

	<registers>
	<register>
	<name>UART2_CONFIG_REG</name>
	<description>ISO7816 Config Register</description>
	<addressOffset>0x0000001c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0xffffffff</resetMask>
	<fields><field>
	<name>ISO7816_SCRATCH_PAD</name>
	<description>This register is for programmers to use as a temporary storage space. It has no defined purpose in the UART Ctrl. </description>
	<bitRange>[7:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>ISO7816_ENABLE</name>
	<description>0: Normal UART
1: ISO7816 Enabled</description>
	<bitRange>[2:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>ISO7816_ERR_SIG_EN</name>
	<description>0: Error Signal feature disabled
1: Error Signal feature enabled</description>
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>ISO7816_CONVENTION</name>
	<description>0: Direct convention
1: Inverse convention</description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART2_CTRL_REG</name>
	<description>ISO7816 Control Register</description>
	<addressOffset>0x000000e0</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0xffffffff</resetMask>
	<fields><field>
	<name>ISO7816_AUTO_GT</name>
	<description>0: UART sends when tx data is available
1: UART sends new character after guard time</description>
	<bitRange>[11:11]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>ISO7816_ERR_TX_VALUE_IRQMASK</name>
	<description>0: ERR_TX_VALUE IRQ is masked
1: ERR_TX_VALUE IRQ is enabled</description>
	<bitRange>[10:10]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>ISO7816_ERR_TX_TIME_IRQMASK</name>
	<description>0: ERR_TX_TIME IRQ is masked
1: ERR_TX_TIME IRQ is enabled</description>
	<bitRange>[9:9]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>ISO7816_TIM_EXPIRED_IRQMASK</name>
	<description>0: Timer expired IRQ is masked
1: Timer expired IRQ is enabled</description>
	<bitRange>[8:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>ISO7816_CLK_STATUS</name>
	<description>0: ISO7816 clock is stopped
1: ISO7816 clock is running</description>
	<bitRange>[7:7]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>ISO7816_CLK_LEVEL</name>
	<description>0: ISO7816 clock level low when stopped
1: ISO7816 clock level high when stopped</description>
	<bitRange>[6:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>ISO7816_CLK_EN</name>
	<description>0: ISO7816 clock disabled
1: ISO7816 clock enabled</description>
	<bitRange>[5:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>ISO7816_CLK_DIV</name>
	<description>ISO7816 clk freq = sclk/(2*(ISO7816_CLK_DIV+1)</description>
	<bitRange>[4:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART2_CTR_REG</name>
	<description>Component Type Register</description>
	<addressOffset>0x000000fc</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x44570110</resetValue>
	<resetMask>0xffffffff</resetMask>
	<fields><field>
	<name>UART_CTR</name>
	<description>Component Type Register </description>
	<bitRange>[31:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>UART2_DLF_REG</name>
	<description>Divisor Latch Fraction Register</description>
	<addressOffset>0x000000c0</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0xffffffff</resetMask>
	<fields><field>
	<name>UART_DLF</name>
	<description>The fractional value is added to integer value set by DLH, DLL. Fractional value is equal UART_DLF/16</description>
	<bitRange>[3:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART2_DMASA_REG</name>
	<description>DMA Software Acknowledge</description>
	<addressOffset>0x000000a8</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0xffffffff</resetMask>
	<fields><field>
	<name>UART_DMASA</name>
	<description>This register is use to perform DMA software acknowledge if a transfer needs to be terminated due to an error condition. For example, if the DMA disables the channel, then the DW_apb_uart should clear its request. This will cause the TX request, TX single, RX request and RX single signals to de-assert. Note that this bit is 'self-clearing' and it is not necessary to clear this bit.</description>
	<bitRange>[0:0]</bitRange>
	<access>write-only</access>
	</field></fields>
</register><register>
	<name>UART2_ERR_CTRL_REG</name>
	<description>ISO7816 Error Signal Control Register</description>
	<addressOffset>0x000000e8</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x0000010e</resetValue>
	<resetMask>0xffffffff</resetMask>
	<fields><field>
	<name>ISO7816_ERR_PULSE_WIDTH</name>
	<description>When Error Signal feature is enable and receive mode, it gives the width of the error signal in 1/16 etu</description>
	<bitRange>[8:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>ISO7816_ERR_PULSE_OFFSET</name>
	<description>When Error Signal feature is enable and receive mode, it gives the offset of the error signal in 1/16 etu from the 9.6 etu</description>
	<bitRange>[3:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART2_HTX_REG</name>
	<description>Halt TX</description>
	<addressOffset>0x000000a4</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0xffffffff</resetMask>
	<fields><field>
	<name>UART_HALT_TX</name>
	<description>This register is use to halt transmissions, so that the transmit FIFO can be filled by the master when FIFOs are implemented and enabled.
0 = Halt TX disabled
1 = Halt TX enabled
Note, if FIFOs are not enabled, the setting of the halt TX register has no effect on operation. </description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART2_IER_DLH_REG</name>
	<description>Interrupt Enable Register</description>
	<addressOffset>0x00000004</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0xffffffff</resetMask>
	<fields><field>
	<name>PTIME_DLH7</name>
	<description>Interrupt Enable Register: PTIME, Programmable THRE Interrupt Mode Enable. This is used to enable/disable the generation of THRE Interrupt. 0 = disabled 1 = enabled
Divisor Latch (High): Bit[7] of the 8 bit DLH register. </description>
	<bitRange>[7:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>DLH6_5</name>
	<description>Divisor Latch (High): Bit[6:5] of the 8 bit DLH register </description>
	<bitRange>[6:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>ELCOLR_DLH4</name>
	<description>Interrupt Enable Register: ELCOLR (read only), this bit controls the method for clearing the status in the LSR register. This is applicable only for Overrun Error, Parity Error, Framing Error, and Break Interrupt status bits.
0 = LSR status bits are cleared either on reading Rx FIFO (RBR Read) or On reading LSR register.
Divisor Latch (High): Bit[4] of the 8 bit DLH register </description>
	<bitRange>[4:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>EDSSI_DLH3</name>
	<description>Interrupt Enable Register: EDSSI, Enable Modem Status Interrupt. This is used to enable/disable the generation of Modem Status Interrupt. This is the fourth highest priority interrupt. 0 = disabled 1 = enabled
Divisor Latch (High): Bit[3] of the 8 bit DLH register </description>
	<bitRange>[3:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>ELSI_DLH2</name>
	<description>Interrupt Enable Register: ELSI, Enable Receiver Line Status Interrupt. This is used to enable/disable the generation of Receiver Line Status Interrupt. This is the highest priority interrupt. 0 = disabled 1 = enabled
Divisor Latch (High): Bit[2] of the 8 bit DLH register. </description>
	<bitRange>[2:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>ETBEI_DLH1</name>
	<description>Interrupt Enable Register: ETBEI, Enable Transmit Holding Register Empty Interrupt. This is used to enable/disable the generation of Transmitter Holding Register Empty Interrupt. This is the third highest priority interrupt. 0 = disabled 1 = enabled
Divisor Latch (High): Bit[1] of the 8 bit DLH register. </description>
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>ERBFI_DLH0</name>
	<description>Interrupt Enable Register: ERBFI, Enable Received Data Available Interrupt. This is used to enable/disable the generation of Received Data Available Interrupt and the Character Timeout Interrupt (if in FIFO mode and FIFO's enabled). These are the second highest priority interrupts. 0 = disabled 1 = enabled
Divisor Latch (High): Bit[0] of the 8 bit DLH register. </description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART2_IIR_FCR_REG</name>
	<description>Interrupt Identification Register/FIFO Control Register</description>
	<addressOffset>0x00000008</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000001</resetValue>
	<resetMask>0xffffffff</resetMask>
	<fields><field>
	<name>IIR_FCR</name>
	<description>On Read Interrupt Identification Register :
Bits[7:6], FIFO's Enabled (or FIFOSE): This is used to indicate whether the FIFO's are enabled or disabled. 00 = disabled. 11 = enabled.
Bits[5:4],Reserved
Bits[3:0], Interrupt ID (or IID): This indicates the highest priority pending interrupt which can be one of the following types:0001 = no interrupt pending. 0010 = THR empty. 0100 = received data available. 0110 = receiver line status. 0111 = busy detect. 1100 = character timeout.
On Write FIFO Control Register
Bits[7:6], RCVR Trigger (or RT):. This is used to select the trigger level in the receiver FIFO at which the Received Data Available Interrupt will be generated. In auto flow control mode it is used to determine when the rts_n signal will be de-asserted. It also determines when the dma_rx_req_n signal will be asserted when in certain modes of operation. The following trigger levels are supported: 00 = 1 character in the FIFO 01 = FIFO 1/4 full 10 = FIFO 1/2 full 11 = FIFO 2 less than full
Bits[5:4], TX Empty Trigger (or TET): This is used to select the empty threshold level at which the THRE Interrupts will be generated when the mode is active. It also determines when the dma_tx_req_n signal will be asserted when in certain modes of operation. The following trigger levels are supported: 00 = FIFO empty 01 = 2 characters in the FIFO 10 = FIFO 1/4 full 11 = FIFO 1/2 full
Bit[3], DMA Mode (or DMAM): This determines the DMA signalling mode used for the dma_tx_req_n and dma_rx_req_n output signals. 0 = mode 0 1 = mode 1
Bit[2], XMIT FIFO Reset (or XFIFOR): This resets the control portion of the transmit FIFO and treats the FIFO as empty. Note that this bit is 'self-clearing' and it is not necessary to clear this bit.
Bit[1], RCVR FIFO Reset (or RFIFOR): This resets the control portion of the receive FIFO and treats the FIFO as empty. Note that this bit is 'self-clearing' and it is not necessary to clear this bit.
Bit[0], FIFO Enable (or FIFOE): This enables/disables the transmit (XMIT) and receive (RCVR) FIFO's. Whenever the value of this bit is changed both the XMIT and RCVR controller portion of FIFO's will be reset. </description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART2_IRQ_STATUS_REG</name>
	<description>ISO7816 Interrupt Status Register</description>
	<addressOffset>0x000000ec</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0xffffffff</resetMask>
	<fields><field>
	<name>ISO7816_ERR_TX_VALUE_IRQ</name>
	<description>On read
1: If error signal is enabled and in transmit mode, module generates IRQ when receiver does not receive correctly the character
On Write
1: Clear IRQ</description>
	<bitRange>[2:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>ISO7816_ERR_TX_TIME_IRQ</name>
	<description>On read
1: If error signal is enabled and in transmit mode, module generates IRQ when it checks the error signal
On Write
1: Clear IRQ</description>
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>ISO7816_TIM_EXPIRED_IRQ</name>
	<description>On read
1: When Timer is expired. Timer has to be disabled to clear the IRQ. When sclk is lower than pclk then this bit has to be checked if it's cleared before return form the IRQ Handler</description>
	<bitRange>[0:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>UART2_LCR_EXT</name>
	<description>Line Extended Control Register</description>
	<addressOffset>0x000000cc</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000000f</resetMask>
	<fields><field>
	<name>UART_TRANSMIT_MODE</name>
	<description>Transmit mode control bit. This bit is used to control the type of transmit mode during 9-bit data transfers.
1 = In this mode of operation, Transmit Holding Register (THR) and Shadow Transmit Holding Register (STHR) are 9-bit wide. The user needs to ensure that the THR/STHR register is written correctly for address/data.
Address: 9th bit is set to 1,
Data : 9th bit is set to 0.
Note: Transmit address register (TAR) is not applicable in this mode of operation.
0 = In this mode of operation, Transmit Holding Register (THR) and Shadow Transmit Holding register (STHR) are 8-bit wide. The user needs to program the address into Transmit Address Register (TAR) and data into the THR/STHR register. SEND_ADDR bit is used as a control knob to indicate the uart on when to send the address.</description>
	<bitRange>[3:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>UART_SEND_ADDR</name>
	<description>Send address control bit. This bit is used as a control knob for the user to determine when to send the address during transmit mode.
1 = 9-bit character will be transmitted with 9-th bit set to 1 and the remaining 8-bits will match to what is being programmed in &quot;Transmit Address Register&quot;.
0 = 9-bit character will be transmitted with 9-th bit set to 0 and the remaining 8-bits will be taken from the TXFIFO which is programmed through 8-bit wide THR/STHR register.
Note:
1. This bit is auto-cleared by the hardware, after sending out the address character. User is not expected to program this bit to 0.
2. This field is applicable only when DLS_E bit is set to 1 and TRANSMIT_MODE is set to 0.</description>
	<bitRange>[2:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>UART_ADDR_MATCH</name>
	<description>Address Match Mode.This bit is used to enable the address match feature during receive.
1 = Address match mode; uart will wait until the incoming character with 9-th bit set to 1. And further checks to see if the address matches with what is programmed in &quot;Receive Address Match Register&quot;. If match is found, then sub-sequent characters will be treated as valid data and DW_apb_uart starts receiving data.
0 = Normal mode; DW_apb_uart will start to receive the data and 9-bit character will be formed and written into the receive RXFIFO. User is responsible to read the data and differentiate b/n address and data.
Note: This field is applicable only when DLS_E is set to 1.</description>
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>UART_DLS_E</name>
	<description>Extension for DLS. This bit is used to enable 9-bit data for transmit and receive transfers.</description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART2_LCR_REG</name>
	<description>Line Control Register</description>
	<addressOffset>0x0000000c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0xffffffff</resetMask>
	<fields><field>
	<name>UART_DLAB</name>
	<description>Divisor Latch Access Bit.
This bit is used to enable reading and writing of the Divisor Latch register (DLL and DLH) to set the baud rate of the UART.
This bit must be cleared after initial baud rate setup in order to access other registers. </description>
	<bitRange>[7:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>UART_BC</name>
	<description>Break Control Bit.
This is used to cause a break condition to be transmitted to the receiving device. If set to one the serial output is forced to the spacing (logic 0) state. When not in Loopback Mode, as determined by MCR[4], the sout line is forced low until the Break bit is cleared.</description>
	<bitRange>[6:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>UART_SP</name>
	<description>Stick Parity. (writeable only when UART is not busy USR[0] is 0); otherwise always writable and always readable. This bit is used to force parity value. When PEN, EPS and Stick Parity are set to 1, the parity bit is transmitted and checked as logic 0. If PEN and Stick Parity are set to 1 and EPS is a logic 0, then parity bit is transmitted and checked as a logic 1. If this bit is set to 0, Stick Parity is disabled. </description>
	<bitRange>[5:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>UART_EPS</name>
	<description>Even Parity Select. Writeable only when UART is not busy (USR[0] is zero).
This is used to select between even and odd parity, when parity is enabled (PEN set to one). If set to one, an even number of logic 1s is transmitted or checked. If set to zero, an odd number of logic 1s is transmitted or checked. </description>
	<bitRange>[4:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>UART_PEN</name>
	<description>Parity Enable. Writeable only when UART is not busy (USR[0] is zero)
This bit is used to enable and disable parity generation and detection in transmitted and received serial character respectively.
0 = parity disabled
1 = parity enabled </description>
	<bitRange>[3:3]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>UART_STOP</name>
	<description>Number of stop bits.
This is used to select the number of stop bits per character that the peripheral transmits and receives. If set to zero, one stop bit is transmitted in the serial data.
If set to one and the data bits are set to 5 (LCR[1:0] set to zero) one and a half stop bits is transmitted. Otherwise, two stop bits are transmitted. Note that regardless of the number of stop bits selected, the receiver checks only the first stop bit.
0 = 1 stop bit
1 = 1.5 stop bits when DLS (LCR[1:0]) is zero, else 2 stop bit </description>
	<bitRange>[2:2]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>UART_DLS</name>
	<description>Data Length Select.
This is used to select the number of data bits per character that the peripheral transmits and receives. The number of bit that may be selected areas follows:
00 = 5 bits
01 = 6 bits
10 = 7 bits
11 = 8 bits </description>
	<bitRange>[1:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART2_LSR_REG</name>
	<description>Line Status Register</description>
	<addressOffset>0x00000014</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000060</resetValue>
	<resetMask>0x000001ff</resetMask>
	<fields><field>
	<name>UART_ADDR_RCVD</name>
	<description>Address Received Bit.
If 9Bit data mode (LCR_EXT[0]=1) is enabled, this bit is used to indicate the 9th bit of the receive data is set to 1. This bit can also be used to indicate whether the incoming character is address or data.
1 = Indicates the character is address.
0 = Indicates the character is data.
In the FIFO mode, since the 9th bit is associated with a character received, it is revealed when the character with the 9th bit set to 1 is at the top of the FIFO.
Reading the LSR clears the 9BIT.
Note: User needs to ensure that interrupt gets cleared (reading LSR register) before the next address byte arrives. If there is a delay in clearing the interrupt, then Software will not be able to distinguish between multiple address related interrupt. </description>
	<bitRange>[8:8]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>UART_RFE</name>
	<description>Receiver FIFO Error bit.
This bit is only relevant when FIFOs are enabled (FCR[0] set to one). This is used to indicate if there is at least one parity error, framing error, or break indication in the FIFO.
0 = no error in RX FIFO
1 = error in RX FIFO
This bit is cleared when the LSR is read and the character with the error is at the top of the receiver FIFO and there are no subsequent errors in the FIFO. </description>
	<bitRange>[7:7]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>UART_TEMT</name>
	<description>Transmitter Empty bit.
If FIFOs enabled (FCR[0] set to one), this bit is set whenever the Transmitter Shift Register and the FIFO are both empty. If FIFOs are disabled, this bit is set whenever the Transmitter Holding Register and the Transmitter Shift Register are both empty. </description>
	<bitRange>[6:6]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>UART_THRE</name>
	<description>Transmit Holding Register Empty bit.
If THRE mode is disabled (IER[7] set to zero) and regardless of FIFO's being implemented/enabled or not, this bit indicates that the THR or TX FIFO is empty.
This bit is set whenever data is transferred from the THR or TX FIFO to the transmitter shift register and no new data has been written to the THR or TX FIFO. This also causes a THRE Interrupt to occur, if the THRE Interrupt is enabled. If both modes are active (IER[7] set to one and FCR[0] set to one respectively), the functionality is switched to indicate the transmitter FIFO is full, and no longer controls THRE interrupts, which are then controlled by the FCR[5:4] threshold setting. </description>
	<bitRange>[5:5]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>UART_BI</name>
	<description>Break Interrupt bit.
This is used to indicate the detection of a break sequence on the serial input data.
If in UART mode (SIR_MODE == Disabled), it is set whenever the serial input, sin, is held in a logic '0' state for longer than the sum of start time + data bits + parity + stop bits.
In the FIFO mode, the character associated with the break condition is carried through the FIFO and is revealed when the character is at the top of the FIFO.
Reading the LSR clears the BI bit. In the non-FIFO mode, the BI indication occurs immediately and persists until the LSR is read. </description>
	<bitRange>[4:4]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>UART_FE</name>
	<description>Framing Error bit.
This is used to indicate the occurrence of a framing error in the receiver. A framing error occurs when the receiver does not detect a valid STOP bit in the received data.
In the FIFO mode, since the framing error is associated with a character received, it is revealed when the character with the framing error is at the top of the FIFO.
When a framing error occurs, the UART tries to resynchronize. It does this by assuming that the error was due to the start bit of the next character and then continues receiving the other bit i.e. data, and/or parity and stop. It should be noted that the Framing Error (FE) bit (LSR[3]) is set if a break interrupt has occurred, as indicated by Break Interrupt (BI) bit (LSR[4]).
0 = no framing error
1 = framing error
Reading the LSR clears the FE bit. </description>
	<bitRange>[3:3]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>UART_PE</name>
	<description>Parity Error bit.
This is used to indicate the occurrence of a parity error in the receiver if the Parity Enable (PEN) bit (LCR[3]) is set.
In the FIFO mode, since the parity error is associated with a character received, it is revealed when the character with the parity error arrives at the top of the FIFO.
It should be noted that the Parity Error (PE) bit (LSR[2]) is set if a break interrupt has occurred, as indicated by Break Interrupt (BI) bit (LSR[4]).
0 = no parity error
1 = parity error
Reading the LSR clears the PE bit. </description>
	<bitRange>[2:2]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>UART_OE</name>
	<description>Overrun error bit.
This is used to indicate the occurrence of an overrun error.
This occurs if a new data character was received before the previous data was read.
In the non-FIFO mode, the OE bit is set when a new character arrives in the receiver before the previous character was read from the RBR. When this happens, the data in the RBR is overwritten. In the FIFO mode, an overrun error occurs when the FIFO is full and a new character arrives at the receiver. The data in the FIFO is retained and the data in the receive shift register is lost.
0 = no overrun error
1 = overrun error
Reading the LSR clears the OE bit. </description>
	<bitRange>[1:1]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>UART_DR</name>
	<description>Data Ready bit.
This is used to indicate that the receiver contains at least one character in the RBR or the receiver FIFO.
0 = no data ready
1 = data ready
This bit is cleared when the RBR is read in non-FIFO mode, or when the receiver FIFO is empty, in FIFO mode. </description>
	<bitRange>[0:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>UART2_MCR_REG</name>
	<description>Modem Control Register</description>
	<addressOffset>0x00000010</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0xffffffff</resetMask>
	<fields><field>
	<name>UART_AFCE</name>
	<description>Auto Flow Control Enable.
When FIFOs are enabled and the Auto Flow Control Enable (AFCE) bit is set, Auto Flow Control features are enabled as described in &quot;Auto Flow Control&quot;.
0 = Auto Flow Control Mode disabled
1 = Auto Flow Control Mode enabled </description>
	<bitRange>[5:5]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>UART_LB</name>
	<description>LoopBack Bit.
This is used to put the UART into a diagnostic mode for test purposes.
Data on the sout line is held high, while serial data output is looped back to the sin line, internally. In this mode all the interrupts are fully functional. Also, in loopback mode, the modem control inputs (dsr_n, cts_n, ri_n, dcd_n) are disconnected and the modem control outputs (dtr_n, rts_n) are looped back to the inputs, internally.</description>
	<bitRange>[4:4]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>UART_RTS</name>
	<description>Request to Send.
This is used to directly control the Request to Send (rts_n) output. The Request To Send (rts_n) output is used to inform the modem or data set that the UART is ready to exchange data.
When Auto RTS Flow Control is not enabled (MCR[5] set to zero), the rts_n signal is set low by programming MCR[1] (RTS) to a high.In Auto Flow Control, active (MCR[5] set to one) and FIFOs enable (FCR[0] set to one), the rts_n output is controlled in the same way, but is also gated with the receiver FIFO threshold trigger (rts_n is inactive high when above the threshold). The rts_n signal is de-asserted when MCR[1] is set low.
Note that in Loopback mode (MCR[4] set to one), the rts_n output is held inactive high while the value of this location is internally looped back to an input. </description>
	<bitRange>[1:1]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART2_MSR_REG</name>
	<description>Modem Status Register</description>
	<addressOffset>0x00000018</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000010</resetValue>
	<resetMask>0xffffffff</resetMask>
	<fields><field>
	<name>UART_CTS</name>
	<description>Clear to Send.
This is used to indicate the current state of the modem control line cts_n. This bit is the complement of cts_n. When the Clear to Send input (cts_n) is asserted it is an indication that the modem or data set is ready to exchange data with the UART Ctrl.
0 = cts_n input is de-asserted (logic 1)
1 = cts_n input is asserted (logic 0)
In Loopback Mode (MCR[4] = 1), CTS is the same as MCR[1] (RTS). </description>
	<bitRange>[4:4]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>UART_DCTS</name>
	<description>Delta Clear to Send.
This is used to indicate that the modem control line cts_n has changed since the last time the MSR was read.
0 = no change on cts_n since last read of MSR
1 = change on cts_n since last read of MSR
Reading the MSR clears the DCTS bit. In Loopback Mode (MCR[4] = 1), DCTS reflects changes on MCR[1] (RTS).
Note, if the DCTS bit is not set and the cts_n signal is asserted (low) and a reset occurs (software or otherwise), then the DCTS bit is set when the reset is removed if the cts_n signal remains asserted. </description>
	<bitRange>[0:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>UART2_RAR_REG</name>
	<description>Receive Address Register</description>
	<addressOffset>0x000000c4</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x000000ff</resetMask>
	<fields><field>
	<name>UART_RAR</name>
	<description>This is an address matching register during receive mode. If the 9-th bit is set in the incoming character then the remaining 8-bits will be checked against this register value. If the match happens then sub-sequent characters with 9-th bit set to 0 will be treated as data byte until the next address byte is received.
Note:
- This register is applicable only when 'ADDR_MATCH'(LCR_EXT[1] and 'DLS_E' (LCR_EXT[0]) bits are set to 1.
RAR should be programmed only when UART is not busy.</description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART2_RBR_THR_DLL_REG</name>
	<description>Receive Buffer Register</description>
	<addressOffset>0x00000000</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x000001ff</resetMask>
	<fields><field>
	<name>RBR_THR_9BIT</name>
	<description>When 9BIT_DATA_EN, On read :Receive Buffer bit 8 - On write Transmit Buffer bit 8 when LCR_EXT[3] = 1</description>
	<bitRange>[8:8]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>RBR_THR_DLL</name>
	<description>Receive Buffer Register: (RBR).
This register contains the data byte received on the serial input port (sin) in UART mode or the serial infrared input (sir_in) in infrared mode. The data in this register is valid only if the Data Ready (DR) bit in the Line status Register (LSR) is set. If FIFOs are disabled (FCR[0] set to zero), the data in the RBR must be read before the next data arrives, otherwise it will be overwritten, resulting in an overrun error. If FIFOs are enabled (FCR[0] set to one), this register accesses the head of the receive FIFO. If the receive FIFO is full and this register is not read before the next data character arrives, then the data already in the FIFO will be preserved but any incoming data will be lost. An overrun error will also occur.
Transmit Holding Register: (THR)
This register contains data to be transmitted on the serial output port (sout) in UART mode or the serial infrared output (sir_out_n) in infrared mode. Data should only be written to the THR when the THR Empty (THRE) bit (LSR[5]) is set. If FIFO's are disabled (FCR[0] set to zero) and THRE is set, writing a single character to the THR clears the THRE. Any additional writes to the THR before the THRE is set again causes the THR data to be overwritten. If FIFO's are enabled (FCR[0] set to one) and THRE is set, x number of characters of data may be written to the THR before the FIFO is full. The number x (default=16) is determined by the value of FIFO Depth that you set during configuration. Any attempt to write data when the FIFO is full results in the write data being lost.
Divisor Latch (Low): (DLL)
This register makes up the lower 8-bits of a 16-bit, read/write, Divisor Latch register that contains the baud rate divisor for the UART. This register may only be accessed when the DLAB bit (LCR[7]) is set. The output baud rate is equal to the serial clock (sclk) frequency divided by sixteen times the value of the baud rate divisor, as follows:
baud rate = (serial clock freq) / (16 * divisor)
Note that with the Divisor Latch Registers (DLL and DLH) set to zero, the baud clock is disabled and no serial communications will occur. Also, once the DLL is set, at least 8 clock cycles of the slowest DW_apb_uart clock should be allowed to pass before transmitting or receiving data.
Divisor Latch (High): (DLH) (Note: This register is placed in UART_IER_DLH_REG with offset 0x4)
Upper 8-bits of a 16-bit, read/write, Divisor Latch register that contains the baud rate divisor for the UART. This register may be accessed only when the DLAB bit (LCR[7]) is set. The output baud rate is equal to the serial clock frequency divided by sixteen times the value of the baud rate divisor, as follows:
baud rate = (serial clock freq)/(16 * divisor).
Note that with the Divisor Latch Registers (DLL and DLH) set to zero, the baud clock is disabled and no serial communications occur. Also, once the DLH is set, at least 8 clock cycles of the slowest DW_apb_uart clock should be allowed to pass before transmitting or receiving data.</description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART2_RFL_REG</name>
	<description>Receive FIFO Level.</description>
	<addressOffset>0x00000084</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000001f</resetMask>
	<fields><field>
	<name>UART_RECEIVE_FIFO_LEVEL</name>
	<description>Receive FIFO Level.
This is indicates the number of data entries in the receive FIFO. </description>
	<bitRange>[4:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>UART2_SBCR_REG</name>
	<description>Shadow Break Control Register</description>
	<addressOffset>0x00000090</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0xffffffff</resetMask>
	<fields><field>
	<name>UART_SHADOW_BREAK_CONTROL</name>
	<description>Shadow Break Control Bit.
This is a shadow register for the Break bit (LCR[6]), this can be used to remove the burden of having to performing a read modify write on the LCR. This is used to cause a break condition to be transmitted to the receiving device.
If set to one the serial output is forced to the spacing (logic 0) state. When not in Loopback Mode, as determined by MCR[4], the sout line is forced low until the Break bit is cleared.</description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART2_SDMAM_REG</name>
	<description>Shadow DMA Mode</description>
	<addressOffset>0x00000094</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0xffffffff</resetMask>
	<fields><field>
	<name>UART_SHADOW_DMA_MODE</name>
	<description>Shadow DMA Mode.
This is a shadow register for the DMA mode bit (FCR[3]). This can be used to remove the burden of having to store the previously written value to the FCR in memory and having to mask this value so that only the DMA Mode bit gets updated. This determines the DMA signalling mode used for the dma_tx_req_n and dma_rx_req_n output signals.
0 = mode 0
1 = mode 1 </description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART2_SFE_REG</name>
	<description>Shadow FIFO Enable</description>
	<addressOffset>0x00000098</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0xffffffff</resetMask>
	<fields><field>
	<name>UART_SHADOW_FIFO_ENABLE</name>
	<description>Shadow FIFO Enable.
This is a shadow register for the FIFO enable bit (FCR[0]). This can be used to remove the burden of having to store the previously written value to the FCR in memory and having to mask this value so that only the FIFO enable bit gets updated.This enables/disables the transmit (XMIT) and receive (RCVR) FIFOs. If this bit is set to zero (disabled) after being enabled then both the XMIT and RCVR controller portion of FIFOs are reset. </description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART2_SRBR_STHR0_REG</name>
	<description>Shadow Receive/Transmit Buffer Register</description>
	<addressOffset>0x00000030</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0xffffffff</resetMask>
	<fields><field>
	<name>SRBR_STHRx</name>
	<description>Shadow Receive Buffer Register x: This is a shadow register for the RBR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains the data byte received on the serial input port (sin) in UART mode or the serial infrared input (sir_in) in infrared mode. The data in this register is valid only if the Data Ready (DR) bit in the Line status Register (LSR) is set. If FIFOs are disabled (FCR[0] set to zero), the data in the RBR must be read before the next data arrives, otherwise it will be overwritten, resulting in an overrun error. If FIFOs are enabled (FCR[0] set to one), this register accesses the head of the receive FIFO. If the receive FIFO is full and this register is not read before the next data character arrives, then the data already in the FIFO will be preserved but any incoming data will be lost. An overrun error will also occur. Shadow Transmit Holding Register 0: This is a shadow register for the THR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains data to be transmitted on the serial output port (sout) in UART mode or the serial infrared output (sir_out_n) in infrared mode. Data should only be written to the THR when the THR Empty (THRE) bit (LSR[5]) is set. If FIFO's are disabled (FCR[0] set to zero) and THRE is set, writing a single character to the THR clears the THRE. Any additional writes to the THR before the THRE is set again causes the THR data to be overwritten. If FIFO's are enabled (FCR[0] set to one) and THRE is set, x number of characters of data may be written to the THR before the FIFO is full. The number x (default=16) is determined by the value of FIFO Depth that you set during configuration. Any attempt to write data when the FIFO is full results in the write data being lost. </description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART2_SRBR_STHR10_REG</name>
	<description>Shadow Receive/Transmit Buffer Register</description>
	<addressOffset>0x00000058</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0xffffffff</resetMask>
	<fields><field>
	<name>SRBR_STHRx</name>
	<description>Shadow Receive Buffer Register x: This is a shadow register for the RBR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains the data byte received on the serial input port (sin) in UART mode or the serial infrared input (sir_in) in infrared mode. The data in this register is valid only if the Data Ready (DR) bit in the Line status Register (LSR) is set. If FIFOs are disabled (FCR[0] set to zero), the data in the RBR must be read before the next data arrives, otherwise it will be overwritten, resulting in an overrun error. If FIFOs are enabled (FCR[0] set to one), this register accesses the head of the receive FIFO. If the receive FIFO is full and this register is not read before the next data character arrives, then the data already in the FIFO will be preserved but any incoming data will be lost. An overrun error will also occur. Shadow Transmit Holding Register 0: This is a shadow register for the THR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains data to be transmitted on the serial output port (sout) in UART mode or the serial infrared output (sir_out_n) in infrared mode. Data should only be written to the THR when the THR Empty (THRE) bit (LSR[5]) is set. If FIFO's are disabled (FCR[0] set to zero) and THRE is set, writing a single character to the THR clears the THRE. Any additional writes to the THR before the THRE is set again causes the THR data to be overwritten. If FIFO's are enabled (FCR[0] set to one) and THRE is set, x number of characters of data may be written to the THR before the FIFO is full. The number x (default=16) is determined by the value of FIFO Depth that you set during configuration. Any attempt to write data when the FIFO is full results in the write data being lost. </description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART2_SRBR_STHR11_REG</name>
	<description>Shadow Receive/Transmit Buffer Register</description>
	<addressOffset>0x0000005c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0xffffffff</resetMask>
	<fields><field>
	<name>SRBR_STHRx</name>
	<description>Shadow Receive Buffer Register x: This is a shadow register for the RBR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains the data byte received on the serial input port (sin) in UART mode or the serial infrared input (sir_in) in infrared mode. The data in this register is valid only if the Data Ready (DR) bit in the Line status Register (LSR) is set. If FIFOs are disabled (FCR[0] set to zero), the data in the RBR must be read before the next data arrives, otherwise it will be overwritten, resulting in an overrun error. If FIFOs are enabled (FCR[0] set to one), this register accesses the head of the receive FIFO. If the receive FIFO is full and this register is not read before the next data character arrives, then the data already in the FIFO will be preserved but any incoming data will be lost. An overrun error will also occur. Shadow Transmit Holding Register 0: This is a shadow register for the THR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains data to be transmitted on the serial output port (sout) in UART mode or the serial infrared output (sir_out_n) in infrared mode. Data should only be written to the THR when the THR Empty (THRE) bit (LSR[5]) is set. If FIFO's are disabled (FCR[0] set to zero) and THRE is set, writing a single character to the THR clears the THRE. Any additional writes to the THR before the THRE is set again causes the THR data to be overwritten. If FIFO's are enabled (FCR[0] set to one) and THRE is set, x number of characters of data may be written to the THR before the FIFO is full. The number x (default=16) is determined by the value of FIFO Depth that you set during configuration. Any attempt to write data when the FIFO is full results in the write data being lost. </description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART2_SRBR_STHR12_REG</name>
	<description>Shadow Receive/Transmit Buffer Register</description>
	<addressOffset>0x00000060</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0xffffffff</resetMask>
	<fields><field>
	<name>SRBR_STHRx</name>
	<description>Shadow Receive Buffer Register x: This is a shadow register for the RBR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains the data byte received on the serial input port (sin) in UART mode or the serial infrared input (sir_in) in infrared mode. The data in this register is valid only if the Data Ready (DR) bit in the Line status Register (LSR) is set. If FIFOs are disabled (FCR[0] set to zero), the data in the RBR must be read before the next data arrives, otherwise it will be overwritten, resulting in an overrun error. If FIFOs are enabled (FCR[0] set to one), this register accesses the head of the receive FIFO. If the receive FIFO is full and this register is not read before the next data character arrives, then the data already in the FIFO will be preserved but any incoming data will be lost. An overrun error will also occur. Shadow Transmit Holding Register 0: This is a shadow register for the THR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains data to be transmitted on the serial output port (sout) in UART mode or the serial infrared output (sir_out_n) in infrared mode. Data should only be written to the THR when the THR Empty (THRE) bit (LSR[5]) is set. If FIFO's are disabled (FCR[0] set to zero) and THRE is set, writing a single character to the THR clears the THRE. Any additional writes to the THR before the THRE is set again causes the THR data to be overwritten. If FIFO's are enabled (FCR[0] set to one) and THRE is set, x number of characters of data may be written to the THR before the FIFO is full. The number x (default=16) is determined by the value of FIFO Depth that you set during configuration. Any attempt to write data when the FIFO is full results in the write data being lost. </description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART2_SRBR_STHR13_REG</name>
	<description>Shadow Receive/Transmit Buffer Register</description>
	<addressOffset>0x00000064</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0xffffffff</resetMask>
	<fields><field>
	<name>SRBR_STHRx</name>
	<description>Shadow Receive Buffer Register x: This is a shadow register for the RBR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains the data byte received on the serial input port (sin) in UART mode or the serial infrared input (sir_in) in infrared mode. The data in this register is valid only if the Data Ready (DR) bit in the Line status Register (LSR) is set. If FIFOs are disabled (FCR[0] set to zero), the data in the RBR must be read before the next data arrives, otherwise it will be overwritten, resulting in an overrun error. If FIFOs are enabled (FCR[0] set to one), this register accesses the head of the receive FIFO. If the receive FIFO is full and this register is not read before the next data character arrives, then the data already in the FIFO will be preserved but any incoming data will be lost. An overrun error will also occur. Shadow Transmit Holding Register 0: This is a shadow register for the THR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains data to be transmitted on the serial output port (sout) in UART mode or the serial infrared output (sir_out_n) in infrared mode. Data should only be written to the THR when the THR Empty (THRE) bit (LSR[5]) is set. If FIFO's are disabled (FCR[0] set to zero) and THRE is set, writing a single character to the THR clears the THRE. Any additional writes to the THR before the THRE is set again causes the THR data to be overwritten. If FIFO's are enabled (FCR[0] set to one) and THRE is set, x number of characters of data may be written to the THR before the FIFO is full. The number x (default=16) is determined by the value of FIFO Depth that you set during configuration. Any attempt to write data when the FIFO is full results in the write data being lost. </description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART2_SRBR_STHR14_REG</name>
	<description>Shadow Receive/Transmit Buffer Register</description>
	<addressOffset>0x00000068</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0xffffffff</resetMask>
	<fields><field>
	<name>SRBR_STHRx</name>
	<description>Shadow Receive Buffer Register x: This is a shadow register for the RBR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains the data byte received on the serial input port (sin) in UART mode or the serial infrared input (sir_in) in infrared mode. The data in this register is valid only if the Data Ready (DR) bit in the Line status Register (LSR) is set. If FIFOs are disabled (FCR[0] set to zero), the data in the RBR must be read before the next data arrives, otherwise it will be overwritten, resulting in an overrun error. If FIFOs are enabled (FCR[0] set to one), this register accesses the head of the receive FIFO. If the receive FIFO is full and this register is not read before the next data character arrives, then the data already in the FIFO will be preserved but any incoming data will be lost. An overrun error will also occur. Shadow Transmit Holding Register 0: This is a shadow register for the THR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains data to be transmitted on the serial output port (sout) in UART mode or the serial infrared output (sir_out_n) in infrared mode. Data should only be written to the THR when the THR Empty (THRE) bit (LSR[5]) is set. If FIFO's are disabled (FCR[0] set to zero) and THRE is set, writing a single character to the THR clears the THRE. Any additional writes to the THR before the THRE is set again causes the THR data to be overwritten. If FIFO's are enabled (FCR[0] set to one) and THRE is set, x number of characters of data may be written to the THR before the FIFO is full. The number x (default=16) is determined by the value of FIFO Depth that you set during configuration. Any attempt to write data when the FIFO is full results in the write data being lost. </description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART2_SRBR_STHR15_REG</name>
	<description>Shadow Receive/Transmit Buffer Register</description>
	<addressOffset>0x0000006c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0xffffffff</resetMask>
	<fields><field>
	<name>SRBR_STHRx</name>
	<description>Shadow Receive Buffer Register x: This is a shadow register for the RBR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains the data byte received on the serial input port (sin) in UART mode or the serial infrared input (sir_in) in infrared mode. The data in this register is valid only if the Data Ready (DR) bit in the Line status Register (LSR) is set. If FIFOs are disabled (FCR[0] set to zero), the data in the RBR must be read before the next data arrives, otherwise it will be overwritten, resulting in an overrun error. If FIFOs are enabled (FCR[0] set to one), this register accesses the head of the receive FIFO. If the receive FIFO is full and this register is not read before the next data character arrives, then the data already in the FIFO will be preserved but any incoming data will be lost. An overrun error will also occur. Shadow Transmit Holding Register 0: This is a shadow register for the THR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains data to be transmitted on the serial output port (sout) in UART mode or the serial infrared output (sir_out_n) in infrared mode. Data should only be written to the THR when the THR Empty (THRE) bit (LSR[5]) is set. If FIFO's are disabled (FCR[0] set to zero) and THRE is set, writing a single character to the THR clears the THRE. Any additional writes to the THR before the THRE is set again causes the THR data to be overwritten. If FIFO's are enabled (FCR[0] set to one) and THRE is set, x number of characters of data may be written to the THR before the FIFO is full. The number x (default=16) is determined by the value of FIFO Depth that you set during configuration. Any attempt to write data when the FIFO is full results in the write data being lost. </description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART2_SRBR_STHR1_REG</name>
	<description>Shadow Receive/Transmit Buffer Register</description>
	<addressOffset>0x00000034</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0xffffffff</resetMask>
	<fields><field>
	<name>SRBR_STHRx</name>
	<description>Shadow Receive Buffer Register x: This is a shadow register for the RBR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains the data byte received on the serial input port (sin) in UART mode or the serial infrared input (sir_in) in infrared mode. The data in this register is valid only if the Data Ready (DR) bit in the Line status Register (LSR) is set. If FIFOs are disabled (FCR[0] set to zero), the data in the RBR must be read before the next data arrives, otherwise it will be overwritten, resulting in an overrun error. If FIFOs are enabled (FCR[0] set to one), this register accesses the head of the receive FIFO. If the receive FIFO is full and this register is not read before the next data character arrives, then the data already in the FIFO will be preserved but any incoming data will be lost. An overrun error will also occur. Shadow Transmit Holding Register 0: This is a shadow register for the THR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains data to be transmitted on the serial output port (sout) in UART mode or the serial infrared output (sir_out_n) in infrared mode. Data should only be written to the THR when the THR Empty (THRE) bit (LSR[5]) is set. If FIFO's are disabled (FCR[0] set to zero) and THRE is set, writing a single character to the THR clears the THRE. Any additional writes to the THR before the THRE is set again causes the THR data to be overwritten. If FIFO's are enabled (FCR[0] set to one) and THRE is set, x number of characters of data may be written to the THR before the FIFO is full. The number x (default=16) is determined by the value of FIFO Depth that you set during configuration. Any attempt to write data when the FIFO is full results in the write data being lost. </description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART2_SRBR_STHR2_REG</name>
	<description>Shadow Receive/Transmit Buffer Register</description>
	<addressOffset>0x00000038</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0xffffffff</resetMask>
	<fields><field>
	<name>SRBR_STHRx</name>
	<description>Shadow Receive Buffer Register x: This is a shadow register for the RBR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains the data byte received on the serial input port (sin) in UART mode or the serial infrared input (sir_in) in infrared mode. The data in this register is valid only if the Data Ready (DR) bit in the Line status Register (LSR) is set. If FIFOs are disabled (FCR[0] set to zero), the data in the RBR must be read before the next data arrives, otherwise it will be overwritten, resulting in an overrun error. If FIFOs are enabled (FCR[0] set to one), this register accesses the head of the receive FIFO. If the receive FIFO is full and this register is not read before the next data character arrives, then the data already in the FIFO will be preserved but any incoming data will be lost. An overrun error will also occur. Shadow Transmit Holding Register 0: This is a shadow register for the THR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains data to be transmitted on the serial output port (sout) in UART mode or the serial infrared output (sir_out_n) in infrared mode. Data should only be written to the THR when the THR Empty (THRE) bit (LSR[5]) is set. If FIFO's are disabled (FCR[0] set to zero) and THRE is set, writing a single character to the THR clears the THRE. Any additional writes to the THR before the THRE is set again causes the THR data to be overwritten. If FIFO's are enabled (FCR[0] set to one) and THRE is set, x number of characters of data may be written to the THR before the FIFO is full. The number x (default=16) is determined by the value of FIFO Depth that you set during configuration. Any attempt to write data when the FIFO is full results in the write data being lost. </description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART2_SRBR_STHR3_REG</name>
	<description>Shadow Receive/Transmit Buffer Register</description>
	<addressOffset>0x0000003c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0xffffffff</resetMask>
	<fields><field>
	<name>SRBR_STHRx</name>
	<description>Shadow Receive Buffer Register x: This is a shadow register for the RBR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains the data byte received on the serial input port (sin) in UART mode or the serial infrared input (sir_in) in infrared mode. The data in this register is valid only if the Data Ready (DR) bit in the Line status Register (LSR) is set. If FIFOs are disabled (FCR[0] set to zero), the data in the RBR must be read before the next data arrives, otherwise it will be overwritten, resulting in an overrun error. If FIFOs are enabled (FCR[0] set to one), this register accesses the head of the receive FIFO. If the receive FIFO is full and this register is not read before the next data character arrives, then the data already in the FIFO will be preserved but any incoming data will be lost. An overrun error will also occur. Shadow Transmit Holding Register 0: This is a shadow register for the THR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains data to be transmitted on the serial output port (sout) in UART mode or the serial infrared output (sir_out_n) in infrared mode. Data should only be written to the THR when the THR Empty (THRE) bit (LSR[5]) is set. If FIFO's are disabled (FCR[0] set to zero) and THRE is set, writing a single character to the THR clears the THRE. Any additional writes to the THR before the THRE is set again causes the THR data to be overwritten. If FIFO's are enabled (FCR[0] set to one) and THRE is set, x number of characters of data may be written to the THR before the FIFO is full. The number x (default=16) is determined by the value of FIFO Depth that you set during configuration. Any attempt to write data when the FIFO is full results in the write data being lost. </description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART2_SRBR_STHR4_REG</name>
	<description>Shadow Receive/Transmit Buffer Register</description>
	<addressOffset>0x00000040</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0xffffffff</resetMask>
	<fields><field>
	<name>SRBR_STHRx</name>
	<description>Shadow Receive Buffer Register x: This is a shadow register for the RBR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains the data byte received on the serial input port (sin) in UART mode or the serial infrared input (sir_in) in infrared mode. The data in this register is valid only if the Data Ready (DR) bit in the Line status Register (LSR) is set. If FIFOs are disabled (FCR[0] set to zero), the data in the RBR must be read before the next data arrives, otherwise it will be overwritten, resulting in an overrun error. If FIFOs are enabled (FCR[0] set to one), this register accesses the head of the receive FIFO. If the receive FIFO is full and this register is not read before the next data character arrives, then the data already in the FIFO will be preserved but any incoming data will be lost. An overrun error will also occur. Shadow Transmit Holding Register 0: This is a shadow register for the THR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains data to be transmitted on the serial output port (sout) in UART mode or the serial infrared output (sir_out_n) in infrared mode. Data should only be written to the THR when the THR Empty (THRE) bit (LSR[5]) is set. If FIFO's are disabled (FCR[0] set to zero) and THRE is set, writing a single character to the THR clears the THRE. Any additional writes to the THR before the THRE is set again causes the THR data to be overwritten. If FIFO's are enabled (FCR[0] set to one) and THRE is set, x number of characters of data may be written to the THR before the FIFO is full. The number x (default=16) is determined by the value of FIFO Depth that you set during configuration. Any attempt to write data when the FIFO is full results in the write data being lost. </description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART2_SRBR_STHR5_REG</name>
	<description>Shadow Receive/Transmit Buffer Register</description>
	<addressOffset>0x00000044</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0xffffffff</resetMask>
	<fields><field>
	<name>SRBR_STHRx</name>
	<description>Shadow Receive Buffer Register x: This is a shadow register for the RBR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains the data byte received on the serial input port (sin) in UART mode or the serial infrared input (sir_in) in infrared mode. The data in this register is valid only if the Data Ready (DR) bit in the Line status Register (LSR) is set. If FIFOs are disabled (FCR[0] set to zero), the data in the RBR must be read before the next data arrives, otherwise it will be overwritten, resulting in an overrun error. If FIFOs are enabled (FCR[0] set to one), this register accesses the head of the receive FIFO. If the receive FIFO is full and this register is not read before the next data character arrives, then the data already in the FIFO will be preserved but any incoming data will be lost. An overrun error will also occur. Shadow Transmit Holding Register 0: This is a shadow register for the THR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains data to be transmitted on the serial output port (sout) in UART mode or the serial infrared output (sir_out_n) in infrared mode. Data should only be written to the THR when the THR Empty (THRE) bit (LSR[5]) is set. If FIFO's are disabled (FCR[0] set to zero) and THRE is set, writing a single character to the THR clears the THRE. Any additional writes to the THR before the THRE is set again causes the THR data to be overwritten. If FIFO's are enabled (FCR[0] set to one) and THRE is set, x number of characters of data may be written to the THR before the FIFO is full. The number x (default=16) is determined by the value of FIFO Depth that you set during configuration. Any attempt to write data when the FIFO is full results in the write data being lost. </description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART2_SRBR_STHR6_REG</name>
	<description>Shadow Receive/Transmit Buffer Register</description>
	<addressOffset>0x00000048</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0xffffffff</resetMask>
	<fields><field>
	<name>SRBR_STHRx</name>
	<description>Shadow Receive Buffer Register x: This is a shadow register for the RBR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains the data byte received on the serial input port (sin) in UART mode or the serial infrared input (sir_in) in infrared mode. The data in this register is valid only if the Data Ready (DR) bit in the Line status Register (LSR) is set. If FIFOs are disabled (FCR[0] set to zero), the data in the RBR must be read before the next data arrives, otherwise it will be overwritten, resulting in an overrun error. If FIFOs are enabled (FCR[0] set to one), this register accesses the head of the receive FIFO. If the receive FIFO is full and this register is not read before the next data character arrives, then the data already in the FIFO will be preserved but any incoming data will be lost. An overrun error will also occur. Shadow Transmit Holding Register 0: This is a shadow register for the THR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains data to be transmitted on the serial output port (sout) in UART mode or the serial infrared output (sir_out_n) in infrared mode. Data should only be written to the THR when the THR Empty (THRE) bit (LSR[5]) is set. If FIFO's are disabled (FCR[0] set to zero) and THRE is set, writing a single character to the THR clears the THRE. Any additional writes to the THR before the THRE is set again causes the THR data to be overwritten. If FIFO's are enabled (FCR[0] set to one) and THRE is set, x number of characters of data may be written to the THR before the FIFO is full. The number x (default=16) is determined by the value of FIFO Depth that you set during configuration. Any attempt to write data when the FIFO is full results in the write data being lost. </description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART2_SRBR_STHR7_REG</name>
	<description>Shadow Receive/Transmit Buffer Register</description>
	<addressOffset>0x0000004c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0xffffffff</resetMask>
	<fields><field>
	<name>SRBR_STHRx</name>
	<description>Shadow Receive Buffer Register x: This is a shadow register for the RBR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains the data byte received on the serial input port (sin) in UART mode or the serial infrared input (sir_in) in infrared mode. The data in this register is valid only if the Data Ready (DR) bit in the Line status Register (LSR) is set. If FIFOs are disabled (FCR[0] set to zero), the data in the RBR must be read before the next data arrives, otherwise it will be overwritten, resulting in an overrun error. If FIFOs are enabled (FCR[0] set to one), this register accesses the head of the receive FIFO. If the receive FIFO is full and this register is not read before the next data character arrives, then the data already in the FIFO will be preserved but any incoming data will be lost. An overrun error will also occur. Shadow Transmit Holding Register 0: This is a shadow register for the THR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains data to be transmitted on the serial output port (sout) in UART mode or the serial infrared output (sir_out_n) in infrared mode. Data should only be written to the THR when the THR Empty (THRE) bit (LSR[5]) is set. If FIFO's are disabled (FCR[0] set to zero) and THRE is set, writing a single character to the THR clears the THRE. Any additional writes to the THR before the THRE is set again causes the THR data to be overwritten. If FIFO's are enabled (FCR[0] set to one) and THRE is set, x number of characters of data may be written to the THR before the FIFO is full. The number x (default=16) is determined by the value of FIFO Depth that you set during configuration. Any attempt to write data when the FIFO is full results in the write data being lost. </description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART2_SRBR_STHR8_REG</name>
	<description>Shadow Receive/Transmit Buffer Register</description>
	<addressOffset>0x00000050</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0xffffffff</resetMask>
	<fields><field>
	<name>SRBR_STHRx</name>
	<description>Shadow Receive Buffer Register x: This is a shadow register for the RBR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains the data byte received on the serial input port (sin) in UART mode or the serial infrared input (sir_in) in infrared mode. The data in this register is valid only if the Data Ready (DR) bit in the Line status Register (LSR) is set. If FIFOs are disabled (FCR[0] set to zero), the data in the RBR must be read before the next data arrives, otherwise it will be overwritten, resulting in an overrun error. If FIFOs are enabled (FCR[0] set to one), this register accesses the head of the receive FIFO. If the receive FIFO is full and this register is not read before the next data character arrives, then the data already in the FIFO will be preserved but any incoming data will be lost. An overrun error will also occur. Shadow Transmit Holding Register 0: This is a shadow register for the THR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains data to be transmitted on the serial output port (sout) in UART mode or the serial infrared output (sir_out_n) in infrared mode. Data should only be written to the THR when the THR Empty (THRE) bit (LSR[5]) is set. If FIFO's are disabled (FCR[0] set to zero) and THRE is set, writing a single character to the THR clears the THRE. Any additional writes to the THR before the THRE is set again causes the THR data to be overwritten. If FIFO's are enabled (FCR[0] set to one) and THRE is set, x number of characters of data may be written to the THR before the FIFO is full. The number x (default=16) is determined by the value of FIFO Depth that you set during configuration. Any attempt to write data when the FIFO is full results in the write data being lost. </description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART2_SRBR_STHR9_REG</name>
	<description>Shadow Receive/Transmit Buffer Register</description>
	<addressOffset>0x00000054</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0xffffffff</resetMask>
	<fields><field>
	<name>SRBR_STHRx</name>
	<description>Shadow Receive Buffer Register x: This is a shadow register for the RBR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains the data byte received on the serial input port (sin) in UART mode or the serial infrared input (sir_in) in infrared mode. The data in this register is valid only if the Data Ready (DR) bit in the Line status Register (LSR) is set. If FIFOs are disabled (FCR[0] set to zero), the data in the RBR must be read before the next data arrives, otherwise it will be overwritten, resulting in an overrun error. If FIFOs are enabled (FCR[0] set to one), this register accesses the head of the receive FIFO. If the receive FIFO is full and this register is not read before the next data character arrives, then the data already in the FIFO will be preserved but any incoming data will be lost. An overrun error will also occur. Shadow Transmit Holding Register 0: This is a shadow register for the THR and has been allocated sixteen 32-bit locations so as to accommodate burst accesses from the master. This register contains data to be transmitted on the serial output port (sout) in UART mode or the serial infrared output (sir_out_n) in infrared mode. Data should only be written to the THR when the THR Empty (THRE) bit (LSR[5]) is set. If FIFO's are disabled (FCR[0] set to zero) and THRE is set, writing a single character to the THR clears the THRE. Any additional writes to the THR before the THRE is set again causes the THR data to be overwritten. If FIFO's are enabled (FCR[0] set to one) and THRE is set, x number of characters of data may be written to the THR before the FIFO is full. The number x (default=16) is determined by the value of FIFO Depth that you set during configuration. Any attempt to write data when the FIFO is full results in the write data being lost. </description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART2_SRR_REG</name>
	<description>Software Reset Register.</description>
	<addressOffset>0x00000088</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0xffffffff</resetMask>
	<fields><field>
	<name>UART_XFR</name>
	<description>XMIT FIFO Reset.
This is a shadow register for the XMIT FIFO Reset bit (FCR[2]). This can be used to remove the burden on software having to store previously written FCR values (which are pretty static) just to reset the transmit FIFO. This resets the control portion of the transmit FIFO and treats the FIFO as empty. Note that this bit is 'self-clearing'. It is not necessary to clear this bit. </description>
	<bitRange>[2:2]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>UART_RFR</name>
	<description>RCVR FIFO Reset.
This is a shadow register for the RCVR FIFO Reset bit (FCR[1]). This can be used to remove the burden on software having to store previously written FCR values (which are pretty static) just to reset the receive FIFO This resets the control portion of the receive FIFO and treats the FIFO as empty.
Note that this bit is 'self-clearing'. It is not necessary to clear this bit. </description>
	<bitRange>[1:1]</bitRange>
	<access>write-only</access>
	</field><field>
	<name>UART_UR</name>
	<description>UART Reset. This asynchronously resets the UART Ctrl and synchronously removes the reset assertion. For a two clock implementation both pclk and sclk domains are reset. </description>
	<bitRange>[0:0]</bitRange>
	<access>write-only</access>
	</field></fields>
</register><register>
	<name>UART2_SRTS_REG</name>
	<description>Shadow Request to Send</description>
	<addressOffset>0x0000008c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0xffffffff</resetMask>
	<fields><field>
	<name>UART_SHADOW_REQUEST_TO_SEND</name>
	<description>Shadow Request to Send.
This is a shadow register for the RTS bit (MCR[1]), this can be used to remove the burden of having to
performing a read-modify-write on the MCR. This is used to directly control the Request to Send (rts_n) output. The Request To Send (rts_n) output is used to inform the modem or data set that the UART Ctrl is ready to exchange data.
When Auto RTS Flow Control is not enabled (MCR[5] = 0), the rts_n signal is set low by programming MCR[1] (RTS) to a high.
In Auto Flow Control, (active MCR[5] = 1) and FIFOs enable (FCR[0] = 1), the rts_n output is controlled in the same way, but is also gated with the receiver FIFO threshold trigger (rts_n is inactive high when above the threshold).
Note that in Loopback mode (MCR[4] = 1), the rts_n output is held inactive-high while the value of this location is internally looped back to an input. </description>
	<bitRange>[0:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART2_SRT_REG</name>
	<description>Shadow RCVR Trigger</description>
	<addressOffset>0x0000009c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0xffffffff</resetMask>
	<fields><field>
	<name>UART_SHADOW_RCVR_TRIGGER</name>
	<description>Shadow RCVR Trigger.
This is a shadow register for the RCVR trigger bits (FCR[7:6]). This can be used to remove the burden of having to store the previously written value to the FCR in memory and having to mask this value so that only the RCVR trigger bit gets updated.
This is used to select the trigger level in the receiver FIFO at which the Received Data Available Interrupt is generated. It also determines when the dma_rx_req_n signal is asserted when DMA Mode (FCR[3]) = 1. The following trigger levels are supported:
00 = 1 character in the FIFO
01 = FIFO &#188; full
10 = FIFO &#189; full
11 = FIFO 2 less than full </description>
	<bitRange>[1:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART2_STET_REG</name>
	<description>Shadow TX Empty Trigger</description>
	<addressOffset>0x000000a0</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0xffffffff</resetMask>
	<fields><field>
	<name>UART_SHADOW_TX_EMPTY_TRIGGER</name>
	<description>Shadow TX Empty Trigger.
This is a shadow register for the TX empty trigger bits (FCR[5:4]). This can be used to remove the burden of having to store the previously written value to the FCR in memory and having to mask this value so that only the TX empty trigger bit gets updated.
This is used to select the empty threshold level at which the THRE Interrupts are generated when the mode is active. The following trigger levels are supported:
00 = FIFO empty
01 = 2 characters in the FIFO
10 = FIFO &#188; full
11 = FIFO &#189; full </description>
	<bitRange>[1:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART2_TAR_REG</name>
	<description>Transmit Address Register</description>
	<addressOffset>0x000000c8</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x000000ff</resetMask>
	<fields><field>
	<name>UART_TAR</name>
	<description>This is an address matching register during transmit mode. If DLS_E (LCR_EXT[0]) bit is enabled, then uart will send the 9-bit character with 9-th bit set to 1 and remaining 8-bit address will be sent from this register provided 'SEND_ADDR' (LCR_EXT[2]) bit is set to 1.
Note:
- This register is used only to send the address. The normal data should be sent by programming THR register.
- Once the address is started to send on the DW_apb_uart serial lane, then 'SEND_ADDR' bit will be auto-cleared by the hardware.</description>
	<bitRange>[7:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART2_TFL_REG</name>
	<description>Transmit FIFO Level</description>
	<addressOffset>0x00000080</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000001f</resetMask>
	<fields><field>
	<name>UART_TRANSMIT_FIFO_LEVEL</name>
	<description>Transmit FIFO Level.
This is indicates the number of data entries in the transmit FIFO. </description>
	<bitRange>[4:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>UART2_TIMER_REG</name>
	<description>ISO7816 Timer Register</description>
	<addressOffset>0x000000e4</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0xffffffff</resetMask>
	<fields><field>
	<name>ISO7816_TIM_MODE</name>
	<description>0: Timer will count up to max value then stops. Timer has to be disabled and enabled again to restart. Timer is clocked with the ISO7816 clock
1: Timer will count guard time. ISO7816_TIM_MAX has to be 16*GuardTime-1</description>
	<bitRange>[17:17]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>ISO7816_TIM_EN</name>
	<description>0: Timer is disabled
1: Timer is enabled</description>
	<bitRange>[16:16]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>ISO7816_TIM_MAX</name>
	<description>On write: timer will count from 0 to ISO7816_TIM_MAX
On read: gives the current timer value</description>
	<bitRange>[15:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>UART2_UCV_REG</name>
	<description>Component Version</description>
	<addressOffset>0x000000f8</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x3430312a</resetValue>
	<resetMask>0xffffffff</resetMask>
	<fields><field>
	<name>UART_UCV</name>
	<description>Component Version </description>
	<bitRange>[31:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>UART2_USR_REG</name>
	<description>UART Status register.</description>
	<addressOffset>0x0000007c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000006</resetValue>
	<resetMask>0xffffffff</resetMask>
	<fields><field>
	<name>UART_RFF</name>
	<description>Receive FIFO Full.
This is used to indicate that the receive FIFO is completely full.
0 = Receive FIFO not full
1 = Receive FIFO Full
This bit is cleared when the RX FIFO is no longer full. </description>
	<bitRange>[4:4]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>UART_RFNE</name>
	<description>Receive FIFO Not Empty.
This is used to indicate that the receive FIFO contains one or more entries.
0 = Receive FIFO is empty
1 = Receive FIFO is not empty
This bit is cleared when the RX FIFO is empty. </description>
	<bitRange>[3:3]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>UART_TFE</name>
	<description>Transmit FIFO Empty.
This is used to indicate that the transmit FIFO is completely empty.
0 = Transmit FIFO is not empty
1 = Transmit FIFO is empty
This bit is cleared when the TX FIFO is no longer empty. </description>
	<bitRange>[2:2]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>UART_TFNF</name>
	<description>Transmit FIFO Not Full.
This is used to indicate that the transmit FIFO in not full.
0 = Transmit FIFO is full
1 = Transmit FIFO is not full
This bit is cleared when the TX FIFO is full. </description>
	<bitRange>[1:1]</bitRange>
	<access>read-only</access>
	</field><field>
	<name>UART_BUSY</name>
	<description>UART Busy. This indicates that a serial transfer is in progress, when cleared indicates that the DW_apb_uart is idle or inactive. 0 - DW_apb_uart is idle or inactive 1 - DW_apb_uart is busy (actively transferring data) Note that it is possible for the UART Busy bit to be cleared even though a new character may have been sent from another device. That is, if the DW_apb_uart has no data in the THR and RBR and there is no transmission in progress and a start bit of a new character has just reached the DW_apb_uart. This is due to the fact that a valid start is not seen until the middle of the bit period and this duration is dependent on the baud divisor that has been programmed. If a second system clock has been implemented (CLOCK_MODE == Enabled) the assertion of this bit will also be delayed by several cycles of the slower clock.</description>
	<bitRange>[0:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register></registers>
</peripheral><peripheral>
	<name>WAKEUP</name>
	<version>1.0</version>
	<description>WAKEUP registers</description>
	<groupName>Peripheral_Registers</groupName>
	<baseAddress>0x50000100</baseAddress>
	<size>0</size>
	<addressBlock>
	<offset>0</offset>
	<size>100</size>
	<usage>registers</usage>
</addressBlock>

	<registers>
	<register>
	<name>WKUP_CLEAR_P0_REG</name>
	<description>Clear event register for P0</description>
	<addressOffset>0x00000048</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>WKUP_CLEAR_P0</name>
	<description>Clear latched value of the GPIOs P0 when corresponding bit is 1</description>
	<bitRange>[15:0]</bitRange>
	<access>write-only</access>
	</field></fields>
</register><register>
	<name>WKUP_CLEAR_P1_REG</name>
	<description>Clear event register for P1</description>
	<addressOffset>0x0000004c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>WKUP_CLEAR_P1</name>
	<description>Clear latched value of the GPIOs P1 when corresponding bit is 1</description>
	<bitRange>[15:0]</bitRange>
	<access>write-only</access>
	</field></fields>
</register><register>
	<name>WKUP_CTRL_REG</name>
	<description>Control register for the wake-up counter</description>
	<addressOffset>0x00000000</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>WKUP_ENABLE_IRQ</name>
	<description>0: no interrupt will be enabled
1: if you have an event an IRQ will be generated </description>
	<bitRange>[7:7]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>WKUP_SFT_KEYHIT</name>
	<description>0 = no effect
1 = emulate key hit. First make this bit 0 before any new key hit can be sensed. </description>
	<bitRange>[6:6]</bitRange>
	<access>read-write</access>
	</field><field>
	<name>WKUP_DEB_VALUE</name>
	<description>Wake-up debounce time. If set to 0, no debouncing will be done.
Debounce time: N*1 ms. N =1..63
Note: Depending on the time key is pressed, debounce time can be less than N*1 ms. To make sure that debounce time is bigger than the programmed time, program this register field to (&quot;desired value&quot;+1). So, if at least 2 ms of debounce time is required, program the register to 3.</description>
	<bitRange>[5:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>WKUP_POL_P0_REG</name>
	<description>Select the sensitivity polarity for each P0 input</description>
	<addressOffset>0x00000028</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>WKUP_POL_P0</name>
	<description>0: enabled input P0_xx will give an event if that input goes high
1: enabled input P0_xx will give an event if that input goes low</description>
	<bitRange>[15:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>WKUP_POL_P1_REG</name>
	<description>Select the sensitivity polarity for each P1 input</description>
	<addressOffset>0x0000002c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>WKUP_POL_P1</name>
	<description>0: enabled input P1_xx will give an event if that input goes high
1: enabled input P1_xx will give an event if that input goes low</description>
	<bitRange>[15:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>WKUP_RESET_IRQ_REG</name>
	<description>Reset wake-up interrupt</description>
	<addressOffset>0x00000008</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>WKUP_IRQ_RST</name>
	<description>Writing any value to this register will reset the interrupt. Reading always returns 0. </description>
	<bitRange>[15:0]</bitRange>
	<access>write-only</access>
	</field></fields>
</register><register>
	<name>WKUP_SEL1_GPIO_P0_REG</name>
	<description>Configure to generate level or edge sensitive IRQ on P0 events</description>
	<addressOffset>0x0000005c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>WKUP_SEL1_GPIO_P0</name>
	<description>0 (level sensitive): If WKUP_SEL_GPIO_P0_REG[x] is 1, generate GPIO_P0_IRQ based on P0_x level.
Fast wake-up is not enabled if the corresponding WKUP_SEL_GPIO_P0_REG[x] is 0 too.
1 (edge sensitive): If WKUP_SEL_GPIO_P0_REG[x] is 1, GPIO_P0_IRQ will be generated only on rising/falling (defined by WKUP_POL_P0_REG) edge on P0_x.
Fast wake-up from the corresponding P0_x input is enabled.</description>
	<bitRange>[15:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>WKUP_SEL1_GPIO_P1_REG</name>
	<description>Configure to generate level or edge sensitive IRQ on P1 events</description>
	<addressOffset>0x00000060</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>WKUP_SEL1_GPIO_P1</name>
	<description>0 (level sensitive): If WKUP_SEL_GPIO_P1_REG[x] is 1, generate GPIO_P1_IRQ based on P1_x level.
Fast wake-up is not enabled if the corresponding WKUP_SEL_GPIO_P1_REG[x] is 0 too.
1 (edge sensitive): If WKUP_SEL_GPIO_P1_REG[x] is 1, GPIO_P1_IRQ will be generated only on rising/falling (defined by WKUP_POL_P1_REG) edge on P1_x.
Fast wake-up from the corresponding P1_x input is enabled.</description>
	<bitRange>[15:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>WKUP_SELECT_P0_REG</name>
	<description>Select which inputs from P0 port can trigger wake-up counter</description>
	<addressOffset>0x00000014</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>WKUP_SELECT_P0</name>
	<description>0: input P0_xx is not enabled for wake-up event
1: input P0_xx is enabled for wake-up event</description>
	<bitRange>[15:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>WKUP_SELECT_P1_REG</name>
	<description>Select which inputs from P1 port can trigger wake-up counter</description>
	<addressOffset>0x00000018</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>WKUP_SELECT_P1</name>
	<description>0: input P1_xx is not enabled for wake-up event
1: input P1_xx is enabled for wake-up event </description>
	<bitRange>[15:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>WKUP_SEL_GPIO_P0_REG</name>
	<description>Enable fast wake-up and enable GPIO_P0_IRQ</description>
	<addressOffset>0x00000054</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>WKUP_SEL_GPIO_P0</name>
	<description>0: No GPIO_P0_IRQ on input P0_x.
Fast wake-up is not enabled if the corresponding WKUP_SEL1_GPIO_P0_REG[x] is 0 too.
1: GPIO_P0_IRQ will be generated on P0_x input event. If WKUP_SEL1_GPIO_P0_REG[x] is 0, IRQ generation is level sensitive. If WKUP_SEL1_GPIO_P0_REG[x] is 1, IRQ generation is edge sensitive (only if there is a change on P0_x input).
Fast wake-up from the corresponding P0_x input is enabled.</description>
	<bitRange>[15:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>WKUP_SEL_GPIO_P1_REG</name>
	<description>Enable fast wake-up and enable GPIO_P1_IRQ</description>
	<addressOffset>0x00000058</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>WKUP_SEL_GPIO_P1</name>
	<description>0: No GPIO_P1_IRQ on input P1_x.
Fast wake-up is not enabled if the corresponding WKUP_SEL1_GPIO_P1_REG[x] is 0 too.
1: GPIO_P1_IRQ will be generated on P1_x input event. If WKUP_SEL1_GPIO_P1_REG[x] is 0, IRQ generation is level sensitive. If WKUP_SEL1_GPIO_P1_REG[x] is 1, IRQ generation is edge sensitive (only if there is a change on P1_x input).
Fast wake-up from the corresponding P1_x input is enabled.</description>
	<bitRange>[15:0]</bitRange>
	<access>read-write</access>
	</field></fields>
</register><register>
	<name>WKUP_STATUS_P0_REG</name>
	<description>Event status register for P0</description>
	<addressOffset>0x0000003c</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>WKUP_STAT_P0</name>
	<description>Contains the latched value of any toggle of the GPIOs Port P0. WKUP_STAT_P0[0] -&gt; P0_00.</description>
	<bitRange>[15:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register><register>
	<name>WKUP_STATUS_P1_REG</name>
	<description>Event status register for P1</description>
	<addressOffset>0x00000040</addressOffset>
	<size>32</size>
	<access>read-write</access>
	<resetValue>0x00000000</resetValue>
	<resetMask>0x0000ffff</resetMask>
	<fields><field>
	<name>WKUP_STAT_P1</name>
	<description>Contains the latched value of any toggle of the GPIOs Port P1. WKUP_STAT_P1[0] -&gt; P1_00.</description>
	<bitRange>[15:0]</bitRange>
	<access>read-only</access>
	</field></fields>
</register></registers>
</peripheral></peripherals>
</device>
